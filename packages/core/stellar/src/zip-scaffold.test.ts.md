# Snapshot report for `src/zip-scaffold.test.ts`

The actual snapshot is saved in `zip-scaffold.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## fungible simple

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};âŠ
      use stellar_fungible::{self as fungible, FungibleToken};âŠ
      âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, ());âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible full

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_fungible::{âŠ
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintableâŠ
      };âŠ
      use stellar_pausable::{self as pausable, Pausable};âŠ
      use stellar_pausable_macros::when_not_paused;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyTokenError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleBurnable for MyToken {âŠ
          #[when_not_paused]âŠ
          fn burn(e: &Env, from: Address, amount: i128) {âŠ
              fungible::burnable::burn(e, &from, amount);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {âŠ
              fungible::burnable::burn_from(e, &spender, &from, amount);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleMintable for MyToken {âŠ
          #[when_not_paused]âŠ
          fn mint(e: &Env, account: Address, amount: i128) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              owner.require_auth();âŠ
              fungible::mintable::mint(e, &account, amount);âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl Pausable for MyToken {âŠ
          fn paused(e: &Env) -> bool {âŠ
              pausable::paused(e)âŠ
          }âŠ
      âŠ
          fn pause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::pause(e, &caller);âŠ
          }âŠ
      âŠ
          fn unpause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::unpause(e, &caller);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible burnable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};âŠ
      use stellar_fungible::{âŠ
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintableâŠ
      };âŠ
      âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleBurnable for MyToken {âŠ
          fn burn(e: &Env, from: Address, amount: i128) {âŠ
              fungible::burnable::burn(e, &from, amount);âŠ
          }âŠ
      âŠ
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {âŠ
              fungible::burnable::burn_from(e, &spender, &from, amount);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible mintable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};âŠ
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleMintable for MyToken {âŠ
          fn mint(e: &Env, account: Address, amount: i128) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              owner.require_auth();âŠ
              fungible::mintable::mint(e, &account, amount);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};âŠ
      use stellar_pausable::{self as pausable, Pausable};âŠ
      use stellar_pausable_macros::when_not_paused;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyTokenError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl Pausable for MyToken {âŠ
          fn paused(e: &Env) -> bool {âŠ
              pausable::paused(e)âŠ
          }âŠ
      âŠ
          fn pause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::pause(e, &caller);âŠ
          }âŠ
      âŠ
          fn unpause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::unpause(e, &caller);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible burnable mintable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};âŠ
      use stellar_fungible::{âŠ
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintableâŠ
      };âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleBurnable for MyToken {âŠ
          fn burn(e: &Env, from: Address, amount: i128) {âŠ
              fungible::burnable::burn(e, &from, amount);âŠ
          }âŠ
      âŠ
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {âŠ
              fungible::burnable::burn_from(e, &spender, &from, amount);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleMintable for MyToken {âŠ
          fn mint(e: &Env, account: Address, amount: i128) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              owner.require_auth();âŠ
              fungible::mintable::mint(e, &account, amount);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible burnable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_fungible::{âŠ
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintableâŠ
      };âŠ
      use stellar_pausable::{self as pausable, Pausable};âŠ
      use stellar_pausable_macros::when_not_paused;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyTokenError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleBurnable for MyToken {âŠ
          #[when_not_paused]âŠ
          fn burn(e: &Env, from: Address, amount: i128) {âŠ
              fungible::burnable::burn(e, &from, amount);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {âŠ
              fungible::burnable::burn_from(e, &spender, &from, amount);âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl Pausable for MyToken {âŠ
          fn paused(e: &Env) -> bool {âŠ
              pausable::paused(e)âŠ
          }âŠ
      âŠ
          fn pause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::pause(e, &caller);âŠ
          }âŠ
      âŠ
          fn unpause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::unpause(e, &caller);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible mintable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};âŠ
      use stellar_pausable::{self as pausable, Pausable};âŠ
      use stellar_pausable_macros::when_not_paused;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyTokenError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleMintable for MyToken {âŠ
          #[when_not_paused]âŠ
          fn mint(e: &Env, account: Address, amount: i128) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              owner.require_auth();âŠ
              fungible::mintable::mint(e, &account, amount);âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl Pausable for MyToken {âŠ
          fn paused(e: &Env) -> bool {âŠ
              pausable::paused(e)âŠ
          }âŠ
      âŠ
          fn pause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::pause(e, &caller);âŠ
          }âŠ
      âŠ
          fn unpause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::unpause(e, &caller);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible upgradable simple

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_fungible::{self as fungible, FungibleToken};âŠ
      use stellar_upgradeable::UpgradeableInternal;âŠ
      use stellar_upgradeable_macros::Upgradeable;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[derive(Upgradeable)]âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyTokenError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      impl UpgradeableInternal for MyToken {âŠ
          fn _require_auth(e: &Env, operator: &Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != *operator {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              operator.require_auth();âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible upgradable full

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_fungible::{âŠ
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintableâŠ
      };âŠ
      use stellar_pausable::{self as pausable, Pausable};âŠ
      use stellar_pausable_macros::when_not_paused;âŠ
      use stellar_upgradeable::UpgradeableInternal;âŠ
      use stellar_upgradeable_macros::Upgradeable;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[derive(Upgradeable)]âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyTokenError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleBurnable for MyToken {âŠ
          #[when_not_paused]âŠ
          fn burn(e: &Env, from: Address, amount: i128) {âŠ
              fungible::burnable::burn(e, &from, amount);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {âŠ
              fungible::burnable::burn_from(e, &spender, &from, amount);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleMintable for MyToken {âŠ
          #[when_not_paused]âŠ
          fn mint(e: &Env, account: Address, amount: i128) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              owner.require_auth();âŠ
              fungible::mintable::mint(e, &account, amount);âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      impl UpgradeableInternal for MyToken {âŠ
          fn _require_auth(e: &Env, operator: &Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != *operator {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              operator.require_auth();âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl Pausable for MyToken {âŠ
          fn paused(e: &Env) -> bool {âŠ
              pausable::paused(e)âŠ
          }âŠ
      âŠ
          fn pause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::pause(e, &caller);âŠ
          }âŠ
      âŠ
          fn unpause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::unpause(e, &caller);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible upgradable burnable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_fungible::{âŠ
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintableâŠ
      };âŠ
      use stellar_upgradeable::UpgradeableInternal;âŠ
      use stellar_upgradeable_macros::Upgradeable;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[derive(Upgradeable)]âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyTokenError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleBurnable for MyToken {âŠ
          fn burn(e: &Env, from: Address, amount: i128) {âŠ
              fungible::burnable::burn(e, &from, amount);âŠ
          }âŠ
      âŠ
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {âŠ
              fungible::burnable::burn_from(e, &spender, &from, amount);âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      impl UpgradeableInternal for MyToken {âŠ
          fn _require_auth(e: &Env, operator: &Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != *operator {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              operator.require_auth();âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible upgradable mintable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};âŠ
      use stellar_upgradeable::UpgradeableInternal;âŠ
      use stellar_upgradeable_macros::Upgradeable;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[derive(Upgradeable)]âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyTokenError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleMintable for MyToken {âŠ
          fn mint(e: &Env, account: Address, amount: i128) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              owner.require_auth();âŠ
              fungible::mintable::mint(e, &account, amount);âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      impl UpgradeableInternal for MyToken {âŠ
          fn _require_auth(e: &Env, operator: &Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != *operator {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              operator.require_auth();âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible upgradable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};âŠ
      use stellar_pausable::{self as pausable, Pausable};âŠ
      use stellar_pausable_macros::when_not_paused;âŠ
      use stellar_upgradeable::UpgradeableInternal;âŠ
      use stellar_upgradeable_macros::Upgradeable;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[derive(Upgradeable)]âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyTokenError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      impl UpgradeableInternal for MyToken {âŠ
          fn _require_auth(e: &Env, operator: &Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != *operator {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              operator.require_auth();âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl Pausable for MyToken {âŠ
          fn paused(e: &Env) -> bool {âŠ
              pausable::paused(e)âŠ
          }âŠ
      âŠ
          fn pause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::pause(e, &caller);âŠ
          }âŠ
      âŠ
          fn unpause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::unpause(e, &caller);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible upgradable burnable mintable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_fungible::{âŠ
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintableâŠ
      };âŠ
      use stellar_upgradeable::UpgradeableInternal;âŠ
      use stellar_upgradeable_macros::Upgradeable;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[derive(Upgradeable)]âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyTokenError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleBurnable for MyToken {âŠ
          fn burn(e: &Env, from: Address, amount: i128) {âŠ
              fungible::burnable::burn(e, &from, amount);âŠ
          }âŠ
      âŠ
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {âŠ
              fungible::burnable::burn_from(e, &spender, &from, amount);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleMintable for MyToken {âŠ
          fn mint(e: &Env, account: Address, amount: i128) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              owner.require_auth();âŠ
              fungible::mintable::mint(e, &account, amount);âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      impl UpgradeableInternal for MyToken {âŠ
          fn _require_auth(e: &Env, operator: &Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != *operator {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              operator.require_auth();âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible upgradable burnable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_fungible::{âŠ
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintableâŠ
      };âŠ
      use stellar_pausable::{self as pausable, Pausable};âŠ
      use stellar_pausable_macros::when_not_paused;âŠ
      use stellar_upgradeable::UpgradeableInternal;âŠ
      use stellar_upgradeable_macros::Upgradeable;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[derive(Upgradeable)]âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyTokenError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleBurnable for MyToken {âŠ
          #[when_not_paused]âŠ
          fn burn(e: &Env, from: Address, amount: i128) {âŠ
              fungible::burnable::burn(e, &from, amount);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {âŠ
              fungible::burnable::burn_from(e, &spender, &from, amount);âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      impl UpgradeableInternal for MyToken {âŠ
          fn _require_auth(e: &Env, operator: &Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != *operator {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              operator.require_auth();âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl Pausable for MyToken {âŠ
          fn paused(e: &Env) -> bool {âŠ
              pausable::paused(e)âŠ
          }âŠ
      âŠ
          fn pause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::pause(e, &caller);âŠ
          }âŠ
      âŠ
          fn unpause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::unpause(e, &caller);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## fungible upgradable mintable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};âŠ
      use stellar_pausable::{self as pausable, Pausable};âŠ
      use stellar_pausable_macros::when_not_paused;âŠ
      use stellar_upgradeable::UpgradeableInternal;âŠ
      use stellar_upgradeable_macros::Upgradeable;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[derive(Upgradeable)]âŠ
      #[contract]âŠ
      pub struct MyToken;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyTokenError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyToken {âŠ
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {âŠ
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));âŠ
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleToken for MyToken {âŠ
          fn total_supply(e: &Env) -> i128 {âŠ
              fungible::total_supply(e)âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, account: Address) -> i128 {âŠ
              fungible::balance(e, &account)âŠ
          }âŠ
      âŠ
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {âŠ
              fungible::allowance(e, &owner, &spender)âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer(e, &from, &to, amount);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {âŠ
              fungible::transfer_from(e, &spender, &from, &to, amount);âŠ
          }âŠ
      âŠ
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {âŠ
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn decimals(e: &Env) -> u32 {âŠ
              fungible::metadata::decimals(e)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              fungible::metadata::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              fungible::metadata::symbol(e)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl FungibleMintable for MyToken {âŠ
          #[when_not_paused]âŠ
          fn mint(e: &Env, account: Address, amount: i128) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              owner.require_auth();âŠ
              fungible::mintable::mint(e, &account, amount);âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      impl UpgradeableInternal for MyToken {âŠ
          fn _require_auth(e: &Env, operator: &Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != *operator {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              operator.require_auth();âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl Pausable for MyToken {âŠ
          fn paused(e: &Env) -> bool {âŠ
              pausable::paused(e)âŠ
          }âŠ
      âŠ
          fn pause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::pause(e, &caller);âŠ
          }âŠ
      âŠ
          fn unpause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyTokenError::Unauthorized);âŠ
              }âŠ
              pausable::unpause(e, &caller);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyToken, MyTokenClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));âŠ
          let client = MyTokenClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## nonfungible simple

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{Address, contract, contractimpl, Env, String};âŠ
      use stellar_non_fungible::{Base, NonFungibleToken};âŠ
      âŠ
      #[contract]âŠ
      pub struct MyNFT;âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyNFT {âŠ
          pub fn __constructor(e: &Env) {âŠ
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleToken for MyNFT {âŠ
          type ContractType = Base;âŠ
      âŠ
          fn owner_of(e: &Env, token_id: u32) -> Address {âŠ
              Self::ContractType::owner_of(e, token_id)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer(e, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, owner: Address) -> u32 {âŠ
              Self::ContractType::balance(e, &owner)âŠ
          }âŠ
      âŠ
          fn approve(âŠ
              e: &Env,âŠ
              approver: Address,âŠ
              approved: Address,âŠ
              token_id: u32,âŠ
              live_until_ledger: u32,âŠ
          ) {âŠ
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {âŠ
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {âŠ
              Self::ContractType::get_approved(e, token_id)âŠ
          }âŠ
      âŠ
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {âŠ
              Self::ContractType::is_approved_for_all(e, &owner, &operator)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              Self::ContractType::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              Self::ContractType::symbol(e)âŠ
          }âŠ
      âŠ
          fn token_uri(e: &Env, token_id: u32) -> String {âŠ
              Self::ContractType::token_uri(e, token_id)âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ Env, String };âŠ
      âŠ
      use crate::contract::{ MyNFT, MyNFTClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyNFT, ());âŠ
          let client = MyNFTClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "non-fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## nonfungible full except sequential mintable enumerable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_non_fungible::{âŠ
          Base, burnable::NonFungibleBurnable, consecutive::{NonFungibleConsecutive, Consecutive},âŠ
          ContractOverrides, NonFungibleTokenâŠ
      };âŠ
      use stellar_pausable::{self as pausable, Pausable};âŠ
      use stellar_pausable_macros::when_not_paused;âŠ
      use stellar_upgradeable::UpgradeableInternal;âŠ
      use stellar_upgradeable_macros::Upgradeable;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[derive(Upgradeable)]âŠ
      #[contract]âŠ
      pub struct MyNFT;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyNFTError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyNFT {âŠ
          pub fn __constructor(e: &Env, owner: Address) {âŠ
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          pub fn batch_mint(e: &Env, to: Address, amount: u32) -> u32 {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              owner.require_auth();âŠ
              Consecutive::batch_mint(e, &to, amount)âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleToken for MyNFT {âŠ
          type ContractType = Consecutive;âŠ
      âŠ
          fn owner_of(e: &Env, token_id: u32) -> Address {âŠ
              Self::ContractType::owner_of(e, token_id)âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer(e, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, owner: Address) -> u32 {âŠ
              Self::ContractType::balance(e, &owner)âŠ
          }âŠ
      âŠ
          fn approve(âŠ
              e: &Env,âŠ
              approver: Address,âŠ
              approved: Address,âŠ
              token_id: u32,âŠ
              live_until_ledger: u32,âŠ
          ) {âŠ
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {âŠ
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {âŠ
              Self::ContractType::get_approved(e, token_id)âŠ
          }âŠ
      âŠ
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {âŠ
              Self::ContractType::is_approved_for_all(e, &owner, &operator)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              Self::ContractType::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              Self::ContractType::symbol(e)âŠ
          }âŠ
      âŠ
          fn token_uri(e: &Env, token_id: u32) -> String {âŠ
              Self::ContractType::token_uri(e, token_id)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleBurnable for MyNFT {âŠ
          #[when_not_paused]âŠ
          fn burn(e: &Env, from: Address, token_id: u32) {âŠ
              Self::ContractType::burn(e, &from, token_id);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {âŠ
              Self::ContractType::burn_from(e, &spender, &from, token_id);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleConsecutive for MyNFT {}âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      impl UpgradeableInternal for MyNFT {âŠ
          fn _require_auth(e: &Env, operator: &Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != *operator {âŠ
                  panic_with_error!(e, MyNFTError::Unauthorized);âŠ
              }âŠ
              operator.require_auth();âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl Pausable for MyNFT {âŠ
          fn paused(e: &Env) -> bool {âŠ
              pausable::paused(e)âŠ
          }âŠ
      âŠ
          fn pause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyNFTError::Unauthorized);âŠ
              }âŠ
              pausable::pause(e, &caller);âŠ
          }âŠ
      âŠ
          fn unpause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyNFTError::Unauthorized);âŠ
              }âŠ
              pausable::unpause(e, &caller);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyNFT, MyNFTClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));âŠ
          let client = MyNFTClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "non-fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## nonfungible burnable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{Address, contract, contractimpl, Env, String};âŠ
      use stellar_non_fungible::{Base, burnable::NonFungibleBurnable, NonFungibleToken};âŠ
      âŠ
      #[contract]âŠ
      pub struct MyNFT;âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyNFT {âŠ
          pub fn __constructor(e: &Env) {âŠ
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleToken for MyNFT {âŠ
          type ContractType = Base;âŠ
      âŠ
          fn owner_of(e: &Env, token_id: u32) -> Address {âŠ
              Self::ContractType::owner_of(e, token_id)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer(e, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, owner: Address) -> u32 {âŠ
              Self::ContractType::balance(e, &owner)âŠ
          }âŠ
      âŠ
          fn approve(âŠ
              e: &Env,âŠ
              approver: Address,âŠ
              approved: Address,âŠ
              token_id: u32,âŠ
              live_until_ledger: u32,âŠ
          ) {âŠ
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {âŠ
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {âŠ
              Self::ContractType::get_approved(e, token_id)âŠ
          }âŠ
      âŠ
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {âŠ
              Self::ContractType::is_approved_for_all(e, &owner, &operator)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              Self::ContractType::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              Self::ContractType::symbol(e)âŠ
          }âŠ
      âŠ
          fn token_uri(e: &Env, token_id: u32) -> String {âŠ
              Self::ContractType::token_uri(e, token_id)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleBurnable for MyNFT {âŠ
          fn burn(e: &Env, from: Address, token_id: u32) {âŠ
              Self::ContractType::burn(e, &from, token_id);âŠ
          }âŠ
      âŠ
          fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {âŠ
              Self::ContractType::burn_from(e, &spender, &from, token_id);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ Env, String };âŠ
      âŠ
      use crate::contract::{ MyNFT, MyNFTClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyNFT, ());âŠ
          let client = MyNFTClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "non-fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## nonfungible consecutive

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};âŠ
      use stellar_non_fungible::{âŠ
          Base, consecutive::{NonFungibleConsecutive, Consecutive}, ContractOverrides,âŠ
          NonFungibleTokenâŠ
      };âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[contract]âŠ
      pub struct MyNFT;âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyNFT {âŠ
          pub fn __constructor(e: &Env, owner: Address) {âŠ
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      âŠ
          pub fn batch_mint(e: &Env, to: Address, amount: u32) -> u32 {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              owner.require_auth();âŠ
              Consecutive::batch_mint(e, &to, amount)âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleToken for MyNFT {âŠ
          type ContractType = Consecutive;âŠ
      âŠ
          fn owner_of(e: &Env, token_id: u32) -> Address {âŠ
              Self::ContractType::owner_of(e, token_id)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer(e, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, owner: Address) -> u32 {âŠ
              Self::ContractType::balance(e, &owner)âŠ
          }âŠ
      âŠ
          fn approve(âŠ
              e: &Env,âŠ
              approver: Address,âŠ
              approved: Address,âŠ
              token_id: u32,âŠ
              live_until_ledger: u32,âŠ
          ) {âŠ
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {âŠ
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {âŠ
              Self::ContractType::get_approved(e, token_id)âŠ
          }âŠ
      âŠ
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {âŠ
              Self::ContractType::is_approved_for_all(e, &owner, &operator)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              Self::ContractType::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              Self::ContractType::symbol(e)âŠ
          }âŠ
      âŠ
          fn token_uri(e: &Env, token_id: u32) -> String {âŠ
              Self::ContractType::token_uri(e, token_id)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleConsecutive for MyNFT {}âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyNFT, MyNFTClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));âŠ
          let client = MyNFTClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "non-fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## nonfungible pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_non_fungible::{Base, NonFungibleToken};âŠ
      use stellar_pausable::{self as pausable, Pausable};âŠ
      use stellar_pausable_macros::when_not_paused;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[contract]âŠ
      pub struct MyNFT;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyNFTError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyNFT {âŠ
          pub fn __constructor(e: &Env, owner: Address) {âŠ
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleToken for MyNFT {âŠ
          type ContractType = Base;âŠ
      âŠ
          fn owner_of(e: &Env, token_id: u32) -> Address {âŠ
              Self::ContractType::owner_of(e, token_id)âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer(e, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, owner: Address) -> u32 {âŠ
              Self::ContractType::balance(e, &owner)âŠ
          }âŠ
      âŠ
          fn approve(âŠ
              e: &Env,âŠ
              approver: Address,âŠ
              approved: Address,âŠ
              token_id: u32,âŠ
              live_until_ledger: u32,âŠ
          ) {âŠ
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {âŠ
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {âŠ
              Self::ContractType::get_approved(e, token_id)âŠ
          }âŠ
      âŠ
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {âŠ
              Self::ContractType::is_approved_for_all(e, &owner, &operator)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              Self::ContractType::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              Self::ContractType::symbol(e)âŠ
          }âŠ
      âŠ
          fn token_uri(e: &Env, token_id: u32) -> String {âŠ
              Self::ContractType::token_uri(e, token_id)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl Pausable for MyNFT {âŠ
          fn paused(e: &Env) -> bool {âŠ
              pausable::paused(e)âŠ
          }âŠ
      âŠ
          fn pause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyNFTError::Unauthorized);âŠ
              }âŠ
              pausable::pause(e, &caller);âŠ
          }âŠ
      âŠ
          fn unpause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyNFTError::Unauthorized);âŠ
              }âŠ
              pausable::unpause(e, &caller);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyNFT, MyNFTClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));âŠ
          let client = MyNFTClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "non-fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## nonfungible upgradeable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_non_fungible::{Base, NonFungibleToken};âŠ
      use stellar_upgradeable::UpgradeableInternal;âŠ
      use stellar_upgradeable_macros::Upgradeable;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[derive(Upgradeable)]âŠ
      #[contract]âŠ
      pub struct MyNFT;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyNFTError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyNFT {âŠ
          pub fn __constructor(e: &Env, owner: Address) {âŠ
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleToken for MyNFT {âŠ
          type ContractType = Base;âŠ
      âŠ
          fn owner_of(e: &Env, token_id: u32) -> Address {âŠ
              Self::ContractType::owner_of(e, token_id)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer(e, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, owner: Address) -> u32 {âŠ
              Self::ContractType::balance(e, &owner)âŠ
          }âŠ
      âŠ
          fn approve(âŠ
              e: &Env,âŠ
              approver: Address,âŠ
              approved: Address,âŠ
              token_id: u32,âŠ
              live_until_ledger: u32,âŠ
          ) {âŠ
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {âŠ
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {âŠ
              Self::ContractType::get_approved(e, token_id)âŠ
          }âŠ
      âŠ
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {âŠ
              Self::ContractType::is_approved_for_all(e, &owner, &operator)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              Self::ContractType::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              Self::ContractType::symbol(e)âŠ
          }âŠ
      âŠ
          fn token_uri(e: &Env, token_id: u32) -> String {âŠ
              Self::ContractType::token_uri(e, token_id)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      impl UpgradeableInternal for MyNFT {âŠ
          fn _require_auth(e: &Env, operator: &Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != *operator {âŠ
                  panic_with_error!(e, MyNFTError::Unauthorized);âŠ
              }âŠ
              operator.require_auth();âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyNFT, MyNFTClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));âŠ
          let client = MyNFTClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "non-fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## nonfungible sequential

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{Address, contract, contractimpl, Env, String};âŠ
      use stellar_non_fungible::{Base, NonFungibleToken};âŠ
      âŠ
      #[contract]âŠ
      pub struct MyNFT;âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyNFT {âŠ
          pub fn __constructor(e: &Env) {âŠ
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleToken for MyNFT {âŠ
          type ContractType = Base;âŠ
      âŠ
          fn owner_of(e: &Env, token_id: u32) -> Address {âŠ
              Self::ContractType::owner_of(e, token_id)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer(e, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, owner: Address) -> u32 {âŠ
              Self::ContractType::balance(e, &owner)âŠ
          }âŠ
      âŠ
          fn approve(âŠ
              e: &Env,âŠ
              approver: Address,âŠ
              approved: Address,âŠ
              token_id: u32,âŠ
              live_until_ledger: u32,âŠ
          ) {âŠ
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {âŠ
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {âŠ
              Self::ContractType::get_approved(e, token_id)âŠ
          }âŠ
      âŠ
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {âŠ
              Self::ContractType::is_approved_for_all(e, &owner, &operator)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              Self::ContractType::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              Self::ContractType::symbol(e)âŠ
          }âŠ
      âŠ
          fn token_uri(e: &Env, token_id: u32) -> String {âŠ
              Self::ContractType::token_uri(e, token_id)âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ Env, String };âŠ
      âŠ
      use crate::contract::{ MyNFT, MyNFTClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyNFT, ());âŠ
          let client = MyNFTClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "non-fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## nonfungible burnable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_non_fungible::{Base, burnable::NonFungibleBurnable, NonFungibleToken};âŠ
      use stellar_pausable::{self as pausable, Pausable};âŠ
      use stellar_pausable_macros::when_not_paused;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[contract]âŠ
      pub struct MyNFT;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyNFTError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyNFT {âŠ
          pub fn __constructor(e: &Env, owner: Address) {âŠ
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleToken for MyNFT {âŠ
          type ContractType = Base;âŠ
      âŠ
          fn owner_of(e: &Env, token_id: u32) -> Address {âŠ
              Self::ContractType::owner_of(e, token_id)âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer(e, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, owner: Address) -> u32 {âŠ
              Self::ContractType::balance(e, &owner)âŠ
          }âŠ
      âŠ
          fn approve(âŠ
              e: &Env,âŠ
              approver: Address,âŠ
              approved: Address,âŠ
              token_id: u32,âŠ
              live_until_ledger: u32,âŠ
          ) {âŠ
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {âŠ
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {âŠ
              Self::ContractType::get_approved(e, token_id)âŠ
          }âŠ
      âŠ
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {âŠ
              Self::ContractType::is_approved_for_all(e, &owner, &operator)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              Self::ContractType::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              Self::ContractType::symbol(e)âŠ
          }âŠ
      âŠ
          fn token_uri(e: &Env, token_id: u32) -> String {âŠ
              Self::ContractType::token_uri(e, token_id)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleBurnable for MyNFT {âŠ
          #[when_not_paused]âŠ
          fn burn(e: &Env, from: Address, token_id: u32) {âŠ
              Self::ContractType::burn(e, &from, token_id);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {âŠ
              Self::ContractType::burn_from(e, &spender, &from, token_id);âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl Pausable for MyNFT {âŠ
          fn paused(e: &Env) -> bool {âŠ
              pausable::paused(e)âŠ
          }âŠ
      âŠ
          fn pause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyNFTError::Unauthorized);âŠ
              }âŠ
              pausable::pause(e, &caller);âŠ
          }âŠ
      âŠ
          fn unpause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyNFTError::Unauthorized);âŠ
              }âŠ
              pausable::unpause(e, &caller);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyNFT, MyNFTClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));âŠ
          let client = MyNFTClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "non-fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## nonfungible enumerable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{Address, contract, contractimpl, Env, String};âŠ
      use stellar_default_impl_macro::default_impl;âŠ
      use stellar_non_fungible::{âŠ
          Base, ContractOverrides, enumerable::{NonFungibleEnumerable, Enumerable}, NonFungibleTokenâŠ
      };âŠ
      âŠ
      #[contract]âŠ
      pub struct MyNFT;âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyNFT {âŠ
          pub fn __constructor(e: &Env) {âŠ
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleToken for MyNFT {âŠ
          type ContractType = Enumerable;âŠ
      âŠ
          fn owner_of(e: &Env, token_id: u32) -> Address {âŠ
              Self::ContractType::owner_of(e, token_id)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer(e, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, owner: Address) -> u32 {âŠ
              Self::ContractType::balance(e, &owner)âŠ
          }âŠ
      âŠ
          fn approve(âŠ
              e: &Env,âŠ
              approver: Address,âŠ
              approved: Address,âŠ
              token_id: u32,âŠ
              live_until_ledger: u32,âŠ
          ) {âŠ
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {âŠ
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {âŠ
              Self::ContractType::get_approved(e, token_id)âŠ
          }âŠ
      âŠ
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {âŠ
              Self::ContractType::is_approved_for_all(e, &owner, &operator)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              Self::ContractType::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              Self::ContractType::symbol(e)âŠ
          }âŠ
      âŠ
          fn token_uri(e: &Env, token_id: u32) -> String {âŠ
              Self::ContractType::token_uri(e, token_id)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[default_impl]âŠ
      #[contractimpl]âŠ
      impl NonFungibleEnumerable for MyNFT {}âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ Env, String };âŠ
      âŠ
      use crate::contract::{ MyNFT, MyNFTClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyNFT, ());âŠ
          let client = MyNFTClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "non-fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## nonfungible burnable enumerable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{Address, contract, contractimpl, Env, String};âŠ
      use stellar_default_impl_macro::default_impl;âŠ
      use stellar_non_fungible::{âŠ
          Base, burnable::NonFungibleBurnable, ContractOverrides,âŠ
          enumerable::{NonFungibleEnumerable, Enumerable}, NonFungibleTokenâŠ
      };âŠ
      âŠ
      #[contract]âŠ
      pub struct MyNFT;âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyNFT {âŠ
          pub fn __constructor(e: &Env) {âŠ
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleToken for MyNFT {âŠ
          type ContractType = Enumerable;âŠ
      âŠ
          fn owner_of(e: &Env, token_id: u32) -> Address {âŠ
              Self::ContractType::owner_of(e, token_id)âŠ
          }âŠ
      âŠ
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer(e, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, owner: Address) -> u32 {âŠ
              Self::ContractType::balance(e, &owner)âŠ
          }âŠ
      âŠ
          fn approve(âŠ
              e: &Env,âŠ
              approver: Address,âŠ
              approved: Address,âŠ
              token_id: u32,âŠ
              live_until_ledger: u32,âŠ
          ) {âŠ
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {âŠ
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {âŠ
              Self::ContractType::get_approved(e, token_id)âŠ
          }âŠ
      âŠ
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {âŠ
              Self::ContractType::is_approved_for_all(e, &owner, &operator)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              Self::ContractType::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              Self::ContractType::symbol(e)âŠ
          }âŠ
      âŠ
          fn token_uri(e: &Env, token_id: u32) -> String {âŠ
              Self::ContractType::token_uri(e, token_id)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleBurnable for MyNFT {âŠ
          fn burn(e: &Env, from: Address, token_id: u32) {âŠ
              Self::ContractType::burn(e, &from, token_id);âŠ
          }âŠ
      âŠ
          fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {âŠ
              Self::ContractType::burn_from(e, &spender, &from, token_id);âŠ
          }âŠ
      }âŠ
      âŠ
      #[default_impl]âŠ
      #[contractimpl]âŠ
      impl NonFungibleEnumerable for MyNFT {}âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ Env, String };âŠ
      âŠ
      use crate::contract::{ MyNFT, MyNFTClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyNFT, ());âŠ
          let client = MyNFTClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "non-fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]

## nonfungible full except consecutive

> Snapshot 1

    [
      `// SPDX-License-Identifier: MITâŠ
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0âŠ
      âŠ
      âŠ
      use soroban_sdk::{âŠ
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,âŠ
          symbol_shortâŠ
      };âŠ
      use stellar_default_impl_macro::default_impl;âŠ
      use stellar_non_fungible::{âŠ
          Base, burnable::NonFungibleBurnable, ContractOverrides,âŠ
          enumerable::{NonFungibleEnumerable, Enumerable}, NonFungibleTokenâŠ
      };âŠ
      use stellar_pausable::{self as pausable, Pausable};âŠ
      use stellar_pausable_macros::when_not_paused;âŠ
      use stellar_upgradeable::UpgradeableInternal;âŠ
      use stellar_upgradeable_macros::Upgradeable;âŠ
      âŠ
      const OWNER: Symbol = symbol_short!("OWNER");âŠ
      âŠ
      #[derive(Upgradeable)]âŠ
      #[contract]âŠ
      pub struct MyNFT;âŠ
      âŠ
      #[contracterror]âŠ
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]âŠ
      #[repr(u32)]âŠ
      pub enum MyNFTError {âŠ
          Unauthorized = 1,âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl MyNFT {âŠ
          pub fn __constructor(e: &Env, owner: Address) {âŠ
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));âŠ
              e.storage().instance().set(&OWNER, &owner);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          pub fn sequential_mint(e: &Env, to: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              owner.require_auth();âŠ
              Enumerable::sequential_mint(e, &to);âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleToken for MyNFT {âŠ
          type ContractType = Enumerable;âŠ
      âŠ
          fn owner_of(e: &Env, token_id: u32) -> Address {âŠ
              Self::ContractType::owner_of(e, token_id)âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer(e, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {âŠ
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);âŠ
          }âŠ
      âŠ
          fn balance(e: &Env, owner: Address) -> u32 {âŠ
              Self::ContractType::balance(e, &owner)âŠ
          }âŠ
      âŠ
          fn approve(âŠ
              e: &Env,âŠ
              approver: Address,âŠ
              approved: Address,âŠ
              token_id: u32,âŠ
              live_until_ledger: u32,âŠ
          ) {âŠ
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {âŠ
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);âŠ
          }âŠ
      âŠ
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {âŠ
              Self::ContractType::get_approved(e, token_id)âŠ
          }âŠ
      âŠ
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {âŠ
              Self::ContractType::is_approved_for_all(e, &owner, &operator)âŠ
          }âŠ
      âŠ
          fn name(e: &Env) -> String {âŠ
              Self::ContractType::name(e)âŠ
          }âŠ
      âŠ
          fn symbol(e: &Env) -> String {âŠ
              Self::ContractType::symbol(e)âŠ
          }âŠ
      âŠ
          fn token_uri(e: &Env, token_id: u32) -> String {âŠ
              Self::ContractType::token_uri(e, token_id)âŠ
          }âŠ
      }âŠ
      âŠ
      //âŠ
      // ExtensionsâŠ
      //âŠ
      âŠ
      #[contractimpl]âŠ
      impl NonFungibleBurnable for MyNFT {âŠ
          #[when_not_paused]âŠ
          fn burn(e: &Env, from: Address, token_id: u32) {âŠ
              Self::ContractType::burn(e, &from, token_id);âŠ
          }âŠ
      âŠ
          #[when_not_paused]âŠ
          fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {âŠ
              Self::ContractType::burn_from(e, &spender, &from, token_id);âŠ
          }âŠ
      }âŠ
      âŠ
      #[default_impl]âŠ
      #[contractimpl]âŠ
      impl NonFungibleEnumerable for MyNFT {}âŠ
      âŠ
      //âŠ
      // UtilsâŠ
      //âŠ
      âŠ
      impl UpgradeableInternal for MyNFT {âŠ
          fn _require_auth(e: &Env, operator: &Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != *operator {âŠ
                  panic_with_error!(e, MyNFTError::Unauthorized);âŠ
              }âŠ
              operator.require_auth();âŠ
          }âŠ
      }âŠ
      âŠ
      #[contractimpl]âŠ
      impl Pausable for MyNFT {âŠ
          fn paused(e: &Env) -> bool {âŠ
              pausable::paused(e)âŠ
          }âŠ
      âŠ
          fn pause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyNFTError::Unauthorized);âŠ
              }âŠ
              pausable::pause(e, &caller);âŠ
          }âŠ
      âŠ
          fn unpause(e: &Env, caller: Address) {âŠ
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");âŠ
              if owner != caller {âŠ
                  panic_with_error!(e, MyNFTError::Unauthorized);âŠ
              }âŠ
              pausable::unpause(e, &caller);âŠ
          }âŠ
      }âŠ
      `,
      `#![cfg(test)]âŠ
      âŠ
      extern crate std;âŠ
      âŠ
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };âŠ
      âŠ
      use crate::contract::{ MyNFT, MyNFTClient };âŠ
      âŠ
      #[test]âŠ
      fn initial_state() {âŠ
          let env = Env::default();âŠ
      âŠ
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));âŠ
          let client = MyNFTClient::new(&env, &contract_addr);âŠ
      âŠ
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));âŠ
      }âŠ
      âŠ
      // Add more tests bellowâŠ
      `,
      `#![no_std]âŠ
      #![allow(dead_code)]âŠ
      âŠ
      mod contract;âŠ
      mod test;âŠ
      `,
      `[package]âŠ
      name = "non-fungible-contract"âŠ
      edition.workspace = trueâŠ
      license.workspace = trueâŠ
      publish = falseâŠ
      version.workspace = trueâŠ
      âŠ
      [lib]âŠ
      crate-type = ["cdylib"]âŠ
      doctest = falseâŠ
      âŠ
      [dependencies]âŠ
      stellar-default-impl-macro = { workspace = true }âŠ
      stellar-fungible = { workspace = true }âŠ
      stellar-non-fungible = { workspace = true }âŠ
      stellar-pausable = { workspace = true }âŠ
      stellar-pausable-macros = { workspace = true }âŠ
      stellar-upgradeable = { workspace = true }âŠ
      stellar-upgradeable-macros = { workspace = true }âŠ
      soroban-sdk = { workspace = true }âŠ
      âŠ
      [dev-dependencies]âŠ
      soroban-sdk = { workspace = true, features = ["testutils"] }âŠ
      âŠ
      `,
      `#!/usr/bin/env bashâŠ
      #âŠ
      # setup.shâŠ
      # âŠ
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the projectâŠ
      âŠ
      check_is_installed() {âŠ
        if ! which "$1" &> /dev/null; thenâŠ
          echo "âŒ $1 command not found."âŠ
          echo "Install $2 and try again, you can find installation guides in the README."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      scaffold() {âŠ
        tmp_folder="tmp"âŠ
        stellar scaffold init "$tmp_folder"âŠ
      âŠ
        rm -rf "$tmp_folder/contracts"âŠ
      âŠ
        local current_directoryâŠ
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"âŠ
      âŠ
        shopt -s dotglobâŠ
      âŠ
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/âŠ
        rm -rf "$current_directory/$tmp_folder"âŠ
      }âŠ
      âŠ
      init_git(){âŠ
        git initâŠ
        git add .âŠ
        git commit -m "openzeppelin: add wizard output" --quietâŠ
      }âŠ
      âŠ
      âŠ
      # Update environments.toml: remove original contracts and insert wizard's contractâŠ
      setup_environment() {âŠ
        local file="environments.toml"âŠ
        local tempâŠ
        temp="$(mktemp)"âŠ
      âŠ
        local in_dev_contracts=0âŠ
        local skip_entry=0âŠ
        local contract_entry_inserted=0âŠ
        insert_contract_entry() {âŠ
          {âŠ
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\âŠ
              "client = true" "" \\âŠ
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\âŠ
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\âŠ
              "# \\\`stellar contract deploy\\\`" \\âŠ
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\âŠ
              "# TODO add appropriate values for for the constructors arguments" \\âŠ
              "constructor_args = \\"\\"\\"" \\âŠ
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\âŠ
              "\\"\\"\\"" \\âŠ
              ""âŠ
          } >> "$temp"âŠ
        }âŠ
      âŠ
        while IFS= read -r line; doâŠ
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; thenâŠ
            insert_contract_entryâŠ
            contract_entry_inserted=1âŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; thenâŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            in_dev_contracts=1âŠ
            skip_entry=0âŠ
            continueâŠ
          fiâŠ
      âŠ
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; thenâŠ
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; thenâŠ
              skip_entry=1âŠ
              in_dev_contracts=0âŠ
              continueâŠ
            fiâŠ
            in_dev_contracts=0âŠ
            skip_entry=0âŠ
            printf '%s\\n' "$line" >> "$temp"âŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( skip_entry )); thenâŠ
            continueâŠ
          fiâŠ
      âŠ
          if (( in_dev_contracts )); thenâŠ
            if [[ $line =~ ^[[:space:]]*# ]]; thenâŠ
              printf '%s\\n' "$line" >> "$temp"âŠ
            fiâŠ
            continueâŠ
          fiâŠ
      âŠ
          printf '%s\\n' "$line" >> "$temp"âŠ
        done < "$file"âŠ
      âŠ
        mv "$temp" "$file"âŠ
      }âŠ
      âŠ
      âŠ
      update_cargo() {âŠ
        cp Cargo.toml Cargo.toml.bakâŠ
      âŠ
        cat <<EOF > deps.tmpâŠ
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }âŠ
      soroban-sdk = { version = "22.0.8" }âŠ
      âŠ
      EOFâŠ
      âŠ
        awk 'âŠ
          BEGIN {âŠ
            inserted = 0âŠ
            deps = ""âŠ
            while ((getline line < "deps.tmp") > 0) {âŠ
              deps = deps line "\\n"âŠ
            }âŠ
            close("deps.tmp")âŠ
          }âŠ
          /^\\[workspace.dependencies\\]/ {âŠ
            in_deps = 1âŠ
            printâŠ
            if (!inserted) {âŠ
              printf "%s", depsâŠ
              inserted = 1âŠ
            }âŠ
            nextâŠ
          }âŠ
          /^\\[/ { in_deps = 0 }âŠ
          in_deps { next }âŠ
          { print }âŠ
        ' Cargo.toml.bak > Cargo.tomlâŠ
      âŠ
        rm deps.tmpâŠ
        rm Cargo.toml.bakâŠ
      }âŠ
      âŠ
      build_contracts() {âŠ
        cargo buildâŠ
      }âŠ
      âŠ
      install_npm_dependencies() {âŠ
        if ! npm install --silent; thenâŠ
          echo "âŒ Failed to set up the project."âŠ
          exit 1âŠ
        fiâŠ
      }âŠ
      âŠ
      âŠ
      ################âŠ
      ##### Start ####âŠ
      ################âŠ
      âŠ
      echo "âš™ï¸ Checking dependencies requirement"âŠ
      check_is_installed git "Git"âŠ
      check_is_installed cargo "Rust"âŠ
      check_is_installed stellar "Scaffold"âŠ
      check_is_installed docker "Docker"âŠ
      check_is_installed node "Node"âŠ
      âŠ
      âŠ
      if ! [ -f "environments.toml" ]âŠ
      thenâŠ
        echo "ğŸ—ï¸ Building Scaffold project"âŠ
      âŠ
        scaffoldâŠ
        âŠ
        setup_environmentâŠ
      âŠ
        update_cargoâŠ
      âŠ
        build_contractsâŠ
      âŠ
        install_npm_dependenciesâŠ
      âŠ
        init_gitâŠ
      âŠ
        echo "âœ… Installation complete" âŠ
      elseâŠ
        echo "âœ… Scaffold project already initialized."âŠ
      fiâŠ
      `,
      `# Sample Scaffold ProjectâŠ
      âŠ
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.âŠ
      âŠ
      ## Installing dependenciesâŠ
      âŠ
      - See [Git installation guide](https://github.com/git-guides/install-git).âŠ
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).âŠ
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).âŠ
      - See [Docker installation guide](https://docs.docker.com/engine/install/).âŠ
      - See [Node installation guide](https://nodejs.org/en/download).âŠ
      âŠ
      ## Initializing the projectâŠ
      âŠ
      \`\`\`âŠ
      bash setup.shâŠ
      \`\`\`âŠ
      âŠ
      ## Resolve any TODOs âŠ
      âŠ
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).âŠ
      âŠ
      âŠ
      ## Testing the contractâŠ
      âŠ
      \`\`\`âŠ
      cargo testâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contractâŠ
      âŠ
      \`\`\`âŠ
      stellar scaffold watch --build-clientsâŠ
      \`\`\`âŠ
      âŠ
      ## Deploying the contract and run the Scaffold UI appâŠ
      âŠ
      \`\`\`âŠ
      npm run devâŠ
      \`\`\`âŠ
      `,
    ]
