# Snapshot report for `src/zip-scaffold.test.ts`

The actual snapshot is saved in `zip-scaffold.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## fungible simple

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};␊
      use stellar_fungible::{self as fungible, FungibleToken};␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, ());␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible full

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          #[when_not_paused]␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible burnable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible mintable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};␊
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible burnable mintable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible burnable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible mintable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          #[when_not_paused]␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible upgradable simple

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{self as fungible, FungibleToken};␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible upgradable full

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          #[when_not_paused]␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible upgradable burnable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible upgradable mintable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible upgradable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible upgradable burnable mintable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible upgradable burnable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{␊
          self as fungible, burnable::FungibleBurnable, FungibleToken, mintable::FungibleMintable␊
      };␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleBurnable for MyToken {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, amount: i128) {␊
              fungible::burnable::burn(e, &from, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
              fungible::burnable::burn_from(e, &spender, &from, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## fungible upgradable mintable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_fungible::{self as fungible, FungibleToken, mintable::FungibleMintable};␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyToken;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyTokenError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyToken {␊
          pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
              fungible::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
              fungible::mintable::mint(e, &recipient, 2000000000000000000000);␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl FungibleToken for MyToken {␊
          fn total_supply(e: &Env) -> i128 {␊
              fungible::total_supply(e)␊
          }␊
      ␊
          fn balance(e: &Env, account: Address) -> i128 {␊
              fungible::balance(e, &account)␊
          }␊
      ␊
          fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
              fungible::allowance(e, &owner, &spender)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
              fungible::transfer(e, &from, &to, amount);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
              fungible::transfer_from(e, &spender, &from, &to, amount);␊
          }␊
      ␊
          fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
              fungible::approve(e, &owner, &spender, amount, live_until_ledger);␊
          }␊
      ␊
          fn decimals(e: &Env) -> u32 {␊
              fungible::metadata::decimals(e)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              fungible::metadata::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              fungible::metadata::symbol(e)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl FungibleMintable for MyToken {␊
          #[when_not_paused]␊
          fn mint(e: &Env, account: Address, amount: i128) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              fungible::mintable::mint(e, &account, amount);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyToken {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyToken {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyTokenError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyToken, MyTokenClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyToken, (Address::generate(&env),Address::generate(&env)));␊
          let client = MyTokenClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyToken"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--recipient \\"ADD_RECIPIENT_ADDRESS_HERE\\" --owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## nonfungible simple

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
      use stellar_non_fungible::{Base, NonFungibleToken};␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env) {␊
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Base;␊
      ␊
          fn owner_of(e: &Env, token_id: u32) -> Address {␊
              Self::ContractType::owner_of(e, token_id)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      ␊
          fn balance(e: &Env, owner: Address) -> u32 {␊
              Self::ContractType::balance(e, &owner)␊
          }␊
      ␊
          fn approve(␊
              e: &Env,␊
              approver: Address,␊
              approved: Address,␊
              token_id: u32,␊
              live_until_ledger: u32,␊
          ) {␊
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
          }␊
      ␊
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
          }␊
      ␊
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
              Self::ContractType::get_approved(e, token_id)␊
          }␊
      ␊
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
              Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              Self::ContractType::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              Self::ContractType::symbol(e)␊
          }␊
      ␊
          fn token_uri(e: &Env, token_id: u32) -> String {␊
              Self::ContractType::token_uri(e, token_id)␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, ());␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## nonfungible full except sequential mintable enumerable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_non_fungible::{␊
          Base, burnable::NonFungibleBurnable, consecutive::{NonFungibleConsecutive, Consecutive},␊
          ContractOverrides, NonFungibleToken␊
      };␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyNFTError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      ␊
          #[when_not_paused]␊
          pub fn batch_mint(e: &Env, to: Address, amount: u32) -> u32 {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              Consecutive::batch_mint(e, &to, amount)␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Consecutive;␊
      ␊
          fn owner_of(e: &Env, token_id: u32) -> Address {␊
              Self::ContractType::owner_of(e, token_id)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      ␊
          fn balance(e: &Env, owner: Address) -> u32 {␊
              Self::ContractType::balance(e, &owner)␊
          }␊
      ␊
          fn approve(␊
              e: &Env,␊
              approver: Address,␊
              approved: Address,␊
              token_id: u32,␊
              live_until_ledger: u32,␊
          ) {␊
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
          }␊
      ␊
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
          }␊
      ␊
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
              Self::ContractType::get_approved(e, token_id)␊
          }␊
      ␊
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
              Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              Self::ContractType::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              Self::ContractType::symbol(e)␊
          }␊
      ␊
          fn token_uri(e: &Env, token_id: u32) -> String {␊
              Self::ContractType::token_uri(e, token_id)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl NonFungibleBurnable for MyNFT {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, token_id: u32) {␊
              Self::ContractType::burn(e, &from, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
              Self::ContractType::burn_from(e, &spender, &from, token_id);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl NonFungibleConsecutive for MyNFT {}␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyNFT {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyNFTError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyNFT {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyNFTError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyNFTError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## nonfungible burnable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
      use stellar_non_fungible::{Base, burnable::NonFungibleBurnable, NonFungibleToken};␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env) {␊
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Base;␊
      ␊
          fn owner_of(e: &Env, token_id: u32) -> Address {␊
              Self::ContractType::owner_of(e, token_id)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      ␊
          fn balance(e: &Env, owner: Address) -> u32 {␊
              Self::ContractType::balance(e, &owner)␊
          }␊
      ␊
          fn approve(␊
              e: &Env,␊
              approver: Address,␊
              approved: Address,␊
              token_id: u32,␊
              live_until_ledger: u32,␊
          ) {␊
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
          }␊
      ␊
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
          }␊
      ␊
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
              Self::ContractType::get_approved(e, token_id)␊
          }␊
      ␊
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
              Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              Self::ContractType::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              Self::ContractType::symbol(e)␊
          }␊
      ␊
          fn token_uri(e: &Env, token_id: u32) -> String {␊
              Self::ContractType::token_uri(e, token_id)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl NonFungibleBurnable for MyNFT {␊
          fn burn(e: &Env, from: Address, token_id: u32) {␊
              Self::ContractType::burn(e, &from, token_id);␊
          }␊
      ␊
          fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
              Self::ContractType::burn_from(e, &spender, &from, token_id);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, ());␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## nonfungible consecutive

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};␊
      use stellar_non_fungible::{␊
          Base, consecutive::{NonFungibleConsecutive, Consecutive}, ContractOverrides,␊
          NonFungibleToken␊
      };␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      ␊
          pub fn batch_mint(e: &Env, to: Address, amount: u32) -> u32 {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              Consecutive::batch_mint(e, &to, amount)␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Consecutive;␊
      ␊
          fn owner_of(e: &Env, token_id: u32) -> Address {␊
              Self::ContractType::owner_of(e, token_id)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      ␊
          fn balance(e: &Env, owner: Address) -> u32 {␊
              Self::ContractType::balance(e, &owner)␊
          }␊
      ␊
          fn approve(␊
              e: &Env,␊
              approver: Address,␊
              approved: Address,␊
              token_id: u32,␊
              live_until_ledger: u32,␊
          ) {␊
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
          }␊
      ␊
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
          }␊
      ␊
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
              Self::ContractType::get_approved(e, token_id)␊
          }␊
      ␊
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
              Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              Self::ContractType::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              Self::ContractType::symbol(e)␊
          }␊
      ␊
          fn token_uri(e: &Env, token_id: u32) -> String {␊
              Self::ContractType::token_uri(e, token_id)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl NonFungibleConsecutive for MyNFT {}␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## nonfungible pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_non_fungible::{Base, NonFungibleToken};␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyNFTError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Base;␊
      ␊
          fn owner_of(e: &Env, token_id: u32) -> Address {␊
              Self::ContractType::owner_of(e, token_id)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      ␊
          fn balance(e: &Env, owner: Address) -> u32 {␊
              Self::ContractType::balance(e, &owner)␊
          }␊
      ␊
          fn approve(␊
              e: &Env,␊
              approver: Address,␊
              approved: Address,␊
              token_id: u32,␊
              live_until_ledger: u32,␊
          ) {␊
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
          }␊
      ␊
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
          }␊
      ␊
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
              Self::ContractType::get_approved(e, token_id)␊
          }␊
      ␊
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
              Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              Self::ContractType::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              Self::ContractType::symbol(e)␊
          }␊
      ␊
          fn token_uri(e: &Env, token_id: u32) -> String {␊
              Self::ContractType::token_uri(e, token_id)␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyNFT {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyNFTError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyNFTError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## nonfungible upgradeable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_non_fungible::{Base, NonFungibleToken};␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyNFTError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Base;␊
      ␊
          fn owner_of(e: &Env, token_id: u32) -> Address {␊
              Self::ContractType::owner_of(e, token_id)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      ␊
          fn balance(e: &Env, owner: Address) -> u32 {␊
              Self::ContractType::balance(e, &owner)␊
          }␊
      ␊
          fn approve(␊
              e: &Env,␊
              approver: Address,␊
              approved: Address,␊
              token_id: u32,␊
              live_until_ledger: u32,␊
          ) {␊
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
          }␊
      ␊
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
          }␊
      ␊
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
              Self::ContractType::get_approved(e, token_id)␊
          }␊
      ␊
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
              Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              Self::ContractType::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              Self::ContractType::symbol(e)␊
          }␊
      ␊
          fn token_uri(e: &Env, token_id: u32) -> String {␊
              Self::ContractType::token_uri(e, token_id)␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyNFT {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyNFTError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## nonfungible sequential

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
      use stellar_non_fungible::{Base, NonFungibleToken};␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env) {␊
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Base;␊
      ␊
          fn owner_of(e: &Env, token_id: u32) -> Address {␊
              Self::ContractType::owner_of(e, token_id)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      ␊
          fn balance(e: &Env, owner: Address) -> u32 {␊
              Self::ContractType::balance(e, &owner)␊
          }␊
      ␊
          fn approve(␊
              e: &Env,␊
              approver: Address,␊
              approved: Address,␊
              token_id: u32,␊
              live_until_ledger: u32,␊
          ) {␊
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
          }␊
      ␊
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
          }␊
      ␊
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
              Self::ContractType::get_approved(e, token_id)␊
          }␊
      ␊
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
              Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              Self::ContractType::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              Self::ContractType::symbol(e)␊
          }␊
      ␊
          fn token_uri(e: &Env, token_id: u32) -> String {␊
              Self::ContractType::token_uri(e, token_id)␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, ());␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## nonfungible burnable pausable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_non_fungible::{Base, burnable::NonFungibleBurnable, NonFungibleToken};␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyNFTError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Base;␊
      ␊
          fn owner_of(e: &Env, token_id: u32) -> Address {␊
              Self::ContractType::owner_of(e, token_id)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      ␊
          fn balance(e: &Env, owner: Address) -> u32 {␊
              Self::ContractType::balance(e, &owner)␊
          }␊
      ␊
          fn approve(␊
              e: &Env,␊
              approver: Address,␊
              approved: Address,␊
              token_id: u32,␊
              live_until_ledger: u32,␊
          ) {␊
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
          }␊
      ␊
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
          }␊
      ␊
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
              Self::ContractType::get_approved(e, token_id)␊
          }␊
      ␊
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
              Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              Self::ContractType::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              Self::ContractType::symbol(e)␊
          }␊
      ␊
          fn token_uri(e: &Env, token_id: u32) -> String {␊
              Self::ContractType::token_uri(e, token_id)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl NonFungibleBurnable for MyNFT {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, token_id: u32) {␊
              Self::ContractType::burn(e, &from, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
              Self::ContractType::burn_from(e, &spender, &from, token_id);␊
          }␊
      }␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyNFT {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyNFTError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyNFTError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## nonfungible enumerable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
      use stellar_default_impl_macro::default_impl;␊
      use stellar_non_fungible::{␊
          Base, ContractOverrides, enumerable::{NonFungibleEnumerable, Enumerable}, NonFungibleToken␊
      };␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env) {␊
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Enumerable;␊
      ␊
          fn owner_of(e: &Env, token_id: u32) -> Address {␊
              Self::ContractType::owner_of(e, token_id)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      ␊
          fn balance(e: &Env, owner: Address) -> u32 {␊
              Self::ContractType::balance(e, &owner)␊
          }␊
      ␊
          fn approve(␊
              e: &Env,␊
              approver: Address,␊
              approved: Address,␊
              token_id: u32,␊
              live_until_ledger: u32,␊
          ) {␊
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
          }␊
      ␊
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
          }␊
      ␊
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
              Self::ContractType::get_approved(e, token_id)␊
          }␊
      ␊
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
              Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              Self::ContractType::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              Self::ContractType::symbol(e)␊
          }␊
      ␊
          fn token_uri(e: &Env, token_id: u32) -> String {␊
              Self::ContractType::token_uri(e, token_id)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleEnumerable for MyNFT {}␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, ());␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## nonfungible burnable enumerable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
      use stellar_default_impl_macro::default_impl;␊
      use stellar_non_fungible::{␊
          Base, burnable::NonFungibleBurnable, ContractOverrides,␊
          enumerable::{NonFungibleEnumerable, Enumerable}, NonFungibleToken␊
      };␊
      ␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env) {␊
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Enumerable;␊
      ␊
          fn owner_of(e: &Env, token_id: u32) -> Address {␊
              Self::ContractType::owner_of(e, token_id)␊
          }␊
      ␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      ␊
          fn balance(e: &Env, owner: Address) -> u32 {␊
              Self::ContractType::balance(e, &owner)␊
          }␊
      ␊
          fn approve(␊
              e: &Env,␊
              approver: Address,␊
              approved: Address,␊
              token_id: u32,␊
              live_until_ledger: u32,␊
          ) {␊
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
          }␊
      ␊
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
          }␊
      ␊
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
              Self::ContractType::get_approved(e, token_id)␊
          }␊
      ␊
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
              Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              Self::ContractType::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              Self::ContractType::symbol(e)␊
          }␊
      ␊
          fn token_uri(e: &Env, token_id: u32) -> String {␊
              Self::ContractType::token_uri(e, token_id)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl NonFungibleBurnable for MyNFT {␊
          fn burn(e: &Env, from: Address, token_id: u32) {␊
              Self::ContractType::burn(e, &from, token_id);␊
          }␊
      ␊
          fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
              Self::ContractType::burn_from(e, &spender, &from, token_id);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleEnumerable for MyNFT {}␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, ());␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]

## nonfungible full except consecutive

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
      ␊
      ␊
      use soroban_sdk::{␊
          Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
          symbol_short␊
      };␊
      use stellar_default_impl_macro::default_impl;␊
      use stellar_non_fungible::{␊
          Base, burnable::NonFungibleBurnable, ContractOverrides,␊
          enumerable::{NonFungibleEnumerable, Enumerable}, NonFungibleToken␊
      };␊
      use stellar_pausable::{self as pausable, Pausable};␊
      use stellar_pausable_macros::when_not_paused;␊
      use stellar_upgradeable::UpgradeableInternal;␊
      use stellar_upgradeable_macros::Upgradeable;␊
      ␊
      const OWNER: Symbol = symbol_short!("OWNER");␊
      ␊
      #[derive(Upgradeable)]␊
      #[contract]␊
      pub struct MyNFT;␊
      ␊
      #[contracterror]␊
      #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
      #[repr(u32)]␊
      pub enum MyNFTError {␊
          Unauthorized = 1,␊
      }␊
      ␊
      #[contractimpl]␊
      impl MyNFT {␊
          pub fn __constructor(e: &Env, owner: Address) {␊
              Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyNFT"), String::from_str(e, "MNFT"));␊
              e.storage().instance().set(&OWNER, &owner);␊
          }␊
      ␊
          #[when_not_paused]␊
          pub fn sequential_mint(e: &Env, to: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              owner.require_auth();␊
              Enumerable::sequential_mint(e, &to);␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl NonFungibleToken for MyNFT {␊
          type ContractType = Enumerable;␊
      ␊
          fn owner_of(e: &Env, token_id: u32) -> Address {␊
              Self::ContractType::owner_of(e, token_id)␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer(e, &from, &to, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
              Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
          }␊
      ␊
          fn balance(e: &Env, owner: Address) -> u32 {␊
              Self::ContractType::balance(e, &owner)␊
          }␊
      ␊
          fn approve(␊
              e: &Env,␊
              approver: Address,␊
              approved: Address,␊
              token_id: u32,␊
              live_until_ledger: u32,␊
          ) {␊
              Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
          }␊
      ␊
          fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
              Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
          }␊
      ␊
          fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
              Self::ContractType::get_approved(e, token_id)␊
          }␊
      ␊
          fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
              Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
          }␊
      ␊
          fn name(e: &Env) -> String {␊
              Self::ContractType::name(e)␊
          }␊
      ␊
          fn symbol(e: &Env) -> String {␊
              Self::ContractType::symbol(e)␊
          }␊
      ␊
          fn token_uri(e: &Env, token_id: u32) -> String {␊
              Self::ContractType::token_uri(e, token_id)␊
          }␊
      }␊
      ␊
      //␊
      // Extensions␊
      //␊
      ␊
      #[contractimpl]␊
      impl NonFungibleBurnable for MyNFT {␊
          #[when_not_paused]␊
          fn burn(e: &Env, from: Address, token_id: u32) {␊
              Self::ContractType::burn(e, &from, token_id);␊
          }␊
      ␊
          #[when_not_paused]␊
          fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
              Self::ContractType::burn_from(e, &spender, &from, token_id);␊
          }␊
      }␊
      ␊
      #[default_impl]␊
      #[contractimpl]␊
      impl NonFungibleEnumerable for MyNFT {}␊
      ␊
      //␊
      // Utils␊
      //␊
      ␊
      impl UpgradeableInternal for MyNFT {␊
          fn _require_auth(e: &Env, operator: &Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != *operator {␊
                  panic_with_error!(e, MyNFTError::Unauthorized);␊
              }␊
              operator.require_auth();␊
          }␊
      }␊
      ␊
      #[contractimpl]␊
      impl Pausable for MyNFT {␊
          fn paused(e: &Env) -> bool {␊
              pausable::paused(e)␊
          }␊
      ␊
          fn pause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyNFTError::Unauthorized);␊
              }␊
              pausable::pause(e, &caller);␊
          }␊
      ␊
          fn unpause(e: &Env, caller: Address) {␊
              let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
              if owner != caller {␊
                  panic_with_error!(e, MyNFTError::Unauthorized);␊
              }␊
              pausable::unpause(e, &caller);␊
          }␊
      }␊
      `,
      `#![cfg(test)]␊
      ␊
      extern crate std;␊
      ␊
      use soroban_sdk::{ testutils::Address as _, Address, Env, String };␊
      ␊
      use crate::contract::{ MyNFT, MyNFTClient };␊
      ␊
      #[test]␊
      fn initial_state() {␊
          let env = Env::default();␊
      ␊
          let contract_addr = env.register(MyNFT, (Address::generate(&env),));␊
          let client = MyNFTClient::new(&env, &contract_addr);␊
      ␊
          assert_eq!(client.name(), String::from_str(&env, "MyNFT"));␊
      }␊
      ␊
      // Add more tests bellow␊
      `,
      `#![no_std]␊
      #![allow(dead_code)]␊
      ␊
      mod contract;␊
      mod test;␊
      `,
      `[package]␊
      name = "non-fungible-contract"␊
      edition.workspace = true␊
      license.workspace = true␊
      publish = false␊
      version.workspace = true␊
      ␊
      [lib]␊
      crate-type = ["cdylib"]␊
      doctest = false␊
      ␊
      [dependencies]␊
      stellar-default-impl-macro = { workspace = true }␊
      stellar-fungible = { workspace = true }␊
      stellar-non-fungible = { workspace = true }␊
      stellar-pausable = { workspace = true }␊
      stellar-pausable-macros = { workspace = true }␊
      stellar-upgradeable = { workspace = true }␊
      stellar-upgradeable-macros = { workspace = true }␊
      soroban-sdk = { workspace = true }␊
      ␊
      [dev-dependencies]␊
      soroban-sdk = { workspace = true, features = ["testutils"] }␊
      ␊
      `,
      `#!/usr/bin/env bash␊
      #␊
      # setup.sh␊
      # ␊
      # This script is meant to set up a Scaffold project and insert the Wizard's contracts in the project␊
      ␊
      check_is_installed() {␊
        if ! which "$1" &> /dev/null; then␊
          echo "❌ $1 command not found."␊
          echo "Install $2 and try again, you can find installation guides in the README."␊
          exit 1␊
        fi␊
      }␊
      ␊
      scaffold() {␊
        tmp_folder="tmp"␊
        stellar scaffold init "$tmp_folder"␊
      ␊
        rm -rf "$tmp_folder/contracts"␊
      ␊
        local current_directory␊
        current_directory="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"␊
      ␊
        shopt -s dotglob␊
      ␊
        cp -a "$current_directory/$tmp_folder"/. "$current_directory"/␊
        rm -rf "$current_directory/$tmp_folder"␊
      }␊
      ␊
      init_git(){␊
        git init␊
        git add .␊
        git commit -m "openzeppelin: add wizard output" --quiet␊
      }␊
      ␊
      ␊
      # Update environments.toml: remove original contracts and insert wizard's contract␊
      setup_environment() {␊
        local file="environments.toml"␊
        local temp␊
        temp="$(mktemp)"␊
      ␊
        local in_dev_contracts=0␊
        local skip_entry=0␊
        local contract_entry_inserted=0␊
        insert_contract_entry() {␊
          {␊
            printf '%s\\n' "[development.contracts.non_fungible_contract]" \\␊
              "client = true" "" \\␊
              "# If your contract has a \\\`__constructor\\\`, specify your arguments to it here." \\␊
              "# These are the same arguments you could pass after the \\\`--\\\` in a call to" \\␊
              "# \\\`stellar contract deploy\\\`" \\␊
              "# Only available in \\\`development\\\` and \\\`test\\\` environments" \\␊
              "# TODO add appropriate values for for the constructors arguments" \\␊
              "constructor_args = \\"\\"\\"" \\␊
              "--owner \\"ADD_OWNER_ADDRESS_HERE\\"" \\␊
              "\\"\\"\\"" \\␊
              ""␊
          } >> "$temp"␊
        }␊
      ␊
        while IFS= read -r line; do␊
          if [[ $contract_entry_inserted -eq 0 && $line == '[staging.network]' ]]; then␊
            insert_contract_entry␊
            contract_entry_inserted=1␊
          fi␊
      ␊
          if [[ $line =~ ^\\[development\\.contracts\\]$ ]]; then␊
            printf '%s\\n' "$line" >> "$temp"␊
            in_dev_contracts=1␊
            skip_entry=0␊
            continue␊
          fi␊
      ␊
          if [[ $line =~ ^\\[[^]]+\\]$ ]]; then␊
            if (( in_dev_contracts )) && [[ $line =~ ^\\[development\\.contracts\\..+\\]$ ]]; then␊
              skip_entry=1␊
              in_dev_contracts=0␊
              continue␊
            fi␊
            in_dev_contracts=0␊
            skip_entry=0␊
            printf '%s\\n' "$line" >> "$temp"␊
            continue␊
          fi␊
      ␊
          if (( skip_entry )); then␊
            continue␊
          fi␊
      ␊
          if (( in_dev_contracts )); then␊
            if [[ $line =~ ^[[:space:]]*# ]]; then␊
              printf '%s\\n' "$line" >> "$temp"␊
            fi␊
            continue␊
          fi␊
      ␊
          printf '%s\\n' "$line" >> "$temp"␊
        done < "$file"␊
      ␊
        mv "$temp" "$file"␊
      }␊
      ␊
      ␊
      update_cargo() {␊
        cp Cargo.toml Cargo.toml.bak␊
      ␊
        cat <<EOF > deps.tmp␊
      stellar-default-impl-macro = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-non-fungible = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-pausable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      stellar-upgradeable-macros = { git = "https://github.com/OpenZeppelin/stellar-contracts", tag = "v0.2.0" }␊
      soroban-sdk = { version = "22.0.8" }␊
      ␊
      EOF␊
      ␊
        awk '␊
          BEGIN {␊
            inserted = 0␊
            deps = ""␊
            while ((getline line < "deps.tmp") > 0) {␊
              deps = deps line "\\n"␊
            }␊
            close("deps.tmp")␊
          }␊
          /^\\[workspace.dependencies\\]/ {␊
            in_deps = 1␊
            print␊
            if (!inserted) {␊
              printf "%s", deps␊
              inserted = 1␊
            }␊
            next␊
          }␊
          /^\\[/ { in_deps = 0 }␊
          in_deps { next }␊
          { print }␊
        ' Cargo.toml.bak > Cargo.toml␊
      ␊
        rm deps.tmp␊
        rm Cargo.toml.bak␊
      }␊
      ␊
      build_contracts() {␊
        cargo build␊
      }␊
      ␊
      install_npm_dependencies() {␊
        if ! npm install --silent; then␊
          echo "❌ Failed to set up the project."␊
          exit 1␊
        fi␊
      }␊
      ␊
      ␊
      ################␊
      ##### Start ####␊
      ################␊
      ␊
      echo "⚙️ Checking dependencies requirement"␊
      check_is_installed git "Git"␊
      check_is_installed cargo "Rust"␊
      check_is_installed stellar "Scaffold"␊
      check_is_installed docker "Docker"␊
      check_is_installed node "Node"␊
      ␊
      ␊
      if ! [ -f "environments.toml" ]␊
      then␊
        echo "🏗️ Building Scaffold project"␊
      ␊
        scaffold␊
        ␊
        setup_environment␊
      ␊
        update_cargo␊
      ␊
        build_contracts␊
      ␊
        install_npm_dependencies␊
      ␊
        init_git␊
      ␊
        echo "✅ Installation complete" ␊
      else␊
        echo "✅ Scaffold project already initialized."␊
      fi␊
      `,
      `# Sample Scaffold Project␊
      ␊
      This project demonstrates a basic Scaffold use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that initiate a Stellar Scaffold project with this contract. [Scaffold Stellar](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#scaffold-stellar) is a convention-over-configuration toolkit for blockchain and distributed application development on the Stellar network. It provides a seamless development experience through CLI tools, smart contract management, and deployment utilities.␊
      ␊
      ## Installing dependencies␊
      ␊
      - See [Git installation guide](https://github.com/git-guides/install-git).␊
      - See [Rust installation guide](https://www.rust-lang.org/tools/install).␊
      - See [Scaffold CLI installation guide](https://github.com/AhaLabs/scaffold-stellar?tab=readme-ov-file#quick-start).␊
      - See [Docker installation guide](https://docs.docker.com/engine/install/).␊
      - See [Node installation guide](https://nodejs.org/en/download).␊
      ␊
      ## Initializing the project␊
      ␊
      \`\`\`␊
      bash setup.sh␊
      \`\`\`␊
      ␊
      ## Resolve any TODOs ␊
      ␊
      Search for any TODO comments in the project and resolve them (search for TODO with your code editor).␊
      ␊
      ␊
      ## Testing the contract␊
      ␊
      \`\`\`␊
      cargo test␊
      \`\`\`␊
      ␊
      ## Deploying the contract␊
      ␊
      \`\`\`␊
      stellar scaffold watch --build-clients␊
      \`\`\`␊
      ␊
      ## Deploying the contract and run the Scaffold UI app␊
      ␊
      \`\`\`␊
      npm run dev␊
      \`\`\`␊
      `,
    ]
