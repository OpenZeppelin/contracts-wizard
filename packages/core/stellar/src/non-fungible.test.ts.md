# Snapshot report for `src/non-fungible.test.ts`

The actual snapshot is saved in `non-fungible.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## basic non-fungible

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
    use stellar_non_fungible::{Base, NonFungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    `

## non-fungible burnable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
    use stellar_non_fungible::{Base, burnable::NonFungibleBurnable, NonFungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl NonFungibleBurnable for MyToken {␊
        fn burn(e: &Env, from: Address, token_id: u32) {␊
            Self::ContractType::burn(e, &from, token_id);␊
        }␊
    ␊
        fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
            Self::ContractType::burn_from(e, &spender, &from, token_id);␊
        }␊
    }␊
    `

## non-fungible pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
        symbol_short␊
    };␊
    use stellar_non_fungible::{Base, NonFungibleToken};␊
    use stellar_pausable::{self as pausable, Pausable};␊
    use stellar_pausable_macros::when_not_paused;␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contracterror]␊
    #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
    #[repr(u32)]␊
    pub enum MyTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `

## non-fungible burnable pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
        symbol_short␊
    };␊
    use stellar_non_fungible::{Base, burnable::NonFungibleBurnable, NonFungibleToken};␊
    use stellar_pausable::{self as pausable, Pausable};␊
    use stellar_pausable_macros::when_not_paused;␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contracterror]␊
    #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
    #[repr(u32)]␊
    pub enum MyTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl NonFungibleBurnable for MyToken {␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, token_id: u32) {␊
            Self::ContractType::burn(e, &from, token_id);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
            Self::ContractType::burn_from(e, &spender, &from, token_id);␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `

## non-fungible mintable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};␊
    use stellar_non_fungible::{Base, Base::mint, NonFungibleToken};␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    ␊
        pub fn mint(e: &Env, to: Address, token_id: u32) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            owner.require_auth();␊
            Base::mint(e, &to, token_id);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    `

## non-fungible enumerable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
    use stellar_non_fungible::{␊
        Base, enumerable::{NonFungibleEnumerable, Enumerable}, NonFungibleToken␊
    };␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for MyToken {␊
        type ContractType = Enumerable;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[defaultimpl]␊
    #[contractimpl]␊
    impl NonFungibleEnumerable for MyToken {}␊
    `

## non-fungible consecutive

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};␊
    use stellar_non_fungible::{␊
        Base, consecutive::{NonFungibleConsecutive, Consecutive}, ContractOverrides,␊
        NonFungibleToken␊
    };␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    ␊
        pub fn batch_mint(e: &Env, to: Address, amount: u32) -> u32 {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            owner.require_auth();␊
            Consecutive::batch_mint(e, &to, amount)␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for MyToken {␊
        type ContractType = Consecutive;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl NonFungibleConsecutive for MyToken {}␊
    `

## non-fungible consecutive burnable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};␊
    use stellar_non_fungible::{␊
        Base, burnable::NonFungibleBurnable, consecutive::{NonFungibleConsecutive, Consecutive},␊
        ContractOverrides, NonFungibleToken␊
    };␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    ␊
        pub fn batch_mint(e: &Env, to: Address, amount: u32) -> u32 {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            owner.require_auth();␊
            Consecutive::batch_mint(e, &to, amount)␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for MyToken {␊
        type ContractType = Consecutive;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl NonFungibleBurnable for MyToken {␊
        fn burn(e: &Env, from: Address, token_id: u32) {␊
            Self::ContractType::burn(e, &from, token_id);␊
        }␊
    ␊
        fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
            Self::ContractType::burn_from(e, &spender, &from, token_id);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleConsecutive for MyToken {}␊
    `

## non-fungible consecutive pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
        symbol_short␊
    };␊
    use stellar_non_fungible::{␊
        Base, consecutive::{NonFungibleConsecutive, Consecutive}, ContractOverrides,␊
        NonFungibleToken␊
    };␊
    use stellar_pausable::{self as pausable, Pausable};␊
    use stellar_pausable_macros::when_not_paused;␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contracterror]␊
    #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
    #[repr(u32)]␊
    pub enum MyTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    ␊
        #[when_not_paused]␊
        pub fn batch_mint(e: &Env, to: Address, amount: u32) -> u32 {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            owner.require_auth();␊
            Consecutive::batch_mint(e, &to, amount)␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for MyToken {␊
        type ContractType = Consecutive;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl NonFungibleConsecutive for MyToken {}␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `

## non-fungible consecutive burnable pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
        symbol_short␊
    };␊
    use stellar_non_fungible::{␊
        Base, burnable::NonFungibleBurnable, consecutive::{NonFungibleConsecutive, Consecutive},␊
        ContractOverrides, NonFungibleToken␊
    };␊
    use stellar_pausable::{self as pausable, Pausable};␊
    use stellar_pausable_macros::when_not_paused;␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contracterror]␊
    #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
    #[repr(u32)]␊
    pub enum MyTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    ␊
        #[when_not_paused]␊
        pub fn batch_mint(e: &Env, to: Address, amount: u32) -> u32 {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            owner.require_auth();␊
            Consecutive::batch_mint(e, &to, amount)␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for MyToken {␊
        type ContractType = Consecutive;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl NonFungibleBurnable for MyToken {␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, token_id: u32) {␊
            Self::ContractType::burn(e, &from, token_id);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
            Self::ContractType::burn_from(e, &spender, &from, token_id);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleConsecutive for MyToken {}␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `

## non-fungible sequential

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
    use stellar_non_fungible::{Base, NonFungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    `

## non-fungible upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
        symbol_short␊
    };␊
    use stellar_non_fungible::{Base, NonFungibleToken};␊
    use stellar_upgradeable::UpgradeableInternal;␊
    use stellar_upgradeable_macros::Upgradeable;␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[derive(Upgradeable)]␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contracterror]␊
    #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
    #[repr(u32)]␊
    pub enum MyTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    impl UpgradeableInternal for MyToken {␊
        fn _require_auth(e: &Env, operator: &Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != *operator {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            operator.require_auth();␊
        }␊
    }␊
    `

## non-fungible with compatible options

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
        symbol_short␊
    };␊
    use stellar_non_fungible::{␊
        Base, burnable::NonFungibleBurnable, enumerable::{NonFungibleEnumerable, Enumerable},␊
        NonFungibleToken␊
    };␊
    use stellar_pausable::{self as pausable, Pausable};␊
    use stellar_pausable_macros::when_not_paused;␊
    use stellar_upgradeable::UpgradeableInternal;␊
    use stellar_upgradeable_macros::Upgradeable;␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[derive(Upgradeable)]␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contracterror]␊
    #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
    #[repr(u32)]␊
    pub enum MyTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    ␊
        #[when_not_paused]␊
        pub fn non_sequential_mint(e: &Env, to: Address, token_id: u32) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            owner.require_auth();␊
            Enumerable::non_sequential_mint(e, &to, token_id);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for MyToken {␊
        type ContractType = Enumerable;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl NonFungibleBurnable for MyToken {␊
        type ContractType = Enumerable;␊
    ␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, token_id: u32) {␊
            Self::ContractType::burn(e, &from, token_id);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
            Self::ContractType::burn_from(e, &spender, &from, token_id);␊
        }␊
    }␊
    ␊
    #[defaultimpl]␊
    #[contractimpl]␊
    impl NonFungibleEnumerable for MyToken {}␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    impl UpgradeableInternal for MyToken {␊
        fn _require_auth(e: &Env, operator: &Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != *operator {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            operator.require_auth();␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `

## non-fungible - complex name

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
        symbol_short␊
    };␊
    use stellar_non_fungible::{Base, burnable::NonFungibleBurnable, NonFungibleToken};␊
    use stellar_pausable::{self as pausable, Pausable};␊
    use stellar_pausable_macros::when_not_paused;␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct CustomToken;␊
    ␊
    #[contracterror]␊
    #[derive(Copy, Clone, Debug, Eq, PartialEq, PartialOrd, Ord)]␊
    #[repr(u32)]␊
    pub enum CustomTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl CustomToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "Custom  $ Token"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for CustomToken {␊
        type ContractType = Base;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl NonFungibleBurnable for CustomToken {␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, token_id: u32) {␊
            Self::ContractType::burn(e, &from, token_id);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, token_id: u32) {␊
            Self::ContractType::burn_from(e, &spender, &from, token_id);␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl]␊
    impl Pausable for CustomToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, CustomTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, CustomTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `
