# Snapshot report for `src/fungible.test.ts`

The actual snapshot is saved in `fungible.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## basic fungible

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.6.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contractimpl, Env, MuxedAddress, String, Symbol, Vec␊
    };␊
    use stellar_tokens::fungible::{Base, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            Base::set_metadata(e, 7, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
    }␊
    `

## fungible burnable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.6.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contractimpl, Env, MuxedAddress, String, Symbol, Vec␊
    };␊
    use stellar_tokens::fungible::{Base, burnable::FungibleBurnable, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            Base::set_metadata(e, 7, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleBurnable for MyToken {}␊
    `

## fungible pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.6.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contractimpl, Env, MuxedAddress, String, Symbol, Vec␊
    };␊
    use stellar_access::ownable::{self as ownable, Ownable};␊
    use stellar_contract_utils::pausable::{self as pausable, Pausable};␊
    use stellar_macros::{only_owner, when_not_paused};␊
    use stellar_tokens::fungible::{Base, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            Base::set_metadata(e, 7, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            ownable::set_owner(e, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: MuxedAddress, amount: i128) {␊
            Self::ContractType::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl Ownable for MyToken {}␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        #[only_owner]␊
        fn pause(e: &Env, _caller: Address) {␊
            pausable::pause(e);␊
        }␊
    ␊
        #[only_owner]␊
        fn unpause(e: &Env, _caller: Address) {␊
            pausable::unpause(e);␊
        }␊
    }␊
    `

## fungible burnable pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.6.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contractimpl, Env, MuxedAddress, String, Symbol, Vec␊
    };␊
    use stellar_access::ownable::{self as ownable, Ownable};␊
    use stellar_contract_utils::pausable::{self as pausable, Pausable};␊
    use stellar_macros::{only_owner, when_not_paused};␊
    use stellar_tokens::fungible::{Base, burnable::FungibleBurnable, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            Base::set_metadata(e, 7, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            ownable::set_owner(e, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: MuxedAddress, amount: i128) {␊
            Self::ContractType::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleBurnable for MyToken {␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, amount: i128) {␊
            Base::burn(e, &from, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
            Base::burn_from(e, &spender, &from, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl Ownable for MyToken {}␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        #[only_owner]␊
        fn pause(e: &Env, _caller: Address) {␊
            pausable::pause(e);␊
        }␊
    ␊
        #[only_owner]␊
        fn unpause(e: &Env, _caller: Address) {␊
            pausable::unpause(e);␊
        }␊
    }␊
    `

## fungible preminted

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.6.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contractimpl, Env, MuxedAddress, String, Symbol, Vec␊
    };␊
    use stellar_tokens::fungible::{Base, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, recipient: Address) {␊
            Base::set_metadata(e, 7, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            Base::mint(e, &recipient, 10000000000);␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
    }␊
    `

## fungible premint of 0

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.6.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contractimpl, Env, MuxedAddress, String, Symbol, Vec␊
    };␊
    use stellar_tokens::fungible::{Base, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            Base::set_metadata(e, 7, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
    }␊
    `

## fungible mintable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.6.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contractimpl, Env, MuxedAddress, String, Symbol, Vec␊
    };␊
    use stellar_tokens::fungible::{Base, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            Base::set_metadata(e, 7, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
    }␊
    `

## fungible ownable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.6.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contractimpl, Env, MuxedAddress, String, Symbol, Vec␊
    };␊
    use stellar_access::ownable::{self as ownable, Ownable};␊
    use stellar_tokens::fungible::{Base, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            Base::set_metadata(e, 7, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            ownable::set_owner(e, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl Ownable for MyToken {}␊
    `

## fungible roles

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.6.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contractimpl, Env, MuxedAddress, String, Symbol, Vec␊
    };␊
    use stellar_access::access_control::{self as access_control, AccessControl};␊
    use stellar_tokens::fungible::{Base, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, admin: Address) {␊
            Base::set_metadata(e, 7, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            access_control::set_admin(e, &admin);␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl AccessControl for MyToken {}␊
    `

## fungible full - ownable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.6.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contractimpl, Env, MuxedAddress, String, Symbol, Vec␊
    };␊
    use stellar_access::ownable::{self as ownable, Ownable};␊
    use stellar_contract_utils::pausable::{self as pausable, Pausable};␊
    use stellar_macros::{only_owner, when_not_paused};␊
    use stellar_tokens::fungible::{Base, burnable::FungibleBurnable, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
            Base::set_metadata(e, 7, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            Base::mint(e, &recipient, 20000000000);␊
            ownable::set_owner(e, &owner);␊
        }␊
    ␊
        #[only_owner]␊
        #[when_not_paused]␊
        pub fn mint(e: &Env, account: Address, amount: i128) {␊
            Base::mint(e, &account, amount);␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: MuxedAddress, amount: i128) {␊
            Self::ContractType::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleBurnable for MyToken {␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, amount: i128) {␊
            Base::burn(e, &from, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
            Base::burn_from(e, &spender, &from, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl Ownable for MyToken {}␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        #[only_owner]␊
        fn pause(e: &Env, _caller: Address) {␊
            pausable::pause(e);␊
        }␊
    ␊
        #[only_owner]␊
        fn unpause(e: &Env, _caller: Address) {␊
            pausable::unpause(e);␊
        }␊
    }␊
    `

## fungible full - roles

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.6.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contractimpl, Env, MuxedAddress, String, Symbol, Vec␊
    };␊
    use stellar_access::access_control::{self as access_control, AccessControl};␊
    use stellar_contract_utils::pausable::{self as pausable, Pausable};␊
    use stellar_contract_utils::upgradeable::UpgradeableInternal;␊
    use stellar_macros::{only_role, Upgradeable, when_not_paused};␊
    use stellar_tokens::fungible::{Base, burnable::FungibleBurnable, FungibleToken};␊
    ␊
    #[derive(Upgradeable)]␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(␊
            e: &Env,␊
            recipient: Address,␊
            admin: Address,␊
            pauser: Address,␊
            upgrader: Address,␊
            minter: Address,␊
        ) {␊
            Base::set_metadata(e, 7, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            Base::mint(e, &recipient, 20000000000);␊
            access_control::set_admin(e, &admin);␊
            access_control::grant_role_no_auth(e, &pauser, &Symbol::new(e, "pauser"), &admin);␊
            access_control::grant_role_no_auth(e, &upgrader, &Symbol::new(e, "upgrader"), &admin);␊
            access_control::grant_role_no_auth(e, &minter, &Symbol::new(e, "minter"), &admin);␊
        }␊
    ␊
        #[only_role(caller, "minter")]␊
        #[when_not_paused]␊
        pub fn mint(e: &Env, account: Address, amount: i128, caller: Address) {␊
            Base::mint(e, &account, amount);␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: MuxedAddress, amount: i128) {␊
            Self::ContractType::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleBurnable for MyToken {␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, amount: i128) {␊
            Base::burn(e, &from, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
            Base::burn_from(e, &spender, &from, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    impl UpgradeableInternal for MyToken {␊
        fn _require_auth(e: &Env, operator: &Address) {␊
            access_control::ensure_role(e, &Symbol::new(e, "upgrader"), operator);␊
            operator.require_auth();␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl AccessControl for MyToken {}␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        #[only_role(caller, "pauser")]␊
        fn pause(e: &Env, caller: Address) {␊
            pausable::pause(e);␊
        }␊
    ␊
        #[only_role(caller, "pauser")]␊
        fn unpause(e: &Env, caller: Address) {␊
            pausable::unpause(e);␊
        }␊
    }␊
    `

## fungible full - complex name

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.6.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contractimpl, Env, MuxedAddress, String, Symbol, Vec␊
    };␊
    use stellar_access::ownable::{self as ownable, Ownable};␊
    use stellar_contract_utils::pausable::{self as pausable, Pausable};␊
    use stellar_contract_utils::upgradeable::UpgradeableInternal;␊
    use stellar_macros::{only_owner, Upgradeable, when_not_paused};␊
    use stellar_tokens::fungible::{Base, burnable::FungibleBurnable, FungibleToken};␊
    ␊
    #[derive(Upgradeable)]␊
    #[contract]␊
    pub struct CustomToken;␊
    ␊
    #[contractimpl]␊
    impl CustomToken {␊
        pub fn __constructor(e: &Env, recipient: Address, owner: Address) {␊
            Base::set_metadata(e, 7, String::from_str(e, "Custom  $ Token"), String::from_str(e, "MTK"));␊
            Base::mint(e, &recipient, 20000000000);␊
            ownable::set_owner(e, &owner);␊
        }␊
    ␊
        #[only_owner]␊
        #[when_not_paused]␊
        pub fn mint(e: &Env, account: Address, amount: i128) {␊
            Base::mint(e, &account, amount);␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleToken for CustomToken {␊
        type ContractType = Base;␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: MuxedAddress, amount: i128) {␊
            Self::ContractType::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl FungibleBurnable for CustomToken {␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, amount: i128) {␊
            Base::burn(e, &from, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
            Base::burn_from(e, &spender, &from, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    impl UpgradeableInternal for CustomToken {␊
        fn _require_auth(e: &Env, _operator: &Address) {␊
            ownable::enforce_owner_auth(e);␊
        }␊
    }␊
    ␊
    #[contractimpl(contracttrait)]␊
    impl Ownable for CustomToken {}␊
    ␊
    #[contractimpl]␊
    impl Pausable for CustomToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        #[only_owner]␊
        fn pause(e: &Env, _caller: Address) {␊
            pausable::pause(e);␊
        }␊
    ␊
        #[only_owner]␊
        fn unpause(e: &Env, _caller: Address) {␊
            pausable::unpause(e);␊
        }␊
    }␊
    `

## fungible explicit trait implementations

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.6.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{␊
        Address, contract, contractimpl, Env, MuxedAddress, String, Symbol, Vec␊
    };␊
    use stellar_tokens::fungible::{Base, FungibleToken};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            Base::set_metadata(e, 7, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl FungibleToken for MyToken {␊
        type ContractType = Base;␊
    ␊
        fn total_supply(e: &Env) -> i128 {␊
            Self::ContractType::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            Self::ContractType::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            Self::ContractType::allowance(e, &owner, &spender)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: MuxedAddress, amount: i128) {␊
            Self::ContractType::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            Self::ContractType::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            Self::ContractType::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    }␊
    `
