# Snapshot report for `src/account.test.ts`

The actual snapshot is saved in `account.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## default full account, mixin + upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::AccountComponent;␊
        use openzeppelin::account::extensions::SRC9Component;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: AccountComponent, storage: account, event: AccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: SRC9Component, storage: src9, event: SRC9Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OutsideExecutionV2Impl = SRC9Component::OutsideExecutionV2Impl<ContractState>;␊
    ␊
        // Internal␊
        impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;␊
        impl OutsideExecutionInternalImpl = SRC9Component::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            account: AccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            src9: SRC9Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccountEvent: AccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            SRC9Event: SRC9Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: felt252) {␊
            self.account.initializer(public_key);␊
            self.src9.initializer();␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## default full account, mixin + non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::AccountComponent;␊
        use openzeppelin::account::extensions::SRC9Component;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
    ␊
        component!(path: AccountComponent, storage: account, event: AccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: SRC9Component, storage: src9, event: SRC9Event);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OutsideExecutionV2Impl = SRC9Component::OutsideExecutionV2Impl<ContractState>;␊
    ␊
        // Internal␊
        impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;␊
        impl OutsideExecutionInternalImpl = SRC9Component::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            account: AccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            src9: SRC9Component::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccountEvent: AccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            SRC9Event: SRC9Component::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: felt252) {␊
            self.account.initializer(public_key);␊
            self.src9.initializer();␊
        }␊
    }␊
    `

## explicit full account, mixin + upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::AccountComponent;␊
        use openzeppelin::account::extensions::SRC9Component;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: AccountComponent, storage: account, event: AccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: SRC9Component, storage: src9, event: SRC9Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OutsideExecutionV2Impl = SRC9Component::OutsideExecutionV2Impl<ContractState>;␊
    ␊
        // Internal␊
        impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;␊
        impl OutsideExecutionInternalImpl = SRC9Component::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            account: AccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            src9: SRC9Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccountEvent: AccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            SRC9Event: SRC9Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: felt252) {␊
            self.account.initializer(public_key);␊
            self.src9.initializer();␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## explicit full account, mixin + non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::AccountComponent;␊
        use openzeppelin::account::extensions::SRC9Component;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
    ␊
        component!(path: AccountComponent, storage: account, event: AccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: SRC9Component, storage: src9, event: SRC9Event);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl AccountMixinImpl = AccountComponent::AccountMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OutsideExecutionV2Impl = SRC9Component::OutsideExecutionV2Impl<ContractState>;␊
    ␊
        // Internal␊
        impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;␊
        impl OutsideExecutionInternalImpl = SRC9Component::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            account: AccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            src9: SRC9Component::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccountEvent: AccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            SRC9Event: SRC9Component::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: felt252) {␊
            self.account.initializer(public_key);␊
            self.src9.initializer();␊
        }␊
    }␊
    `

## basic account, upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::AccountComponent;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: AccountComponent, storage: account, event: AccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = AccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = AccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            account: AccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccountEvent: AccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: felt252) {␊
            self.account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## basic account, non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::AccountComponent;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
    ␊
        component!(path: AccountComponent, storage: account, event: AccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = AccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = AccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            account: AccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccountEvent: AccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: felt252) {␊
            self.account.initializer(public_key);␊
        }␊
    }␊
    `

## account outside execution

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::AccountComponent;␊
        use openzeppelin::account::extensions::SRC9Component;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: AccountComponent, storage: account, event: AccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: SRC9Component, storage: src9, event: SRC9Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = AccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = AccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OutsideExecutionV2Impl = SRC9Component::OutsideExecutionV2Impl<ContractState>;␊
    ␊
        // Internal␊
        impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;␊
        impl OutsideExecutionInternalImpl = SRC9Component::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            account: AccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            src9: SRC9Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccountEvent: AccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            SRC9Event: SRC9Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: felt252) {␊
            self.account.initializer(public_key);␊
            self.src9.initializer();␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## account declarer

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::AccountComponent;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: AccountComponent, storage: account, event: AccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = AccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = AccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl DeclarerImpl = AccountComponent::DeclarerImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            account: AccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccountEvent: AccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: felt252) {␊
            self.account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## account deployable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::AccountComponent;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: AccountComponent, storage: account, event: AccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = AccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = AccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl DeployableImpl = AccountComponent::DeployableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            account: AccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccountEvent: AccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: felt252) {␊
            self.account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## account public key

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::AccountComponent;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: AccountComponent, storage: account, event: AccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = AccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = AccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PublicKeyImpl = AccountComponent::PublicKeyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PublicKeyCamelImpl = AccountComponent::PublicKeyCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            account: AccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccountEvent: AccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: felt252) {␊
            self.account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## account declarer, deployable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::AccountComponent;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: AccountComponent, storage: account, event: AccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = AccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = AccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl DeclarerImpl = AccountComponent::DeclarerImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl DeployableImpl = AccountComponent::DeployableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            account: AccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccountEvent: AccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: felt252) {␊
            self.account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## account declarer, public key

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::AccountComponent;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: AccountComponent, storage: account, event: AccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = AccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = AccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl DeclarerImpl = AccountComponent::DeclarerImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PublicKeyImpl = AccountComponent::PublicKeyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PublicKeyCamelImpl = AccountComponent::PublicKeyCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            account: AccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccountEvent: AccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: felt252) {␊
            self.account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## account deployable, public key

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::AccountComponent;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: AccountComponent, storage: account, event: AccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = AccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = AccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl DeployableImpl = AccountComponent::DeployableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PublicKeyImpl = AccountComponent::PublicKeyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PublicKeyCamelImpl = AccountComponent::PublicKeyCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl AccountInternalImpl = AccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            account: AccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccountEvent: AccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: felt252) {␊
            self.account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## default full ethAccount, mixin + upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::eth_account::EthAccountComponent;␊
        use openzeppelin::account::extensions::SRC9Component;␊
        use openzeppelin::account::interface::EthPublicKey;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: SRC9Component, storage: src9, event: SRC9Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl EthAccountMixinImpl = EthAccountComponent::EthAccountMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OutsideExecutionV2Impl = SRC9Component::OutsideExecutionV2Impl<ContractState>;␊
    ␊
        // Internal␊
        impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;␊
        impl OutsideExecutionInternalImpl = SRC9Component::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            eth_account: EthAccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            src9: SRC9Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            EthAccountEvent: EthAccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            SRC9Event: SRC9Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: EthPublicKey) {␊
            self.eth_account.initializer(public_key);␊
            self.src9.initializer();␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.eth_account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## default full ethAccount, mixin + non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::eth_account::EthAccountComponent;␊
        use openzeppelin::account::extensions::SRC9Component;␊
        use openzeppelin::account::interface::EthPublicKey;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
    ␊
        component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: SRC9Component, storage: src9, event: SRC9Event);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl EthAccountMixinImpl = EthAccountComponent::EthAccountMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OutsideExecutionV2Impl = SRC9Component::OutsideExecutionV2Impl<ContractState>;␊
    ␊
        // Internal␊
        impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;␊
        impl OutsideExecutionInternalImpl = SRC9Component::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            eth_account: EthAccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            src9: SRC9Component::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            EthAccountEvent: EthAccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            SRC9Event: SRC9Component::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: EthPublicKey) {␊
            self.eth_account.initializer(public_key);␊
            self.src9.initializer();␊
        }␊
    }␊
    `

## explicit full ethAccount, mixin + upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::eth_account::EthAccountComponent;␊
        use openzeppelin::account::extensions::SRC9Component;␊
        use openzeppelin::account::interface::EthPublicKey;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: SRC9Component, storage: src9, event: SRC9Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl EthAccountMixinImpl = EthAccountComponent::EthAccountMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OutsideExecutionV2Impl = SRC9Component::OutsideExecutionV2Impl<ContractState>;␊
    ␊
        // Internal␊
        impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;␊
        impl OutsideExecutionInternalImpl = SRC9Component::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            eth_account: EthAccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            src9: SRC9Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            EthAccountEvent: EthAccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            SRC9Event: SRC9Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: EthPublicKey) {␊
            self.eth_account.initializer(public_key);␊
            self.src9.initializer();␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.eth_account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## explicit full ethAccount, mixin + non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::eth_account::EthAccountComponent;␊
        use openzeppelin::account::extensions::SRC9Component;␊
        use openzeppelin::account::interface::EthPublicKey;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
    ␊
        component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: SRC9Component, storage: src9, event: SRC9Event);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl EthAccountMixinImpl = EthAccountComponent::EthAccountMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OutsideExecutionV2Impl = SRC9Component::OutsideExecutionV2Impl<ContractState>;␊
    ␊
        // Internal␊
        impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;␊
        impl OutsideExecutionInternalImpl = SRC9Component::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            eth_account: EthAccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            src9: SRC9Component::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            EthAccountEvent: EthAccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            SRC9Event: SRC9Component::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: EthPublicKey) {␊
            self.eth_account.initializer(public_key);␊
            self.src9.initializer();␊
        }␊
    }␊
    `

## basic ethAccount, upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::eth_account::EthAccountComponent;␊
        use openzeppelin::account::interface::EthPublicKey;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = EthAccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = EthAccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            eth_account: EthAccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            EthAccountEvent: EthAccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: EthPublicKey) {␊
            self.eth_account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.eth_account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## basic ethAccount, non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::eth_account::EthAccountComponent;␊
        use openzeppelin::account::interface::EthPublicKey;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
    ␊
        component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = EthAccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = EthAccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            eth_account: EthAccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            EthAccountEvent: EthAccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: EthPublicKey) {␊
            self.eth_account.initializer(public_key);␊
        }␊
    }␊
    `

## ethAccount outside execution

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::eth_account::EthAccountComponent;␊
        use openzeppelin::account::extensions::SRC9Component;␊
        use openzeppelin::account::interface::EthPublicKey;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: SRC9Component, storage: src9, event: SRC9Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = EthAccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = EthAccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OutsideExecutionV2Impl = SRC9Component::OutsideExecutionV2Impl<ContractState>;␊
    ␊
        // Internal␊
        impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;␊
        impl OutsideExecutionInternalImpl = SRC9Component::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            eth_account: EthAccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            src9: SRC9Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            EthAccountEvent: EthAccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            SRC9Event: SRC9Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: EthPublicKey) {␊
            self.eth_account.initializer(public_key);␊
            self.src9.initializer();␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.eth_account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## ethAccount declarer

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::eth_account::EthAccountComponent;␊
        use openzeppelin::account::interface::EthPublicKey;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = EthAccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = EthAccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl DeclarerImpl = EthAccountComponent::DeclarerImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            eth_account: EthAccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            EthAccountEvent: EthAccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: EthPublicKey) {␊
            self.eth_account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.eth_account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## ethAccount deployable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::eth_account::EthAccountComponent;␊
        use openzeppelin::account::interface::EthPublicKey;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = EthAccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = EthAccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl DeployableImpl = EthAccountComponent::DeployableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            eth_account: EthAccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            EthAccountEvent: EthAccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: EthPublicKey) {␊
            self.eth_account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.eth_account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## ethAccount public key

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::eth_account::EthAccountComponent;␊
        use openzeppelin::account::interface::EthPublicKey;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = EthAccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = EthAccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PublicKeyImpl = EthAccountComponent::PublicKeyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PublicKeyCamelImpl = EthAccountComponent::PublicKeyCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            eth_account: EthAccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            EthAccountEvent: EthAccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: EthPublicKey) {␊
            self.eth_account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.eth_account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## ethAccount declarer, deployable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::eth_account::EthAccountComponent;␊
        use openzeppelin::account::interface::EthPublicKey;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = EthAccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = EthAccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl DeclarerImpl = EthAccountComponent::DeclarerImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl DeployableImpl = EthAccountComponent::DeployableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            eth_account: EthAccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            EthAccountEvent: EthAccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: EthPublicKey) {␊
            self.eth_account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.eth_account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## ethAccount declarer, public key

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::eth_account::EthAccountComponent;␊
        use openzeppelin::account::interface::EthPublicKey;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = EthAccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = EthAccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl DeclarerImpl = EthAccountComponent::DeclarerImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PublicKeyImpl = EthAccountComponent::PublicKeyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PublicKeyCamelImpl = EthAccountComponent::PublicKeyCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            eth_account: EthAccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            EthAccountEvent: EthAccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: EthPublicKey) {␊
            self.eth_account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.eth_account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## ethAccount deployable, public key

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^1.0.0␊
    ␊
    #[starknet::contract(account)]␊
    mod MyAccount {␊
        use openzeppelin::account::eth_account::EthAccountComponent;␊
        use openzeppelin::account::interface::EthPublicKey;␊
        use openzeppelin::introspection::src5::SRC5Component;␊
        use openzeppelin::upgrades::interface::IUpgradeable;␊
        use openzeppelin::upgrades::UpgradeableComponent;␊
        use starknet::ClassHash;␊
    ␊
        component!(path: EthAccountComponent, storage: eth_account, event: EthAccountEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl SRC6Impl = EthAccountComponent::SRC6Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC6CamelOnlyImpl = EthAccountComponent::SRC6CamelOnlyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl DeployableImpl = EthAccountComponent::DeployableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PublicKeyImpl = EthAccountComponent::PublicKeyImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PublicKeyCamelImpl = EthAccountComponent::PublicKeyCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl SRC5Impl = SRC5Component::SRC5Impl<ContractState>;␊
    ␊
        // Internal␊
        impl EthAccountInternalImpl = EthAccountComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            eth_account: EthAccountComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            EthAccountEvent: EthAccountComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, public_key: EthPublicKey) {␊
            self.eth_account.initializer(public_key);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.eth_account.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `
