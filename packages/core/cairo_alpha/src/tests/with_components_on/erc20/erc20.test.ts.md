# Snapshot report for `src/tests/with_components_on/erc20/erc20.test.ts`

The actual snapshot is saved in `erc20.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## basic erc20, non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20)]␊
    mod MyToken {␊
        use openzeppelin_token::erc20::{DefaultConfig as ERC20DefaultConfig, ERC20HooksEmptyImpl};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState) {␊
            self.erc20.initializer("MyToken", "MTK");␊
        }␊
    }␊
    `

## basic erc20

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Upgradeable, Ownable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::{DefaultConfig as ERC20DefaultConfig, ERC20HooksEmptyImpl};␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 burnable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Upgradeable, Ownable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::{DefaultConfig as ERC20DefaultConfig, ERC20HooksEmptyImpl};␊
        use starknet::{ClassHash, ContractAddress, get_caller_address};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, value: u256) {␊
                self.erc20.burn(get_caller_address(), value);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Pausable, Ownable, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::DefaultConfig as ERC20DefaultConfig;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.unpause();␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 pausable with roles

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Pausable, AccessControl, SRC5, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::DEFAULT_ADMIN_ROLE;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::DefaultConfig as ERC20DefaultConfig;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{PAUSER_ROLE, UPGRADER_ROLE};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlMixinImpl = AccessControlComponent::AccessControlMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            default_admin: ContractAddress,␊
            pauser: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.access_control.initializer();␊
    ␊
            self.access_control._grant_role(DEFAULT_ADMIN_ROLE, default_admin);␊
            self.access_control._grant_role(PAUSER_ROLE, pauser);␊
            self.access_control._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.access_control.assert_only_role(PAUSER_ROLE);␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.access_control.assert_only_role(PAUSER_ROLE);␊
                self.pausable.unpause();␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 pausable with roles-DAR (default opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Pausable, AccessControlDefaultAdminRules, SRC5, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::extensions::DefaultConfig as AccessControlDefaultAdminRulesDefaultConfig;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::DefaultConfig as ERC20DefaultConfig;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{PAUSER_ROLE, UPGRADER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 86400; // 1 day␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlMixinImpl = AccessControlDefaultAdminRulesComponent::AccessControlMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            pauser: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
    ␊
            self.access_control_dar._grant_role(PAUSER_ROLE, pauser);␊
            self.access_control_dar._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.unpause();␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 pausable with roles-DAR (custom opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Pausable, AccessControlDefaultAdminRules, SRC5, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::DefaultConfig as ERC20DefaultConfig;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{PAUSER_ROLE, UPGRADER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 172800; // 2 days␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlMixinImpl = AccessControlDefaultAdminRulesComponent::AccessControlMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            pauser: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
    ␊
            self.access_control_dar._grant_role(PAUSER_ROLE, pauser);␊
            self.access_control_dar._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
        }␊
        ␊
        impl AccessControlDefaultAdminRulesImmutableConfig of AccessControlDefaultAdminRulesComponent::ImmutableConfig {␊
            const DEFAULT_ADMIN_DELAY_INCREASE_WAIT: u64 = 604800; // 1 week␊
            const MAXIMUM_DEFAULT_ADMIN_TRANSFER_DELAY: u64 = 1209600; // 2 weeks␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.unpause();␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 burnable pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Pausable, Ownable, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::DefaultConfig as ERC20DefaultConfig;␊
        use starknet::{ClassHash, ContractAddress, get_caller_address};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.unpause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, value: u256) {␊
                self.erc20.burn(get_caller_address(), value);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 preminted

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Upgradeable, Ownable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::{DefaultConfig as ERC20DefaultConfig, ERC20HooksEmptyImpl};␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, recipient: ContractAddress, owner: ContractAddress) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.ownable.initializer(owner);␊
    ␊
            self.erc20.mint(recipient, 1000000000000000000000);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 premint of 0

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Upgradeable, Ownable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::{DefaultConfig as ERC20DefaultConfig, ERC20HooksEmptyImpl};␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 votes, custom decimals

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Upgradeable, Ownable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::ERC20HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        impl ERC20ImmutableConfig of ERC20Component::ImmutableConfig {␊
            const DECIMALS: u8 = 6;␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 mintable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Ownable, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::{DefaultConfig as ERC20DefaultConfig, ERC20HooksEmptyImpl};␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {␊
                self.ownable.assert_only_owner();␊
                self.erc20.mint(recipient, amount);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 mintable with roles

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, AccessControl, SRC5, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::DEFAULT_ADMIN_ROLE;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::{DefaultConfig as ERC20DefaultConfig, ERC20HooksEmptyImpl};␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{MINTER_ROLE, UPGRADER_ROLE};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlMixinImpl = AccessControlComponent::AccessControlMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            default_admin: ContractAddress,␊
            minter: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.access_control.initializer();␊
    ␊
            self.access_control._grant_role(DEFAULT_ADMIN_ROLE, default_admin);␊
            self.access_control._grant_role(MINTER_ROLE, minter);␊
            self.access_control._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {␊
                self.access_control.assert_only_role(MINTER_ROLE);␊
                self.erc20.mint(recipient, amount);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 mintable with roles-DAR (default opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, AccessControlDefaultAdminRules, SRC5, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::extensions::DefaultConfig as AccessControlDefaultAdminRulesDefaultConfig;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::{DefaultConfig as ERC20DefaultConfig, ERC20HooksEmptyImpl};␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{MINTER_ROLE, UPGRADER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 86400; // 1 day␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlMixinImpl = AccessControlDefaultAdminRulesComponent::AccessControlMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            minter: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
    ␊
            self.access_control_dar._grant_role(MINTER_ROLE, minter);␊
            self.access_control_dar._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc20.mint(recipient, amount);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 mintable with roles-DAR (custom opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, AccessControlDefaultAdminRules, SRC5, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::{DefaultConfig as ERC20DefaultConfig, ERC20HooksEmptyImpl};␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{MINTER_ROLE, UPGRADER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 172800; // 2 days␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlMixinImpl = AccessControlDefaultAdminRulesComponent::AccessControlMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            minter: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
    ␊
            self.access_control_dar._grant_role(MINTER_ROLE, minter);␊
            self.access_control_dar._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        impl AccessControlDefaultAdminRulesImmutableConfig of AccessControlDefaultAdminRulesComponent::ImmutableConfig {␊
            const DEFAULT_ADMIN_DELAY_INCREASE_WAIT: u64 = 604800; // 1 week␊
            const MAXIMUM_DEFAULT_ADMIN_TRANSFER_DELAY: u64 = 1209600; // 2 weeks␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc20.mint(recipient, amount);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 votes

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Nonces, Votes, Upgradeable, Ownable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::DefaultConfig as ERC20DefaultConfig;␊
        use openzeppelin_utils::contract_clock::ERC6372TimestampClock;␊
        use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl VotesImpl = VotesComponent::VotesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {␊
            fn after_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let mut contract_state = self.get_contract_mut();␊
                contract_state.votes.transfer_voting_units(from, recipient, amount);␊
            }␊
        }␊
    ␊
        //␊
        // SNIP12 Metadata␊
        //␊
        ␊
        impl SNIP12MetadataImpl of SNIP12Metadata {␊
            fn name() -> felt252 {␊
                'MY_DAPP_NAME'␊
            }␊
    ␊
            fn version() -> felt252 {␊
                'v1'␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 votes, version

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Nonces, Votes, Upgradeable, Ownable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::DefaultConfig as ERC20DefaultConfig;␊
        use openzeppelin_utils::contract_clock::ERC6372TimestampClock;␊
        use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl VotesImpl = VotesComponent::VotesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {␊
            fn after_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let mut contract_state = self.get_contract_mut();␊
                contract_state.votes.transfer_voting_units(from, recipient, amount);␊
            }␊
        }␊
    ␊
        //␊
        // SNIP12 Metadata␊
        //␊
        ␊
        impl SNIP12MetadataImpl of SNIP12Metadata {␊
            fn name() -> felt252 {␊
                'MY_DAPP_NAME'␊
            }␊
    ␊
            fn version() -> felt252 {␊
                'MY_DAPP_VERSION'␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 votes, non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Nonces, Votes)]␊
    mod MyToken {␊
        use openzeppelin_token::erc20::DefaultConfig as ERC20DefaultConfig;␊
        use openzeppelin_utils::contract_clock::ERC6372TimestampClock;␊
        use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;␊
        use starknet::ContractAddress;␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl VotesImpl = VotesComponent::VotesImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState) {␊
            self.erc20.initializer("MyToken", "MTK");␊
        }␊
    ␊
        impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {␊
            fn after_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let mut contract_state = self.get_contract_mut();␊
                contract_state.votes.transfer_voting_units(from, recipient, amount);␊
            }␊
        }␊
    ␊
        //␊
        // SNIP12 Metadata␊
        //␊
        ␊
        impl SNIP12MetadataImpl of SNIP12Metadata {␊
            fn name() -> felt252 {␊
                'MY_DAPP_NAME'␊
            }␊
    ␊
            fn version() -> felt252 {␊
                'v1'␊
            }␊
        }␊
    }␊
    `

## erc20 full, non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Pausable, Ownable, Nonces, Votes)]␊
    mod MyToken {␊
        use openzeppelin_token::erc20::DefaultConfig as ERC20DefaultConfig;␊
        use openzeppelin_utils::contract_clock::ERC6372TimestampClock;␊
        use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;␊
        use starknet::{ContractAddress, get_caller_address};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl VotesImpl = VotesComponent::VotesImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, recipient: ContractAddress, owner: ContractAddress) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.ownable.initializer(owner);␊
    ␊
            self.erc20.mint(recipient, 2000000000000000000000);␊
        }␊
    ␊
        impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
    ␊
            fn after_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let mut contract_state = self.get_contract_mut();␊
                contract_state.votes.transfer_voting_units(from, recipient, amount);␊
            }␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.unpause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, value: u256) {␊
                self.erc20.burn(get_caller_address(), value);␊
            }␊
    ␊
            #[external(v0)]␊
            fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {␊
                self.ownable.assert_only_owner();␊
                self.erc20.mint(recipient, amount);␊
            }␊
        }␊
    ␊
        //␊
        // SNIP12 Metadata␊
        //␊
        ␊
        impl SNIP12MetadataImpl of SNIP12Metadata {␊
            fn name() -> felt252 {␊
                'MY_DAPP_NAME'␊
            }␊
    ␊
            fn version() -> felt252 {␊
                'MY_DAPP_VERSION'␊
            }␊
        }␊
    }␊
    `

## erc20 full upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Pausable, Ownable, Nonces, Votes, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::DefaultConfig as ERC20DefaultConfig;␊
        use openzeppelin_utils::contract_clock::ERC6372TimestampClock;␊
        use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;␊
        use starknet::{ClassHash, ContractAddress, get_caller_address};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl VotesImpl = VotesComponent::VotesImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, recipient: ContractAddress, owner: ContractAddress) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.ownable.initializer(owner);␊
    ␊
            self.erc20.mint(recipient, 2000000000000000000000);␊
        }␊
    ␊
        impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
    ␊
            fn after_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let mut contract_state = self.get_contract_mut();␊
                contract_state.votes.transfer_voting_units(from, recipient, amount);␊
            }␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.unpause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, value: u256) {␊
                self.erc20.burn(get_caller_address(), value);␊
            }␊
    ␊
            #[external(v0)]␊
            fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {␊
                self.ownable.assert_only_owner();␊
                self.erc20.mint(recipient, amount);␊
            }␊
        }␊
    ␊
        //␊
        // SNIP12 Metadata␊
        //␊
        ␊
        impl SNIP12MetadataImpl of SNIP12Metadata {␊
            fn name() -> felt252 {␊
                'MY_DAPP_NAME'␊
            }␊
    ␊
            fn version() -> felt252 {␊
                'MY_DAPP_VERSION'␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 full upgradeable with roles

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Pausable, AccessControl, SRC5, Nonces, Votes, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::DEFAULT_ADMIN_ROLE;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::DefaultConfig as ERC20DefaultConfig;␊
        use openzeppelin_utils::contract_clock::ERC6372TimestampClock;␊
        use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;␊
        use starknet::{ClassHash, ContractAddress, get_caller_address};␊
        use super::{MINTER_ROLE, PAUSER_ROLE, UPGRADER_ROLE};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlMixinImpl = AccessControlComponent::AccessControlMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl VotesImpl = VotesComponent::VotesImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            recipient: ContractAddress,␊
            default_admin: ContractAddress,␊
            pauser: ContractAddress,␊
            minter: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.access_control.initializer();␊
    ␊
            self.erc20.mint(recipient, 2000000000000000000000);␊
            self.access_control._grant_role(DEFAULT_ADMIN_ROLE, default_admin);␊
            self.access_control._grant_role(PAUSER_ROLE, pauser);␊
            self.access_control._grant_role(MINTER_ROLE, minter);␊
            self.access_control._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
    ␊
            fn after_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let mut contract_state = self.get_contract_mut();␊
                contract_state.votes.transfer_voting_units(from, recipient, amount);␊
            }␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.access_control.assert_only_role(PAUSER_ROLE);␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.access_control.assert_only_role(PAUSER_ROLE);␊
                self.pausable.unpause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, value: u256) {␊
                self.erc20.burn(get_caller_address(), value);␊
            }␊
    ␊
            #[external(v0)]␊
            fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {␊
                self.access_control.assert_only_role(MINTER_ROLE);␊
                self.erc20.mint(recipient, amount);␊
            }␊
        }␊
    ␊
        //␊
        // SNIP12 Metadata␊
        //␊
        ␊
        impl SNIP12MetadataImpl of SNIP12Metadata {␊
            fn name() -> felt252 {␊
                'MY_DAPP_NAME'␊
            }␊
    ␊
            fn version() -> felt252 {␊
                'MY_DAPP_VERSION'␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 full upgradeable with roles-DAR (default opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Pausable, AccessControlDefaultAdminRules, SRC5, Nonces, Votes, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::extensions::DefaultConfig as AccessControlDefaultAdminRulesDefaultConfig;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::DefaultConfig as ERC20DefaultConfig;␊
        use openzeppelin_utils::contract_clock::ERC6372TimestampClock;␊
        use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;␊
        use starknet::{ClassHash, ContractAddress, get_caller_address};␊
        use super::{MINTER_ROLE, PAUSER_ROLE, UPGRADER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 86400; // 1 day␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlMixinImpl = AccessControlDefaultAdminRulesComponent::AccessControlMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl VotesImpl = VotesComponent::VotesImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            recipient: ContractAddress,␊
            initial_default_admin: ContractAddress,␊
            pauser: ContractAddress,␊
            minter: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
    ␊
            self.erc20.mint(recipient, 2000000000000000000000);␊
            self.access_control_dar._grant_role(PAUSER_ROLE, pauser);␊
            self.access_control_dar._grant_role(MINTER_ROLE, minter);␊
            self.access_control_dar._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
    ␊
            fn after_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let mut contract_state = self.get_contract_mut();␊
                contract_state.votes.transfer_voting_units(from, recipient, amount);␊
            }␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.unpause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, value: u256) {␊
                self.erc20.burn(get_caller_address(), value);␊
            }␊
    ␊
            #[external(v0)]␊
            fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc20.mint(recipient, amount);␊
            }␊
        }␊
    ␊
        //␊
        // SNIP12 Metadata␊
        //␊
        ␊
        impl SNIP12MetadataImpl of SNIP12Metadata {␊
            fn name() -> felt252 {␊
                'MY_DAPP_NAME'␊
            }␊
    ␊
            fn version() -> felt252 {␊
                'MY_DAPP_VERSION'␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## erc20 full upgradeable with roles-DAR (custom opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0␊
    ␊
    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC20, Pausable, AccessControlDefaultAdminRules, SRC5, Nonces, Votes, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc20::DefaultConfig as ERC20DefaultConfig;␊
        use openzeppelin_utils::contract_clock::ERC6372TimestampClock;␊
        use openzeppelin_utils::cryptography::snip12::SNIP12Metadata;␊
        use starknet::{ClassHash, ContractAddress, get_caller_address};␊
        use super::{MINTER_ROLE, PAUSER_ROLE, UPGRADER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 172800; // 2 days␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC20MixinImpl = ERC20Component::ERC20MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlMixinImpl = AccessControlDefaultAdminRulesComponent::AccessControlMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl NoncesImpl = NoncesComponent::NoncesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl VotesImpl = VotesComponent::VotesImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            recipient: ContractAddress,␊
            initial_default_admin: ContractAddress,␊
            pauser: ContractAddress,␊
            minter: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.erc20.initializer("MyToken", "MTK");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
    ␊
            self.erc20.mint(recipient, 2000000000000000000000);␊
            self.access_control_dar._grant_role(PAUSER_ROLE, pauser);␊
            self.access_control_dar._grant_role(MINTER_ROLE, minter);␊
            self.access_control_dar._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        impl ERC20HooksImpl of ERC20Component::ERC20HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
    ␊
            fn after_update(␊
                ref self: ERC20Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                recipient: ContractAddress,␊
                amount: u256,␊
            ) {␊
                let mut contract_state = self.get_contract_mut();␊
                contract_state.votes.transfer_voting_units(from, recipient, amount);␊
            }␊
        }␊
        ␊
        impl AccessControlDefaultAdminRulesImmutableConfig of AccessControlDefaultAdminRulesComponent::ImmutableConfig {␊
            const DEFAULT_ADMIN_DELAY_INCREASE_WAIT: u64 = 604800; // 1 week␊
            const MAXIMUM_DEFAULT_ADMIN_TRANSFER_DELAY: u64 = 1209600; // 2 weeks␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.unpause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, value: u256) {␊
                self.erc20.burn(get_caller_address(), value);␊
            }␊
    ␊
            #[external(v0)]␊
            fn mint(ref self: ContractState, recipient: ContractAddress, amount: u256) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc20.mint(recipient, amount);␊
            }␊
        }␊
    ␊
        //␊
        // SNIP12 Metadata␊
        //␊
        ␊
        impl SNIP12MetadataImpl of SNIP12Metadata {␊
            fn name() -> felt252 {␊
                'MY_DAPP_NAME'␊
            }␊
    ␊
            fn version() -> felt252 {␊
                'MY_DAPP_VERSION'␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `
