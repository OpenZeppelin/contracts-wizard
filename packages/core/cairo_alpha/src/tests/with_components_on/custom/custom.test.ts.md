# Snapshot report for `src/tests/with_components_on/custom/custom.test.ts`

The actual snapshot is saved in `custom.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## custom non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    #[starknet::contract]␊
    mod MyContract {␊
        #[storage]␊
        struct Storage {}␊
    }␊
    `

## custom defaults

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    #[starknet::contract]␊
    mod MyContract {␊
        use openzeppelin_access::ownable::OwnableComponent;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_upgrades::UpgradeableComponent;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
        component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        // Internal␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
        impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
            #[substorage(v0)]␊
            ownable: OwnableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
            #[flat]␊
            OwnableEvent: OwnableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    #[starknet::contract]␊
    mod MyContract {␊
        use openzeppelin_access::ownable::OwnableComponent;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_security::pausable::PausableComponent;␊
        use openzeppelin_upgrades::UpgradeableComponent;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        component!(path: PausableComponent, storage: pausable, event: PausableEvent);␊
        component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        // Internal␊
        impl PausableInternalImpl = PausableComponent::InternalImpl<ContractState>;␊
        impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            pausable: PausableComponent::Storage,␊
            #[substorage(v0)]␊
            ownable: OwnableComponent::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            PausableEvent: PausableComponent::Event,␊
            #[flat]␊
            OwnableEvent: OwnableComponent::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.unpause();␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    #[starknet::contract]␊
    mod MyContract {␊
        use openzeppelin_access::ownable::OwnableComponent;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_upgrades::UpgradeableComponent;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
        component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        // Internal␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
        impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
            #[substorage(v0)]␊
            ownable: OwnableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
            #[flat]␊
            OwnableEvent: OwnableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## access control disabled

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    #[starknet::contract]␊
    mod MyContract {␊
        #[storage]␊
        struct Storage {}␊
    }␊
    `

## access control ownable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    #[starknet::contract]␊
    mod MyContract {␊
        use openzeppelin_access::ownable::OwnableComponent;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_upgrades::UpgradeableComponent;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        // Internal␊
        impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            ownable: OwnableComponent::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            OwnableEvent: OwnableComponent::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## access control roles

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    mod MyContract {␊
        use openzeppelin_access::accesscontrol::{AccessControlComponent, DEFAULT_ADMIN_ROLE};␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_introspection::src5::SRC5Component;␊
        use openzeppelin_upgrades::UpgradeableComponent;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::UPGRADER_ROLE;␊
    ␊
        component!(path: AccessControlComponent, storage: access_control, event: AccessControlEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl AccessControlMixinImpl = AccessControlComponent::AccessControlMixinImpl<ContractState>;␊
    ␊
        // Internal␊
        impl AccessControlInternalImpl = AccessControlComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            access_control: AccessControlComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccessControlEvent: AccessControlComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            default_admin: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.access_control.initializer();␊
    ␊
            self.access_control._grant_role(DEFAULT_ADMIN_ROLE, default_admin);␊
            self.access_control._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## access control roles default admin rules (default opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    mod MyContract {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_introspection::src5::SRC5Component;␊
        use openzeppelin_upgrades::UpgradeableComponent;␊
        use openzeppelin::access::accesscontrol::extensions::{␊
        	AccessControlDefaultAdminRulesComponent,␊
        	DefaultConfig as AccessControlDefaultAdminRulesDefaultConfig␊
        };␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::UPGRADER_ROLE;␊
    ␊
        const INITIAL_DELAY: u64 = 86400; // 1 day␊
    ␊
        component!(path: AccessControlDefaultAdminRulesComponent, storage: accesscontrol_dar, event: AccessControlDefaultAdminRulesEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl AccessControlMixinImpl = AccessControlDefaultAdminRulesComponent::AccessControlMixinImpl<ContractState>;␊
    ␊
        // Internal␊
        impl AccessControlDefaultAdminRulesInternalImpl = AccessControlDefaultAdminRulesComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            accesscontrol_dar: AccessControlDefaultAdminRulesComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccessControlDefaultAdminRulesEvent: AccessControlDefaultAdminRulesComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.accesscontrol_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
    ␊
            self.accesscontrol_dar._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.accesscontrol_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## access control roles default admin rules (custom opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    mod MyContract {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_introspection::src5::SRC5Component;␊
        use openzeppelin_upgrades::UpgradeableComponent;␊
        use openzeppelin::access::accesscontrol::extensions::AccessControlDefaultAdminRulesComponent;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::UPGRADER_ROLE;␊
    ␊
        const INITIAL_DELAY: u64 = 172800; // 2 days␊
    ␊
        component!(path: AccessControlDefaultAdminRulesComponent, storage: accesscontrol_dar, event: AccessControlDefaultAdminRulesEvent);␊
        component!(path: SRC5Component, storage: src5, event: SRC5Event);␊
        component!(path: UpgradeableComponent, storage: upgradeable, event: UpgradeableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl AccessControlMixinImpl = AccessControlDefaultAdminRulesComponent::AccessControlMixinImpl<ContractState>;␊
    ␊
        // Internal␊
        impl AccessControlDefaultAdminRulesInternalImpl = AccessControlDefaultAdminRulesComponent::InternalImpl<ContractState>;␊
        impl UpgradeableInternalImpl = UpgradeableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            accesscontrol_dar: AccessControlDefaultAdminRulesComponent::Storage,␊
            #[substorage(v0)]␊
            src5: SRC5Component::Storage,␊
            #[substorage(v0)]␊
            upgradeable: UpgradeableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            AccessControlDefaultAdminRulesEvent: AccessControlDefaultAdminRulesComponent::Event,␊
            #[flat]␊
            SRC5Event: SRC5Component::Event,␊
            #[flat]␊
            UpgradeableEvent: UpgradeableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.accesscontrol_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
    ␊
            self.accesscontrol_dar._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        impl AccessControlDefaultAdminRulesImmutableConfig of AccessControlDefaultAdminRulesComponent::ImmutableConfig {␊
            const DEFAULT_ADMIN_DELAY_INCREASE_WAIT: u64 = 604800; // 1 week␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.accesscontrol_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## pausable with access control disabled

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    #[starknet::contract]␊
    mod MyContract {␊
        use openzeppelin_access::ownable::OwnableComponent;␊
        use openzeppelin_security::pausable::PausableComponent;␊
        use starknet::ContractAddress;␊
    ␊
        component!(path: PausableComponent, storage: pausable, event: PausableEvent);␊
        component!(path: OwnableComponent, storage: ownable, event: OwnableEvent);␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        // Internal␊
        impl PausableInternalImpl = PausableComponent::InternalImpl<ContractState>;␊
        impl OwnableInternalImpl = OwnableComponent::InternalImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {␊
            #[substorage(v0)]␊
            pausable: PausableComponent::Storage,␊
            #[substorage(v0)]␊
            ownable: OwnableComponent::Storage,␊
        }␊
    ␊
        #[event]␊
        #[derive(Drop, starknet::Event)]␊
        enum Event {␊
            #[flat]␊
            PausableEvent: PausableComponent::Event,␊
            #[flat]␊
            OwnableEvent: OwnableComponent::Event,␊
        }␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.unpause();␊
            }␊
        }␊
    }␊
    `
