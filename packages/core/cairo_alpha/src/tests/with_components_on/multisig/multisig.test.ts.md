# Snapshot report for `src/tests/with_components_on/multisig/multisig.test.ts`

The actual snapshot is saved in `multisig.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## custom name

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    #[starknet::contract]␊
    #[with_components(Multisig, Upgradeable)]␊
    mod CustomMultisig {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        const INITIAL_QUORUM: u32 = 2;␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl MultisigImpl = MultisigComponent::MultisigImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, signers: Span<ContractAddress>) {␊
            self.multisig.initializer(INITIAL_QUORUM, signers);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.multisig.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## custom quorum

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    #[starknet::contract]␊
    #[with_components(Multisig, Upgradeable)]␊
    mod MyMultisig {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        const INITIAL_QUORUM: u32 = 42;␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl MultisigImpl = MultisigComponent::MultisigImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, signers: Span<ContractAddress>) {␊
            self.multisig.initializer(INITIAL_QUORUM, signers);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.multisig.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## all custom settings

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    #[starknet::contract]␊
    #[with_components(Multisig, Upgradeable)]␊
    mod CustomMultisig {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        const INITIAL_QUORUM: u32 = 42;␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl MultisigImpl = MultisigComponent::MultisigImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, signers: Span<ContractAddress>) {␊
            self.multisig.initializer(INITIAL_QUORUM, signers);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.multisig.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    #[starknet::contract]␊
    #[with_components(Multisig, Upgradeable)]␊
    mod MyMultisig {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        const INITIAL_QUORUM: u32 = 2;␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl MultisigImpl = MultisigComponent::MultisigImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, signers: Span<ContractAddress>) {␊
            self.multisig.initializer(INITIAL_QUORUM, signers);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.multisig.assert_only_self();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo 3.0.0-alpha.3␊
    ␊
    #[starknet::contract]␊
    #[with_components(Multisig)]␊
    mod MyMultisig {␊
        use starknet::ContractAddress;␊
    ␊
        const INITIAL_QUORUM: u32 = 2;␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl MultisigImpl = MultisigComponent::MultisigImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, signers: Span<ContractAddress>) {␊
            self.multisig.initializer(INITIAL_QUORUM, signers);␊
        }␊
    }␊
    `
