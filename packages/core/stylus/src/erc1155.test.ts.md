# Snapshot report for `src/erc1155.test.ts`

The actual snapshot is saved in `erc1155.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## basic erc1155

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0␊
    ␊
    #![cfg_attr(not(any(test, feature = "export-abi")), no_main)]␊
    extern crate alloc;␊
    ␊
    use alloc::vec::Vec;␊
    use openzeppelin_stylus::token::erc1155::{self, Erc1155, IErc1155};␊
    use openzeppelin_stylus::utils::introspection::erc165::IErc165;␊
    use stylus_sdk::abi::Bytes;␊
    use stylus_sdk::alloy_primitives::{Address, FixedBytes, U256};␊
    use stylus_sdk::prelude::*;␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct MyToken {␊
        erc1155: Erc1155,␊
    }␊
    ␊
    #[public]␊
    #[implements(IErc1155<Error = erc1155::Error>, IErc165)]␊
    impl MyToken {}␊
    ␊
    #[public]␊
    impl IErc1155 for MyToken {␊
        type Error = erc1155::Error;␊
    ␊
        fn balance_of(&self, account: Address, id: U256) -> U256 {␊
            self.erc1155.balance_of(account, id)␊
        }␊
    ␊
        fn balance_of_batch(&self, accounts: Vec<Address>, ids: Vec<U256>) -> Result<Vec<U256>, Self::Error> {␊
            Ok(self.erc1155.balance_of_batch(accounts, ids)?)␊
        }␊
    ␊
        fn set_approval_for_all(&mut self, operator: Address, approved: bool) -> Result<(), Self::Error> {␊
            Ok(self.erc1155.set_approval_for_all(operator, approved)?)␊
        }␊
    ␊
        fn is_approved_for_all(&self, account: Address, operator: Address) -> bool {␊
            self.erc1155.is_approved_for_all(account, operator)␊
        }␊
    ␊
        fn safe_transfer_from(&mut self, from: Address, to: Address, id: U256, value: U256, data: Bytes) -> Result<(), Self::Error> {␊
            Ok(self.erc1155.safe_transfer_from(from, to, id, value, data)?)␊
        }␊
    ␊
        fn safe_batch_transfer_from(␊
            &mut self,␊
            from: Address,␊
            to: Address,␊
            ids: Vec<U256>,␊
            values: Vec<U256>,␊
            data: Bytes,␊
        ) -> Result<(), Self::Error> {␊
            Ok(self.erc1155.safe_batch_transfer_from(from, to, ids, values, data)?)␊
        }␊
    }␊
    ␊
    #[public]␊
    impl IErc165 for MyToken {␊
        fn supports_interface(&self, interface_id: FixedBytes<4>) -> bool {␊
            self.erc1155.supports_interface(interface_id)␊
        }␊
    }␊
    `

## erc1155 burnable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0␊
    ␊
    #![cfg_attr(not(any(test, feature = "export-abi")), no_main)]␊
    extern crate alloc;␊
    ␊
    use alloc::vec::Vec;␊
    use openzeppelin_stylus::token::erc1155::extensions::IErc1155Burnable;␊
    use openzeppelin_stylus::token::erc1155::{self, Erc1155, IErc1155};␊
    use openzeppelin_stylus::utils::introspection::erc165::IErc165;␊
    use stylus_sdk::abi::Bytes;␊
    use stylus_sdk::alloy_primitives::{Address, FixedBytes, U256};␊
    use stylus_sdk::prelude::*;␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct MyToken {␊
        erc1155: Erc1155,␊
    }␊
    ␊
    #[public]␊
    #[implements(IErc1155<Error = erc1155::Error>, IErc1155Burnable<Error = erc1155::Error>, IErc165)]␊
    impl MyToken {}␊
    ␊
    #[public]␊
    impl IErc1155 for MyToken {␊
        type Error = erc1155::Error;␊
    ␊
        fn balance_of(&self, account: Address, id: U256) -> U256 {␊
            self.erc1155.balance_of(account, id)␊
        }␊
    ␊
        fn balance_of_batch(&self, accounts: Vec<Address>, ids: Vec<U256>) -> Result<Vec<U256>, Self::Error> {␊
            Ok(self.erc1155.balance_of_batch(accounts, ids)?)␊
        }␊
    ␊
        fn set_approval_for_all(&mut self, operator: Address, approved: bool) -> Result<(), Self::Error> {␊
            Ok(self.erc1155.set_approval_for_all(operator, approved)?)␊
        }␊
    ␊
        fn is_approved_for_all(&self, account: Address, operator: Address) -> bool {␊
            self.erc1155.is_approved_for_all(account, operator)␊
        }␊
    ␊
        fn safe_transfer_from(&mut self, from: Address, to: Address, id: U256, value: U256, data: Bytes) -> Result<(), Self::Error> {␊
            Ok(self.erc1155.safe_transfer_from(from, to, id, value, data)?)␊
        }␊
    ␊
        fn safe_batch_transfer_from(␊
            &mut self,␊
            from: Address,␊
            to: Address,␊
            ids: Vec<U256>,␊
            values: Vec<U256>,␊
            data: Bytes,␊
        ) -> Result<(), Self::Error> {␊
            Ok(self.erc1155.safe_batch_transfer_from(from, to, ids, values, data)?)␊
        }␊
    }␊
    ␊
    #[public]␊
    impl IErc1155Burnable for MyToken {␊
        type Error = erc1155::Error;␊
    ␊
        fn burn(&mut self, account: Address, token_id: U256, value: U256) -> Result<(), Self::Error> {␊
            Ok(self.erc1155.burn(account, token_id, value)?)␊
        }␊
    ␊
        fn burn_batch(&mut self, account: Address, token_ids: Vec<U256>, values: Vec<U256>) -> Result<(), Self::Error> {␊
            Ok(self.erc1155.burn_batch(account, token_ids, values)?)␊
        }␊
    }␊
    ␊
    #[public]␊
    impl IErc165 for MyToken {␊
        fn supports_interface(&self, interface_id: FixedBytes<4>) -> bool {␊
            self.erc1155.supports_interface(interface_id)␊
        }␊
    }␊
    `

## erc1155 supply

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0␊
    ␊
    #![cfg_attr(not(any(test, feature = "export-abi")), no_main)]␊
    extern crate alloc;␊
    ␊
    use alloc::vec::Vec;␊
    use openzeppelin_stylus::token::erc1155::extensions::{Erc1155Supply, IErc1155Supply};␊
    use openzeppelin_stylus::token::erc1155::{self, IErc1155};␊
    use openzeppelin_stylus::utils::introspection::erc165::IErc165;␊
    use stylus_sdk::abi::Bytes;␊
    use stylus_sdk::alloy_primitives::{Address, FixedBytes, U256};␊
    use stylus_sdk::prelude::*;␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct MyToken {␊
        erc1155_supply: Erc1155Supply,␊
    }␊
    ␊
    #[public]␊
    #[implements(IErc1155<Error = erc1155::Error>, IErc1155Supply, IErc165)]␊
    impl MyToken {}␊
    ␊
    #[public]␊
    impl IErc1155 for MyToken {␊
        type Error = erc1155::Error;␊
    ␊
        fn balance_of(&self, account: Address, id: U256) -> U256 {␊
            self.erc1155_supply.balance_of(account, id)␊
        }␊
    ␊
        fn balance_of_batch(&self, accounts: Vec<Address>, ids: Vec<U256>) -> Result<Vec<U256>, Self::Error> {␊
            Ok(self.erc1155_supply.balance_of_batch(accounts, ids)?)␊
        }␊
    ␊
        fn set_approval_for_all(&mut self, operator: Address, approved: bool) -> Result<(), Self::Error> {␊
            Ok(self.erc1155_supply.set_approval_for_all(operator, approved)?)␊
        }␊
    ␊
        fn is_approved_for_all(&self, account: Address, operator: Address) -> bool {␊
            self.erc1155_supply.is_approved_for_all(account, operator)␊
        }␊
    ␊
        fn safe_transfer_from(&mut self, from: Address, to: Address, id: U256, value: U256, data: Bytes) -> Result<(), Self::Error> {␊
            Ok(self.erc1155_supply.safe_transfer_from(from, to, id, value, data)?)␊
        }␊
    ␊
        fn safe_batch_transfer_from(␊
            &mut self,␊
            from: Address,␊
            to: Address,␊
            ids: Vec<U256>,␊
            values: Vec<U256>,␊
            data: Bytes,␊
        ) -> Result<(), Self::Error> {␊
            Ok(self.erc1155_supply.safe_batch_transfer_from(from, to, ids, values, data)?)␊
        }␊
    }␊
    ␊
    #[public]␊
    impl IErc1155Supply for MyToken {␊
        fn total_supply(&self, id: U256) -> U256 {␊
            self.erc1155_supply.total_supply(id)␊
        }␊
    ␊
        #[selector(name = "totalSupply")]␊
        fn total_supply_all(&self) -> U256 {␊
            self.erc1155_supply.total_supply_all()␊
        }␊
    ␊
        fn exists(&self, id: U256) -> bool {␊
            self.erc1155_supply.exists(id)␊
        }␊
    }␊
    ␊
    #[public]␊
    impl IErc165 for MyToken {␊
        fn supports_interface(&self, interface_id: FixedBytes<4>) -> bool {␊
            self.erc1155_supply.supports_interface(interface_id)␊
        }␊
    }␊
    `

## erc1155 supply burnable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0␊
    ␊
    #![cfg_attr(not(any(test, feature = "export-abi")), no_main)]␊
    extern crate alloc;␊
    ␊
    use alloc::vec::Vec;␊
    use openzeppelin_stylus::token::erc1155::extensions::{␊
    	Erc1155Supply, IErc1155Burnable, IErc1155Supply␊
    };␊
    use openzeppelin_stylus::token::erc1155::{self, IErc1155};␊
    use openzeppelin_stylus::utils::introspection::erc165::IErc165;␊
    use stylus_sdk::abi::Bytes;␊
    use stylus_sdk::alloy_primitives::{Address, FixedBytes, U256};␊
    use stylus_sdk::prelude::*;␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct MyToken {␊
        erc1155_supply: Erc1155Supply,␊
    }␊
    ␊
    #[public]␊
    #[implements(IErc1155<Error = erc1155::Error>, IErc1155Burnable<Error = erc1155::Error>, IErc1155Supply, IErc165)]␊
    impl MyToken {}␊
    ␊
    #[public]␊
    impl IErc1155 for MyToken {␊
        type Error = erc1155::Error;␊
    ␊
        fn balance_of(&self, account: Address, id: U256) -> U256 {␊
            self.erc1155_supply.balance_of(account, id)␊
        }␊
    ␊
        fn balance_of_batch(&self, accounts: Vec<Address>, ids: Vec<U256>) -> Result<Vec<U256>, Self::Error> {␊
            Ok(self.erc1155_supply.balance_of_batch(accounts, ids)?)␊
        }␊
    ␊
        fn set_approval_for_all(&mut self, operator: Address, approved: bool) -> Result<(), Self::Error> {␊
            Ok(self.erc1155_supply.set_approval_for_all(operator, approved)?)␊
        }␊
    ␊
        fn is_approved_for_all(&self, account: Address, operator: Address) -> bool {␊
            self.erc1155_supply.is_approved_for_all(account, operator)␊
        }␊
    ␊
        fn safe_transfer_from(&mut self, from: Address, to: Address, id: U256, value: U256, data: Bytes) -> Result<(), Self::Error> {␊
            Ok(self.erc1155_supply.safe_transfer_from(from, to, id, value, data)?)␊
        }␊
    ␊
        fn safe_batch_transfer_from(␊
            &mut self,␊
            from: Address,␊
            to: Address,␊
            ids: Vec<U256>,␊
            values: Vec<U256>,␊
            data: Bytes,␊
        ) -> Result<(), Self::Error> {␊
            Ok(self.erc1155_supply.safe_batch_transfer_from(from, to, ids, values, data)?)␊
        }␊
    }␊
    ␊
    #[public]␊
    impl IErc1155Burnable for MyToken {␊
        type Error = erc1155::Error;␊
    ␊
        fn burn(&mut self, account: Address, token_id: U256, value: U256) -> Result<(), Self::Error> {␊
            Ok(self.erc1155_supply._burn(account, token_id, value)?)␊
        }␊
    ␊
        fn burn_batch(&mut self, account: Address, token_ids: Vec<U256>, values: Vec<U256>) -> Result<(), Self::Error> {␊
            Ok(self.erc1155_supply._burn_batch(account, token_ids, values)?)␊
        }␊
    }␊
    ␊
    #[public]␊
    impl IErc1155Supply for MyToken {␊
        fn total_supply(&self, id: U256) -> U256 {␊
            self.erc1155_supply.total_supply(id)␊
        }␊
    ␊
        #[selector(name = "totalSupply")]␊
        fn total_supply_all(&self) -> U256 {␊
            self.erc1155_supply.total_supply_all()␊
        }␊
    ␊
        fn exists(&self, id: U256) -> bool {␊
            self.erc1155_supply.exists(id)␊
        }␊
    }␊
    ␊
    #[public]␊
    impl IErc165 for MyToken {␊
        fn supports_interface(&self, interface_id: FixedBytes<4>) -> bool {␊
            self.erc1155_supply.supports_interface(interface_id)␊
        }␊
    }␊
    `

## erc1155 full - complex name

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0␊
    ␊
    #![cfg_attr(not(any(test, feature = "export-abi")), no_main)]␊
    extern crate alloc;␊
    ␊
    use alloc::vec::Vec;␊
    use openzeppelin_stylus::token::erc1155::extensions::{␊
    	Erc1155Supply, IErc1155Burnable, IErc1155Supply␊
    };␊
    use openzeppelin_stylus::token::erc1155::{self, IErc1155};␊
    use openzeppelin_stylus::utils::introspection::erc165::IErc165;␊
    use stylus_sdk::abi::Bytes;␊
    use stylus_sdk::alloy_primitives::{Address, FixedBytes, U256};␊
    use stylus_sdk::prelude::*;␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct CustomToken {␊
        erc1155_supply: Erc1155Supply,␊
    }␊
    ␊
    #[public]␊
    #[implements(IErc1155<Error = erc1155::Error>, IErc1155Burnable<Error = erc1155::Error>, IErc1155Supply, IErc165)]␊
    impl CustomToken {}␊
    ␊
    #[public]␊
    impl IErc1155 for CustomToken {␊
        type Error = erc1155::Error;␊
    ␊
        fn balance_of(&self, account: Address, id: U256) -> U256 {␊
            self.erc1155_supply.balance_of(account, id)␊
        }␊
    ␊
        fn balance_of_batch(&self, accounts: Vec<Address>, ids: Vec<U256>) -> Result<Vec<U256>, Self::Error> {␊
            Ok(self.erc1155_supply.balance_of_batch(accounts, ids)?)␊
        }␊
    ␊
        fn set_approval_for_all(&mut self, operator: Address, approved: bool) -> Result<(), Self::Error> {␊
            Ok(self.erc1155_supply.set_approval_for_all(operator, approved)?)␊
        }␊
    ␊
        fn is_approved_for_all(&self, account: Address, operator: Address) -> bool {␊
            self.erc1155_supply.is_approved_for_all(account, operator)␊
        }␊
    ␊
        fn safe_transfer_from(&mut self, from: Address, to: Address, id: U256, value: U256, data: Bytes) -> Result<(), Self::Error> {␊
            Ok(self.erc1155_supply.safe_transfer_from(from, to, id, value, data)?)␊
        }␊
    ␊
        fn safe_batch_transfer_from(␊
            &mut self,␊
            from: Address,␊
            to: Address,␊
            ids: Vec<U256>,␊
            values: Vec<U256>,␊
            data: Bytes,␊
        ) -> Result<(), Self::Error> {␊
            Ok(self.erc1155_supply.safe_batch_transfer_from(from, to, ids, values, data)?)␊
        }␊
    }␊
    ␊
    #[public]␊
    impl IErc1155Burnable for CustomToken {␊
        type Error = erc1155::Error;␊
    ␊
        fn burn(&mut self, account: Address, token_id: U256, value: U256) -> Result<(), Self::Error> {␊
            Ok(self.erc1155_supply._burn(account, token_id, value)?)␊
        }␊
    ␊
        fn burn_batch(&mut self, account: Address, token_ids: Vec<U256>, values: Vec<U256>) -> Result<(), Self::Error> {␊
            Ok(self.erc1155_supply._burn_batch(account, token_ids, values)?)␊
        }␊
    }␊
    ␊
    #[public]␊
    impl IErc1155Supply for CustomToken {␊
        fn total_supply(&self, id: U256) -> U256 {␊
            self.erc1155_supply.total_supply(id)␊
        }␊
    ␊
        #[selector(name = "totalSupply")]␊
        fn total_supply_all(&self) -> U256 {␊
            self.erc1155_supply.total_supply_all()␊
        }␊
    ␊
        fn exists(&self, id: U256) -> bool {␊
            self.erc1155_supply.exists(id)␊
        }␊
    }␊
    ␊
    #[public]␊
    impl IErc165 for CustomToken {␊
        fn supports_interface(&self, interface_id: FixedBytes<4>) -> bool {␊
            self.erc1155_supply.supports_interface(interface_id)␊
        }␊
    }␊
    `
