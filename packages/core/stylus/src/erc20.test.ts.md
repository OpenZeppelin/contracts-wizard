# Snapshot report for `src/erc20.test.ts`

The actual snapshot is saved in `erc20.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## basic erc20

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.1.0-rc␊
    ␊
    use openzeppelin_erc20_token::{ERC20Token, self as erc20};␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            erc20::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl ERC20Token for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            erc20::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            erc20::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            erc20::allowance(e, &owner, &spender)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            erc20::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            erc20::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            erc20::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            erc20::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            erc20::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            erc20::metadata::symbol(e)␊
        }␊
    }␊
    `

## erc20 burnable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.1.0-rc␊
    ␊
    use openzeppelin_erc20_token::{burnable::ERC20Burnable, ERC20Token, self as erc20};␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            erc20::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl ERC20Token for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            erc20::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            erc20::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            erc20::allowance(e, &owner, &spender)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            erc20::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            erc20::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            erc20::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            erc20::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            erc20::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            erc20::metadata::symbol(e)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl ERC20Burnable for MyToken {␊
        fn burn(e: &Env, from: Address, amount: i128) {␊
            erc20::burnable::burn(e, &from, amount);␊
        }␊
    ␊
        fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
            erc20::burnable::burn_from(e, &spender, &from, amount);␊
        }␊
    }␊
    `

## erc20 pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.1.0-rc␊
    ␊
    use openzeppelin_erc20_token::{ERC20Token, self as erc20};␊
    use openzeppelin_pausable_macros::when_not_paused;␊
    use openzeppelin_pausable::{Pausable, self as pausable};␊
    use soroban_sdk::{␊
    	Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
    	symbol_short␊
    };␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contracterror]␊
    pub enum MyTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            erc20::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl ERC20Token for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            erc20::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            erc20::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            erc20::allowance(e, &owner, &spender)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            erc20::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            erc20::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            erc20::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            erc20::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            erc20::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            erc20::metadata::symbol(e)␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `

## erc20 burnable pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.1.0-rc␊
    ␊
    use openzeppelin_erc20_token::{burnable::ERC20Burnable, ERC20Token, self as erc20};␊
    use openzeppelin_pausable_macros::when_not_paused;␊
    use openzeppelin_pausable::{Pausable, self as pausable};␊
    use soroban_sdk::{␊
    	Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
    	symbol_short␊
    };␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contracterror]␊
    pub enum MyTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            erc20::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl ERC20Token for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            erc20::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            erc20::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            erc20::allowance(e, &owner, &spender)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            erc20::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            erc20::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            erc20::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            erc20::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            erc20::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            erc20::metadata::symbol(e)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl ERC20Burnable for MyToken {␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, amount: i128) {␊
            erc20::burnable::burn(e, &from, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
            erc20::burnable::burn_from(e, &spender, &from, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `

## erc20 preminted

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.1.0-rc␊
    ␊
    use openzeppelin_erc20_token::{ERC20Token, mintable::ERC20Mintable, self as erc20};␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            erc20::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            erc20::mintable::mint(e, &owner, 1000000000000000000000);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl ERC20Token for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            erc20::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            erc20::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            erc20::allowance(e, &owner, &spender)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            erc20::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            erc20::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            erc20::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            erc20::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            erc20::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            erc20::metadata::symbol(e)␊
        }␊
    }␊
    `

## erc20 premint of 0

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.1.0-rc␊
    ␊
    use openzeppelin_erc20_token::{ERC20Token, self as erc20};␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol};␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env) {␊
            erc20::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl ERC20Token for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            erc20::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            erc20::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            erc20::allowance(e, &owner, &spender)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            erc20::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            erc20::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            erc20::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            erc20::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            erc20::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            erc20::metadata::symbol(e)␊
        }␊
    }␊
    `

## erc20 mintable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.1.0-rc␊
    ␊
    use openzeppelin_erc20_token::{ERC20Token, mintable::ERC20Mintable, self as erc20};␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            erc20::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl ERC20Token for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            erc20::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            erc20::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            erc20::allowance(e, &owner, &spender)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            erc20::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            erc20::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            erc20::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            erc20::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            erc20::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            erc20::metadata::symbol(e)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl ERC20Mintable for MyToken {␊
        fn mint(e: &Env, account: Address, amount: i128) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            owner.require_auth();␊
            erc20::mintable::mint(e, &account, amount);␊
        }␊
    }␊
    `

## erc20 ownable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.1.0-rc␊
    ␊
    use openzeppelin_erc20_token::{ERC20Token, self as erc20};␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String, Symbol, symbol_short};␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            erc20::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl ERC20Token for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            erc20::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            erc20::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            erc20::allowance(e, &owner, &spender)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            erc20::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            erc20::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            erc20::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            erc20::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            erc20::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            erc20::metadata::symbol(e)␊
        }␊
    }␊
    `

## erc20 full

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.1.0-rc␊
    ␊
    use openzeppelin_erc20_token::{␊
    	burnable::ERC20Burnable, ERC20Token, mintable::ERC20Mintable, self as erc20␊
    };␊
    use openzeppelin_pausable_macros::when_not_paused;␊
    use openzeppelin_pausable::{Pausable, self as pausable};␊
    use soroban_sdk::{␊
    	Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
    	symbol_short␊
    };␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct MyToken;␊
    ␊
    #[contracterror]␊
    pub enum MyTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl MyToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            erc20::metadata::set_metadata(e, 18, String::from_str(e, "MyToken"), String::from_str(e, "MTK"));␊
            erc20::mintable::mint(e, &owner, 2000000000000000000000);␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl ERC20Token for MyToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            erc20::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            erc20::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            erc20::allowance(e, &owner, &spender)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            erc20::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            erc20::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            erc20::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            erc20::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            erc20::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            erc20::metadata::symbol(e)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl ERC20Burnable for MyToken {␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, amount: i128) {␊
            erc20::burnable::burn(e, &from, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
            erc20::burnable::burn_from(e, &spender, &from, amount);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl ERC20Mintable for MyToken {␊
        #[when_not_paused]␊
        fn mint(e: &Env, account: Address, amount: i128) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            owner.require_auth();␊
            erc20::mintable::mint(e, &account, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl]␊
    impl Pausable for MyToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, MyTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `

## erc20 full - complex name

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.1.0-rc␊
    ␊
    use openzeppelin_erc20_token::{␊
    	burnable::ERC20Burnable, ERC20Token, mintable::ERC20Mintable, self as erc20␊
    };␊
    use openzeppelin_pausable_macros::when_not_paused;␊
    use openzeppelin_pausable::{Pausable, self as pausable};␊
    use soroban_sdk::{␊
    	Address, contract, contracterror, contractimpl, Env, panic_with_error, String, Symbol,␊
    	symbol_short␊
    };␊
    ␊
    const OWNER: Symbol = symbol_short!("OWNER");␊
    ␊
    #[contract]␊
    pub struct CustomToken;␊
    ␊
    #[contracterror]␊
    pub enum CustomTokenError {␊
        Unauthorized = 1,␊
    }␊
    ␊
    #[contractimpl]␊
    impl CustomToken {␊
        pub fn __constructor(e: &Env, owner: Address) {␊
            erc20::metadata::set_metadata(e, 18, String::from_str(e, "Custom  $ Token"), String::from_str(e, "MTK"));␊
            erc20::mintable::mint(e, &owner, 2000000000000000000000);␊
            e.storage().instance().set(&OWNER, &owner);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl ERC20Token for CustomToken {␊
        fn total_supply(e: &Env) -> i128 {␊
            erc20::total_supply(e)␊
        }␊
    ␊
        fn balance(e: &Env, account: Address) -> i128 {␊
            erc20::balance(e, &account)␊
        }␊
    ␊
        fn allowance(e: &Env, owner: Address, spender: Address) -> i128 {␊
            erc20::allowance(e, &owner, &spender)␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer(e: &Env, from: Address, to: Address, amount: i128) {␊
            erc20::transfer(e, &from, &to, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, amount: i128) {␊
            erc20::transfer_from(e, &spender, &from, &to, amount);␊
        }␊
    ␊
        fn approve(e: &Env, owner: Address, spender: Address, amount: i128, live_until_ledger: u32) {␊
            erc20::approve(e, &owner, &spender, amount, live_until_ledger);␊
        }␊
    ␊
        fn decimals(e: &Env) -> u32 {␊
            erc20::metadata::decimals(e)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            erc20::metadata::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            erc20::metadata::symbol(e)␊
        }␊
    }␊
    ␊
    //␊
    // Extensions␊
    //␊
    ␊
    #[contractimpl]␊
    impl ERC20Burnable for CustomToken {␊
        #[when_not_paused]␊
        fn burn(e: &Env, from: Address, amount: i128) {␊
            erc20::burnable::burn(e, &from, amount);␊
        }␊
    ␊
        #[when_not_paused]␊
        fn burn_from(e: &Env, spender: Address, from: Address, amount: i128) {␊
            erc20::burnable::burn_from(e, &spender, &from, amount);␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl ERC20Mintable for CustomToken {␊
        #[when_not_paused]␊
        fn mint(e: &Env, account: Address, amount: i128) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            owner.require_auth();␊
            erc20::mintable::mint(e, &account, amount);␊
        }␊
    }␊
    ␊
    //␊
    // Utils␊
    //␊
    ␊
    #[contractimpl]␊
    impl Pausable for CustomToken {␊
        fn paused(e: &Env) -> bool {␊
            pausable::paused(e)␊
        }␊
    ␊
        fn pause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, CustomTokenError::Unauthorized);␊
            }␊
            pausable::pause(e, &caller);␊
        }␊
    ␊
        fn unpause(e: &Env, caller: Address) {␊
            let owner: Address = e.storage().instance().get(&OWNER).expect("owner should be set");␊
            if owner != caller {␊
                panic_with_error!(e, CustomTokenError::Unauthorized);␊
            }␊
            pausable::unpause(e, &caller);␊
        }␊
    }␊
    `
