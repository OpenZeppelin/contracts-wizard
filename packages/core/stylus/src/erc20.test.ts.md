# Snapshot report for `src/erc20.test.ts`

The actual snapshot is saved in `erc20.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## basic erc20

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0-alpha.3␊
    ␊
    use openzeppelin_stylus::token::erc20::{Erc20, IErc20};␊
    use openzeppelin_stylus::token::erc20::extensions::Erc20Metadata;␊
    use stylus_sdk::prelude::{entrypoint, public, storage};␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct MyToken {␊
        #[borrow]␊
        pub erc20: Erc20,␊
        #[borrow]␊
        pub metadata: Erc20Metadata,␊
    }␊
    ␊
    #[public]␊
    #[inherit(Erc20, Erc20Metadata)]␊
    impl MyToken {␊
        ␊
    }␊
    `

## erc20 burnable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0-alpha.3␊
    ␊
    use alloc::vec::Vec;␊
    use alloy_primitives::{Address, U256};␊
    use openzeppelin_stylus::token::erc20::{Erc20, IErc20};␊
    use openzeppelin_stylus::token::erc20::extensions::{Erc20Metadata, IErc20Burnable};␊
    use stylus_sdk::prelude::{entrypoint, public, storage};␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct MyToken {␊
        #[borrow]␊
        pub erc20: Erc20,␊
        #[borrow]␊
        pub metadata: Erc20Metadata,␊
    }␊
    ␊
    #[public]␊
    #[inherit(Erc20, Erc20Metadata)]␊
    impl MyToken {␊
        pub fn burn(&mut: self, value: U256) -> Result<(), Vec<u8>> {␊
            self.erc20.burn(value).map_err(|e| e.into())␊
        }␊
    ␊
        pub fn burn_from(&mut: self, account: Address, value: U256) -> Result<(), Vec<u8>> {␊
            self.erc20.burn_from(account, value).map_err(|e| e.into())␊
        }␊
        ␊
    }␊
    `

## erc20 pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0-alpha.3␊
    ␊
    use alloc::vec::Vec;␊
    use alloy_primitives::{Address, U256};␊
    use openzeppelin_stylus::access::ownable::Ownable;␊
    use openzeppelin_stylus::token::erc20::{Erc20, IErc20};␊
    use openzeppelin_stylus::token::erc20::extensions::Erc20Metadata;␊
    use openzeppelin_stylus::utils::Pausable;␊
    use stylus_sdk::prelude::{entrypoint, public, storage};␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct MyToken {␊
        #[borrow]␊
        pub erc20: Erc20,␊
        #[borrow]␊
        pub metadata: Erc20Metadata,␊
        #[borrow]␊
        pub ownable: Ownable,␊
        #[borrow]␊
        pub pausable: Pausable,␊
    }␊
    ␊
    #[public]␊
    #[inherit(Erc20, Erc20Metadata, Ownable, Pausable)]␊
    impl MyToken {␊
        pub fn transfer(&mut: self, to: Address, value: U256) -> Result<bool, Vec<u8>> {␊
            self.pausable.when_not_paused()?;␊
            self.erc20.transfer(to, value).map_err(|e| e.into())␊
        }␊
    ␊
        pub fn transfer_from(&mut: self, from: Address, to: Address, value: U256) -> Result<bool, Vec<u8>> {␊
            self.pausable.when_not_paused()?;␊
            self.erc20.transfer_from(from, to, value).map_err(|e| e.into())␊
        }␊
        ␊
        ␊
    ␊
        //␊
        // Pausable␊
        //␊
        ␊
        pub fn pause(&mut: self) -> Result<(), Vec<u8>> {␊
            self.ownable.only_owner()?;␊
            self.pausable.pause().map_err(|e| e.into())␊
        }␊
    ␊
        pub fn unpause(&mut: self) -> Result<(), Vec<u8>> {␊
            self.ownable.only_owner()?;␊
            self.pausable.unpause().map_err(|e| e.into())␊
        }␊
    }␊
    `

## erc20 burnable pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0-alpha.3␊
    ␊
    use alloc::vec::Vec;␊
    use alloy_primitives::{Address, U256};␊
    use openzeppelin_stylus::access::ownable::Ownable;␊
    use openzeppelin_stylus::token::erc20::{Erc20, IErc20};␊
    use openzeppelin_stylus::token::erc20::extensions::{Erc20Metadata, IErc20Burnable};␊
    use openzeppelin_stylus::utils::Pausable;␊
    use stylus_sdk::prelude::{entrypoint, public, storage};␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct MyToken {␊
        #[borrow]␊
        pub erc20: Erc20,␊
        #[borrow]␊
        pub metadata: Erc20Metadata,␊
        #[borrow]␊
        pub ownable: Ownable,␊
        #[borrow]␊
        pub pausable: Pausable,␊
    }␊
    ␊
    #[public]␊
    #[inherit(Erc20, Erc20Metadata, Ownable, Pausable)]␊
    impl MyToken {␊
        pub fn transfer(&mut: self, to: Address, value: U256) -> Result<bool, Vec<u8>> {␊
            self.pausable.when_not_paused()?;␊
            self.erc20.transfer(to, value).map_err(|e| e.into())␊
        }␊
    ␊
        pub fn transfer_from(&mut: self, from: Address, to: Address, value: U256) -> Result<bool, Vec<u8>> {␊
            self.pausable.when_not_paused()?;␊
            self.erc20.transfer_from(from, to, value).map_err(|e| e.into())␊
        }␊
    ␊
        pub fn burn(&mut: self, value: U256) -> Result<(), Vec<u8>> {␊
            self.pausable.when_not_paused()?;␊
            self.erc20.burn(value).map_err(|e| e.into())␊
        }␊
    ␊
        pub fn burn_from(&mut: self, account: Address, value: U256) -> Result<(), Vec<u8>> {␊
            self.pausable.when_not_paused()?;␊
            self.erc20.burn_from(account, value).map_err(|e| e.into())␊
        }␊
        ␊
        ␊
    ␊
        //␊
        // Pausable␊
        //␊
        ␊
        pub fn pause(&mut: self) -> Result<(), Vec<u8>> {␊
            self.ownable.only_owner()?;␊
            self.pausable.pause().map_err(|e| e.into())␊
        }␊
    ␊
        pub fn unpause(&mut: self) -> Result<(), Vec<u8>> {␊
            self.ownable.only_owner()?;␊
            self.pausable.unpause().map_err(|e| e.into())␊
        }␊
    }␊
    `

## erc20 full - complex name

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0-alpha.3␊
    ␊
    use alloc::vec::Vec;␊
    use alloy_primitives::{Address, U256};␊
    use openzeppelin_stylus::access::ownable::Ownable;␊
    use openzeppelin_stylus::token::erc20::{Erc20, IErc20};␊
    use openzeppelin_stylus::token::erc20::extensions::{Erc20Metadata, IErc20Burnable};␊
    use openzeppelin_stylus::utils::Pausable;␊
    use stylus_sdk::prelude::{entrypoint, public, storage};␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct CustomToken {␊
        #[borrow]␊
        pub erc20: Erc20,␊
        #[borrow]␊
        pub metadata: Erc20Metadata,␊
        #[borrow]␊
        pub ownable: Ownable,␊
        #[borrow]␊
        pub pausable: Pausable,␊
    }␊
    ␊
    #[public]␊
    #[inherit(Erc20, Erc20Metadata, Ownable, Pausable)]␊
    impl CustomToken {␊
        pub fn transfer(&mut: self, to: Address, value: U256) -> Result<bool, Vec<u8>> {␊
            self.pausable.when_not_paused()?;␊
            self.erc20.transfer(to, value).map_err(|e| e.into())␊
        }␊
    ␊
        pub fn transfer_from(&mut: self, from: Address, to: Address, value: U256) -> Result<bool, Vec<u8>> {␊
            self.pausable.when_not_paused()?;␊
            self.erc20.transfer_from(from, to, value).map_err(|e| e.into())␊
        }␊
    ␊
        pub fn burn(&mut: self, value: U256) -> Result<(), Vec<u8>> {␊
            self.pausable.when_not_paused()?;␊
            self.erc20.burn(value).map_err(|e| e.into())␊
        }␊
    ␊
        pub fn burn_from(&mut: self, account: Address, value: U256) -> Result<(), Vec<u8>> {␊
            self.pausable.when_not_paused()?;␊
            self.erc20.burn_from(account, value).map_err(|e| e.into())␊
        }␊
        ␊
        ␊
    ␊
        //␊
        // Pausable␊
        //␊
        ␊
        pub fn pause(&mut: self) -> Result<(), Vec<u8>> {␊
            self.ownable.only_owner()?;␊
            self.pausable.pause().map_err(|e| e.into())␊
        }␊
    ␊
        pub fn unpause(&mut: self) -> Result<(), Vec<u8>> {␊
            self.ownable.only_owner()?;␊
            self.pausable.unpause().map_err(|e| e.into())␊
        }␊
    }␊
    `
