# Snapshot report for `src/erc20.test.ts`

The actual snapshot is saved in `erc20.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## basic erc20

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0-alpha.3␊
    ␊
    #![cfg_attr(not(any(test, feature = "export-abi")), no_main)]␊
    extern crate alloc;␊
    ␊
    use openzeppelin_stylus::token::erc20::{Erc20, IErc20};␊
    use stylus_sdk::prelude::{entrypoint, public, storage};␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct MyToken {␊
        #[borrow]␊
        erc20: Erc20,␊
    }␊
    ␊
    #[public]␊
    #[inherit(Erc20)]␊
    impl MyToken {}␊
    `

## default erc20

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0-alpha.3␊
    ␊
    #![cfg_attr(not(any(test, feature = "export-abi")), no_main)]␊
    extern crate alloc;␊
    ␊
    use alloc::vec::Vec;␊
    use alloy_primitives::{Address, B256, U256};␊
    use openzeppelin_stylus::token::erc20::{Erc20, IErc20};␊
    use openzeppelin_stylus::token::erc20::extensions::Erc20Permit;␊
    use openzeppelin_stylus::utils::cryptography::eip712::IEip712;␊
    use stylus_sdk::prelude::{entrypoint, public, storage};␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct MyToken {␊
        #[borrow]␊
        erc20: Erc20,␊
        #[borrow]␊
        erc20_permit: Erc20Permit<Eip712>,␊
        #[borrow]␊
        nonces: Nonces,␊
    }␊
    ␊
    #[storage]␊
    struct Eip712 {}␊
    ␊
    impl IEip712 for Eip712 {␊
        const NAME: &'static str = "ERC-20 Permit Example";␊
        const VERSION: &'static str = "1";␊
    }␊
    ␊
    #[public]␊
    #[inherit(Erc20, Erc20Permit<Eip712>, Nonces)]␊
    impl MyToken {␊
        #[allow(clippy::too_many_arguments)]␊
        fn permit(␊
            &mut self,␊
            owner: Address,␊
            spender: Address,␊
            value: U256,␊
            deadline: U256,␊
            v: u8,␊
            r: B256,␊
            s: B256,␊
        ) -> Result<(), Vec<u8>> {␊
            self.erc20_permit.permit(owner, spender, value, deadline, v, r, s, &mut self.erc20, &mut self.nonces).map_err(|e| e.into())␊
        }␊
    }␊
    `

## erc20 burnable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0-alpha.3␊
    ␊
    #![cfg_attr(not(any(test, feature = "export-abi")), no_main)]␊
    extern crate alloc;␊
    ␊
    use alloc::vec::Vec;␊
    use alloy_primitives::{Address, U256};␊
    use openzeppelin_stylus::token::erc20::{Erc20, IErc20};␊
    use openzeppelin_stylus::token::erc20::extensions::IErc20Burnable;␊
    use stylus_sdk::prelude::{entrypoint, public, storage};␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct MyToken {␊
        #[borrow]␊
        erc20: Erc20,␊
    }␊
    ␊
    #[public]␊
    #[inherit(Erc20)]␊
    impl MyToken {␊
        fn burn(&mut self, value: U256) -> Result<(), Vec<u8>> {␊
            self.erc20.burn(value).map_err(|e| e.into())␊
        }␊
    ␊
        fn burn_from(&mut self, account: Address, value: U256) -> Result<(), Vec<u8>> {␊
            self.erc20.burn_from(account, value).map_err(|e| e.into())␊
        }␊
    }␊
    `

## erc20 permit

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0-alpha.3␊
    ␊
    #![cfg_attr(not(any(test, feature = "export-abi")), no_main)]␊
    extern crate alloc;␊
    ␊
    use alloc::vec::Vec;␊
    use alloy_primitives::{Address, B256, U256};␊
    use openzeppelin_stylus::token::erc20::{Erc20, IErc20};␊
    use openzeppelin_stylus::token::erc20::extensions::Erc20Permit;␊
    use openzeppelin_stylus::utils::cryptography::eip712::IEip712;␊
    use stylus_sdk::prelude::{entrypoint, public, storage};␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct MyToken {␊
        #[borrow]␊
        erc20: Erc20,␊
        #[borrow]␊
        erc20_permit: Erc20Permit<Eip712>,␊
        #[borrow]␊
        nonces: Nonces,␊
    }␊
    ␊
    #[storage]␊
    struct Eip712 {}␊
    ␊
    impl IEip712 for Eip712 {␊
        const NAME: &'static str = "ERC-20 Permit Example";␊
        const VERSION: &'static str = "1";␊
    }␊
    ␊
    #[public]␊
    #[inherit(Erc20, Erc20Permit<Eip712>, Nonces)]␊
    impl MyToken {␊
        #[allow(clippy::too_many_arguments)]␊
        fn permit(␊
            &mut self,␊
            owner: Address,␊
            spender: Address,␊
            value: U256,␊
            deadline: U256,␊
            v: u8,␊
            r: B256,␊
            s: B256,␊
        ) -> Result<(), Vec<u8>> {␊
            self.erc20_permit.permit(owner, spender, value, deadline, v, r, s, &mut self.erc20, &mut self.nonces).map_err(|e| e.into())␊
        }␊
    }␊
    `

## erc20 permit burnable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0-alpha.3␊
    ␊
    #![cfg_attr(not(any(test, feature = "export-abi")), no_main)]␊
    extern crate alloc;␊
    ␊
    use alloc::vec::Vec;␊
    use alloy_primitives::{Address, B256, U256};␊
    use openzeppelin_stylus::token::erc20::{Erc20, IErc20};␊
    use openzeppelin_stylus::token::erc20::extensions::{Erc20Permit, IErc20Burnable};␊
    use openzeppelin_stylus::utils::cryptography::eip712::IEip712;␊
    use stylus_sdk::prelude::{entrypoint, public, storage};␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct MyToken {␊
        #[borrow]␊
        erc20: Erc20,␊
        #[borrow]␊
        erc20_permit: Erc20Permit<Eip712>,␊
        #[borrow]␊
        nonces: Nonces,␊
    }␊
    ␊
    #[storage]␊
    struct Eip712 {}␊
    ␊
    impl IEip712 for Eip712 {␊
        const NAME: &'static str = "ERC-20 Permit Example";␊
        const VERSION: &'static str = "1";␊
    }␊
    ␊
    #[public]␊
    #[inherit(Erc20, Erc20Permit<Eip712>, Nonces)]␊
    impl MyToken {␊
        fn burn(&mut self, value: U256) -> Result<(), Vec<u8>> {␊
            self.erc20.burn(value).map_err(|e| e.into())␊
        }␊
    ␊
        fn burn_from(&mut self, account: Address, value: U256) -> Result<(), Vec<u8>> {␊
            self.erc20.burn_from(account, value).map_err(|e| e.into())␊
        }␊
    ␊
        #[allow(clippy::too_many_arguments)]␊
        fn permit(␊
            &mut self,␊
            owner: Address,␊
            spender: Address,␊
            value: U256,␊
            deadline: U256,␊
            v: u8,␊
            r: B256,␊
            s: B256,␊
        ) -> Result<(), Vec<u8>> {␊
            self.erc20_permit.permit(owner, spender, value, deadline, v, r, s, &mut self.erc20, &mut self.nonces).map_err(|e| e.into())␊
        }␊
    }␊
    `

## erc20 full - complex name

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Stylus ^0.2.0-alpha.3␊
    ␊
    #![cfg_attr(not(any(test, feature = "export-abi")), no_main)]␊
    extern crate alloc;␊
    ␊
    use alloc::vec::Vec;␊
    use alloy_primitives::{Address, B256, U256};␊
    use openzeppelin_stylus::token::erc20::{Erc20, IErc20};␊
    use openzeppelin_stylus::token::erc20::extensions::{Erc20Permit, IErc20Burnable};␊
    use openzeppelin_stylus::utils::cryptography::eip712::IEip712;␊
    use stylus_sdk::prelude::{entrypoint, public, storage};␊
    ␊
    #[entrypoint]␊
    #[storage]␊
    struct CustomToken {␊
        #[borrow]␊
        erc20: Erc20,␊
        #[borrow]␊
        erc20_permit: Erc20Permit<Eip712>,␊
        #[borrow]␊
        nonces: Nonces,␊
    }␊
    ␊
    #[storage]␊
    struct Eip712 {}␊
    ␊
    impl IEip712 for Eip712 {␊
        const NAME: &'static str = "ERC-20 Permit Example";␊
        const VERSION: &'static str = "1";␊
    }␊
    ␊
    #[public]␊
    #[inherit(Erc20, Erc20Permit<Eip712>, Nonces)]␊
    impl CustomToken {␊
        fn burn(&mut self, value: U256) -> Result<(), Vec<u8>> {␊
            self.erc20.burn(value).map_err(|e| e.into())␊
        }␊
    ␊
        fn burn_from(&mut self, account: Address, value: U256) -> Result<(), Vec<u8>> {␊
            self.erc20.burn_from(account, value).map_err(|e| e.into())␊
        }␊
    ␊
        #[allow(clippy::too_many_arguments)]␊
        fn permit(␊
            &mut self,␊
            owner: Address,␊
            spender: Address,␊
            value: U256,␊
            deadline: U256,␊
            v: u8,␊
            r: B256,␊
            s: B256,␊
        ) -> Result<(), Vec<u8>> {␊
            self.erc20_permit.permit(owner, spender, value, deadline, v, r, s, &mut self.erc20, &mut self.nonces).map_err(|e| e.into())␊
        }␊
    }␊
    `
