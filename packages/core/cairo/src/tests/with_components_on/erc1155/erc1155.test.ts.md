# Snapshot report for `src/tests/with_components_on/erc1155/erc1155.test.ts`

The actual snapshot is saved in `erc1155.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## basic non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Ownable)]␊
    mod MyToken {␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::ContractAddress;␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.ownable.assert_only_owner();␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    }␊
    `

## basic

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Ownable, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.ownable.assert_only_owner();␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## basic + roles

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, AccessControl, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::DEFAULT_ADMIN_ROLE;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{UPGRADER_ROLE, URI_SETTER_ROLE};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlComponent::AccessControlWithDelayImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            default_admin: ContractAddress,␊
            uri_setter: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control.initializer();␊
    ␊
            self.access_control._grant_role(DEFAULT_ADMIN_ROLE, default_admin);␊
            self.access_control._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## no updatable uri

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Upgradeable, Ownable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## burnable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Ownable, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress, get_caller_address};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, account: ContractAddress, token_id: u256, value: u256) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.burn(account, token_id, value);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_burn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.batch_burn(account, token_ids, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchBurn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                self.batch_burn(account, tokenIds, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.ownable.assert_only_owner();␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Pausable, Ownable, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        impl ERC1155HooksImpl of ERC1155Component::ERC1155HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC1155Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                to: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.ownable.assert_only_owner();␊
                self.pausable.unpause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.ownable.assert_only_owner();␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## mintable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Ownable, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_id: u256,␊
                value: u256,␊
                data: Span<felt252>,␊
            ) {␊
                self.ownable.assert_only_owner();␊
                self.erc1155.mint_with_acceptance_check(account, token_id, value, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.ownable.assert_only_owner();␊
                self.erc1155.batch_mint_with_acceptance_check(account, token_ids, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchMint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.batch_mint(account, tokenIds, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.ownable.assert_only_owner();␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## mintable + roles

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, AccessControl, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::DEFAULT_ADMIN_ROLE;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{MINTER_ROLE, UPGRADER_ROLE, URI_SETTER_ROLE};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlComponent::AccessControlWithDelayImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            default_admin: ContractAddress,␊
            minter: ContractAddress,␊
            uri_setter: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control.initializer();␊
    ␊
            self.access_control._grant_role(DEFAULT_ADMIN_ROLE, default_admin);␊
            self.access_control._grant_role(MINTER_ROLE, minter);␊
            self.access_control._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_id: u256,␊
                value: u256,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control.assert_only_role(MINTER_ROLE);␊
                self.erc1155.mint_with_acceptance_check(account, token_id, value, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control.assert_only_role(MINTER_ROLE);␊
                self.erc1155.batch_mint_with_acceptance_check(account, token_ids, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchMint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.batch_mint(account, tokenIds, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## mintable + roles DAR (default opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, AccessControlDefaultAdminRules, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::extensions::DefaultConfig as AccessControlDefaultAdminRulesDefaultConfig;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{MINTER_ROLE, UPGRADER_ROLE, URI_SETTER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 86400; // 1 day␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlDefaultAdminRulesComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlDefaultAdminRulesImpl = AccessControlDefaultAdminRulesComponent::AccessControlDefaultAdminRulesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlDefaultAdminRulesComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlDefaultAdminRulesComponent::AccessControlWithDelayImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            minter: ContractAddress,␊
            uri_setter: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
    ␊
            self.access_control_dar._grant_role(MINTER_ROLE, minter);␊
            self.access_control_dar._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control_dar._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_id: u256,␊
                value: u256,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc1155.mint_with_acceptance_check(account, token_id, value, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc1155.batch_mint_with_acceptance_check(account, token_ids, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchMint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.batch_mint(account, tokenIds, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control_dar.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## mintable + roles DAR (custom opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, AccessControlDefaultAdminRules, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{MINTER_ROLE, UPGRADER_ROLE, URI_SETTER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 172800; // 2 days␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlDefaultAdminRulesComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlDefaultAdminRulesImpl = AccessControlDefaultAdminRulesComponent::AccessControlDefaultAdminRulesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlDefaultAdminRulesComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlDefaultAdminRulesComponent::AccessControlWithDelayImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            minter: ContractAddress,␊
            uri_setter: ContractAddress,␊
            upgrader: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
    ␊
            self.access_control_dar._grant_role(MINTER_ROLE, minter);␊
            self.access_control_dar._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control_dar._grant_role(UPGRADER_ROLE, upgrader);␊
        }␊
    ␊
        impl AccessControlDefaultAdminRulesImmutableConfig of AccessControlDefaultAdminRulesComponent::ImmutableConfig {␊
            const DEFAULT_ADMIN_DELAY_INCREASE_WAIT: u64 = 604800; // 1 week␊
            const MAXIMUM_DEFAULT_ADMIN_TRANSFER_DELAY: u64 = 1209600; // 2 weeks␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_id: u256,␊
                value: u256,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc1155.mint_with_acceptance_check(account, token_id, value, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc1155.batch_mint_with_acceptance_check(account, token_ids, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchMint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.batch_mint(account, tokenIds, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control_dar.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## royalty info disabled

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Ownable, Upgradeable)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(ref self: ContractState, owner: ContractAddress) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.ownable.initializer(owner);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.ownable.assert_only_owner();␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## royalty info enabled default + ownable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Ownable, Upgradeable, ERC2981)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::common::erc2981::DefaultConfig as ERC2981DefaultConfig;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981Impl = ERC2981Component::ERC2981Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981InfoImpl = ERC2981Component::ERC2981InfoImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981AdminOwnableImpl = ERC2981Component::ERC2981AdminOwnableImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            owner: ContractAddress,␊
            default_royalty_receiver: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.ownable.initializer(owner);␊
            self.erc2981.initializer(default_royalty_receiver, 500);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.ownable.assert_only_owner();␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## royalty info enabled default + roles

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, AccessControl, Upgradeable, ERC2981)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::DEFAULT_ADMIN_ROLE;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::common::erc2981::DefaultConfig as ERC2981DefaultConfig;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{UPGRADER_ROLE, URI_SETTER_ROLE};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlComponent::AccessControlWithDelayImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981Impl = ERC2981Component::ERC2981Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981InfoImpl = ERC2981Component::ERC2981InfoImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981AdminAccessControlImpl = ERC2981Component::ERC2981AdminAccessControlImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            default_admin: ContractAddress,␊
            uri_setter: ContractAddress,␊
            upgrader: ContractAddress,␊
            default_royalty_receiver: ContractAddress,␊
            royalty_admin: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control.initializer();␊
            self.erc2981.initializer(default_royalty_receiver, 500);␊
    ␊
            self.access_control._grant_role(DEFAULT_ADMIN_ROLE, default_admin);␊
            self.access_control._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control._grant_role(UPGRADER_ROLE, upgrader);␊
            self.access_control._grant_role(ERC2981Component::ROYALTY_ADMIN_ROLE, royalty_admin);␊
        }␊
    ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## royalty info enabled default + roles-DAR (custom opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, AccessControlDefaultAdminRules, Upgradeable, ERC2981)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::common::erc2981::DefaultConfig as ERC2981DefaultConfig;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{UPGRADER_ROLE, URI_SETTER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 172800; // 2 days␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlDefaultAdminRulesComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlDefaultAdminRulesImpl = AccessControlDefaultAdminRulesComponent::AccessControlDefaultAdminRulesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlDefaultAdminRulesComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlDefaultAdminRulesComponent::AccessControlWithDelayImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981Impl = ERC2981Component::ERC2981Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981InfoImpl = ERC2981Component::ERC2981InfoImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981AdminAccessControlDefaultAdminRulesImpl = ERC2981Component::ERC2981AdminAccessControlDefaultAdminRulesImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            uri_setter: ContractAddress,␊
            upgrader: ContractAddress,␊
            default_royalty_receiver: ContractAddress,␊
            royalty_admin: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
            self.erc2981.initializer(default_royalty_receiver, 500);␊
    ␊
            self.access_control_dar._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control_dar._grant_role(UPGRADER_ROLE, upgrader);␊
            self.access_control_dar._grant_role(ERC2981Component::ROYALTY_ADMIN_ROLE, royalty_admin);␊
        }␊
    ␊
        impl AccessControlDefaultAdminRulesImmutableConfig of AccessControlDefaultAdminRulesComponent::ImmutableConfig {␊
            const DEFAULT_ADMIN_DELAY_INCREASE_WAIT: u64 = 604800; // 1 week␊
            const MAXIMUM_DEFAULT_ADMIN_TRANSFER_DELAY: u64 = 1209600; // 2 weeks␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control_dar.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## royalty info enabled custom + ownable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Ownable, Upgradeable, ERC2981)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl OwnableMixinImpl = OwnableComponent::OwnableMixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981Impl = ERC2981Component::ERC2981Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981InfoImpl = ERC2981Component::ERC2981InfoImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981AdminOwnableImpl = ERC2981Component::ERC2981AdminOwnableImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            owner: ContractAddress,␊
            default_royalty_receiver: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.ownable.initializer(owner);␊
            self.erc2981.initializer(default_royalty_receiver, 15125);␊
        }␊
    ␊
        impl ERC2981ImmutableConfig of ERC2981Component::ImmutableConfig {␊
            const FEE_DENOMINATOR: u128 = 100000;␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.ownable.assert_only_owner();␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.ownable.assert_only_owner();␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## royalty info enabled custom + roles

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, AccessControl, Upgradeable, ERC2981)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::DEFAULT_ADMIN_ROLE;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{UPGRADER_ROLE, URI_SETTER_ROLE};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlComponent::AccessControlWithDelayImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981Impl = ERC2981Component::ERC2981Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981InfoImpl = ERC2981Component::ERC2981InfoImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981AdminAccessControlImpl = ERC2981Component::ERC2981AdminAccessControlImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            default_admin: ContractAddress,␊
            uri_setter: ContractAddress,␊
            upgrader: ContractAddress,␊
            default_royalty_receiver: ContractAddress,␊
            royalty_admin: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control.initializer();␊
            self.erc2981.initializer(default_royalty_receiver, 15125);␊
    ␊
            self.access_control._grant_role(DEFAULT_ADMIN_ROLE, default_admin);␊
            self.access_control._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control._grant_role(UPGRADER_ROLE, upgrader);␊
            self.access_control._grant_role(ERC2981Component::ROYALTY_ADMIN_ROLE, royalty_admin);␊
        }␊
    ␊
        impl ERC2981ImmutableConfig of ERC2981Component::ImmutableConfig {␊
            const FEE_DENOMINATOR: u128 = 100000;␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## royalty info enabled custom + roles-DAR (default opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, AccessControlDefaultAdminRules, Upgradeable, ERC2981)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::extensions::DefaultConfig as AccessControlDefaultAdminRulesDefaultConfig;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{UPGRADER_ROLE, URI_SETTER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 86400; // 1 day␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlDefaultAdminRulesComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlDefaultAdminRulesImpl = AccessControlDefaultAdminRulesComponent::AccessControlDefaultAdminRulesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlDefaultAdminRulesComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlDefaultAdminRulesComponent::AccessControlWithDelayImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981Impl = ERC2981Component::ERC2981Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981InfoImpl = ERC2981Component::ERC2981InfoImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981AdminAccessControlDefaultAdminRulesImpl = ERC2981Component::ERC2981AdminAccessControlDefaultAdminRulesImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            uri_setter: ContractAddress,␊
            upgrader: ContractAddress,␊
            default_royalty_receiver: ContractAddress,␊
            royalty_admin: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
            self.erc2981.initializer(default_royalty_receiver, 15125);␊
    ␊
            self.access_control_dar._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control_dar._grant_role(UPGRADER_ROLE, upgrader);␊
            self.access_control_dar._grant_role(ERC2981Component::ROYALTY_ADMIN_ROLE, royalty_admin);␊
        }␊
    ␊
        impl ERC2981ImmutableConfig of ERC2981Component::ImmutableConfig {␊
            const FEE_DENOMINATOR: u128 = 100000;␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control_dar.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## royalty info enabled custom + roles-DAR (custom opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, AccessControlDefaultAdminRules, Upgradeable, ERC2981)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::erc1155::ERC1155HooksEmptyImpl;␊
        use starknet::{ClassHash, ContractAddress};␊
        use super::{UPGRADER_ROLE, URI_SETTER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 172800; // 2 days␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlDefaultAdminRulesComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlDefaultAdminRulesImpl = AccessControlDefaultAdminRulesComponent::AccessControlDefaultAdminRulesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlDefaultAdminRulesComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlDefaultAdminRulesComponent::AccessControlWithDelayImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981Impl = ERC2981Component::ERC2981Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981InfoImpl = ERC2981Component::ERC2981InfoImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981AdminAccessControlDefaultAdminRulesImpl = ERC2981Component::ERC2981AdminAccessControlDefaultAdminRulesImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            uri_setter: ContractAddress,␊
            upgrader: ContractAddress,␊
            default_royalty_receiver: ContractAddress,␊
            royalty_admin: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
            self.erc2981.initializer(default_royalty_receiver, 15125);␊
    ␊
            self.access_control_dar._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control_dar._grant_role(UPGRADER_ROLE, upgrader);␊
            self.access_control_dar._grant_role(ERC2981Component::ROYALTY_ADMIN_ROLE, royalty_admin);␊
        }␊
    ␊
        impl AccessControlDefaultAdminRulesImmutableConfig of AccessControlDefaultAdminRulesComponent::ImmutableConfig {␊
            const DEFAULT_ADMIN_DELAY_INCREASE_WAIT: u64 = 604800; // 1 week␊
            const MAXIMUM_DEFAULT_ADMIN_TRANSFER_DELAY: u64 = 1209600; // 2 weeks␊
        }␊
        ␊
        impl ERC2981ImmutableConfig of ERC2981Component::ImmutableConfig {␊
            const FEE_DENOMINATOR: u128 = 100000;␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control_dar.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## full non-upgradeable roles

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Pausable, AccessControl, ERC2981)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::DEFAULT_ADMIN_ROLE;␊
        use openzeppelin_token::common::erc2981::DefaultConfig as ERC2981DefaultConfig;␊
        use starknet::{ContractAddress, get_caller_address};␊
        use super::{MINTER_ROLE, PAUSER_ROLE, URI_SETTER_ROLE};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlComponent::AccessControlWithDelayImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981Impl = ERC2981Component::ERC2981Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981InfoImpl = ERC2981Component::ERC2981InfoImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981AdminAccessControlImpl = ERC2981Component::ERC2981AdminAccessControlImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            default_admin: ContractAddress,␊
            pauser: ContractAddress,␊
            minter: ContractAddress,␊
            uri_setter: ContractAddress,␊
            default_royalty_receiver: ContractAddress,␊
            royalty_admin: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control.initializer();␊
            self.erc2981.initializer(default_royalty_receiver, 500);␊
    ␊
            self.access_control._grant_role(DEFAULT_ADMIN_ROLE, default_admin);␊
            self.access_control._grant_role(PAUSER_ROLE, pauser);␊
            self.access_control._grant_role(MINTER_ROLE, minter);␊
            self.access_control._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control._grant_role(ERC2981Component::ROYALTY_ADMIN_ROLE, royalty_admin);␊
        }␊
    ␊
        impl ERC1155HooksImpl of ERC1155Component::ERC1155HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC1155Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                to: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.access_control.assert_only_role(PAUSER_ROLE);␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.access_control.assert_only_role(PAUSER_ROLE);␊
                self.pausable.unpause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, account: ContractAddress, token_id: u256, value: u256) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.burn(account, token_id, value);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_burn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.batch_burn(account, token_ids, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchBurn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                self.batch_burn(account, tokenIds, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_id: u256,␊
                value: u256,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control.assert_only_role(MINTER_ROLE);␊
                self.erc1155.mint_with_acceptance_check(account, token_id, value, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control.assert_only_role(MINTER_ROLE);␊
                self.erc1155.batch_mint_with_acceptance_check(account, token_ids, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchMint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.batch_mint(account, tokenIds, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    }␊
    `

## full upgradeable roles

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Pausable, AccessControl, Upgradeable, ERC2981)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::DEFAULT_ADMIN_ROLE;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::common::erc2981::DefaultConfig as ERC2981DefaultConfig;␊
        use starknet::{ClassHash, ContractAddress, get_caller_address};␊
        use super::{MINTER_ROLE, PAUSER_ROLE, UPGRADER_ROLE, URI_SETTER_ROLE};␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlComponent::AccessControlWithDelayImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981Impl = ERC2981Component::ERC2981Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981InfoImpl = ERC2981Component::ERC2981InfoImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981AdminAccessControlImpl = ERC2981Component::ERC2981AdminAccessControlImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            default_admin: ContractAddress,␊
            pauser: ContractAddress,␊
            minter: ContractAddress,␊
            uri_setter: ContractAddress,␊
            upgrader: ContractAddress,␊
            default_royalty_receiver: ContractAddress,␊
            royalty_admin: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control.initializer();␊
            self.erc2981.initializer(default_royalty_receiver, 500);␊
    ␊
            self.access_control._grant_role(DEFAULT_ADMIN_ROLE, default_admin);␊
            self.access_control._grant_role(PAUSER_ROLE, pauser);␊
            self.access_control._grant_role(MINTER_ROLE, minter);␊
            self.access_control._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control._grant_role(UPGRADER_ROLE, upgrader);␊
            self.access_control._grant_role(ERC2981Component::ROYALTY_ADMIN_ROLE, royalty_admin);␊
        }␊
    ␊
        impl ERC1155HooksImpl of ERC1155Component::ERC1155HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC1155Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                to: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.access_control.assert_only_role(PAUSER_ROLE);␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.access_control.assert_only_role(PAUSER_ROLE);␊
                self.pausable.unpause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, account: ContractAddress, token_id: u256, value: u256) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.burn(account, token_id, value);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_burn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.batch_burn(account, token_ids, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchBurn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                self.batch_burn(account, tokenIds, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_id: u256,␊
                value: u256,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control.assert_only_role(MINTER_ROLE);␊
                self.erc1155.mint_with_acceptance_check(account, token_id, value, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control.assert_only_role(MINTER_ROLE);␊
                self.erc1155.batch_mint_with_acceptance_check(account, token_ids, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchMint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.batch_mint(account, tokenIds, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## full non-upgradeable roles-DAR (default opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Pausable, AccessControlDefaultAdminRules, ERC2981)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::extensions::DefaultConfig as AccessControlDefaultAdminRulesDefaultConfig;␊
        use openzeppelin_token::common::erc2981::DefaultConfig as ERC2981DefaultConfig;␊
        use starknet::{ContractAddress, get_caller_address};␊
        use super::{MINTER_ROLE, PAUSER_ROLE, URI_SETTER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 86400; // 1 day␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlDefaultAdminRulesComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlDefaultAdminRulesImpl = AccessControlDefaultAdminRulesComponent::AccessControlDefaultAdminRulesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlDefaultAdminRulesComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlDefaultAdminRulesComponent::AccessControlWithDelayImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981Impl = ERC2981Component::ERC2981Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981InfoImpl = ERC2981Component::ERC2981InfoImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981AdminAccessControlDefaultAdminRulesImpl = ERC2981Component::ERC2981AdminAccessControlDefaultAdminRulesImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            pauser: ContractAddress,␊
            minter: ContractAddress,␊
            uri_setter: ContractAddress,␊
            default_royalty_receiver: ContractAddress,␊
            royalty_admin: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
            self.erc2981.initializer(default_royalty_receiver, 500);␊
    ␊
            self.access_control_dar._grant_role(PAUSER_ROLE, pauser);␊
            self.access_control_dar._grant_role(MINTER_ROLE, minter);␊
            self.access_control_dar._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control_dar._grant_role(ERC2981Component::ROYALTY_ADMIN_ROLE, royalty_admin);␊
        }␊
    ␊
        impl ERC1155HooksImpl of ERC1155Component::ERC1155HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC1155Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                to: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.unpause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, account: ContractAddress, token_id: u256, value: u256) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.burn(account, token_id, value);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_burn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.batch_burn(account, token_ids, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchBurn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                self.batch_burn(account, tokenIds, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_id: u256,␊
                value: u256,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc1155.mint_with_acceptance_check(account, token_id, value, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc1155.batch_mint_with_acceptance_check(account, token_ids, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchMint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.batch_mint(account, tokenIds, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control_dar.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    }␊
    `

## full non-upgradeable roles-DAR (custom opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Pausable, AccessControlDefaultAdminRules, ERC2981)]␊
    mod MyToken {␊
        use openzeppelin_token::common::erc2981::DefaultConfig as ERC2981DefaultConfig;␊
        use starknet::{ContractAddress, get_caller_address};␊
        use super::{MINTER_ROLE, PAUSER_ROLE, URI_SETTER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 172800; // 2 days␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlDefaultAdminRulesComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlDefaultAdminRulesImpl = AccessControlDefaultAdminRulesComponent::AccessControlDefaultAdminRulesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlDefaultAdminRulesComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlDefaultAdminRulesComponent::AccessControlWithDelayImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981Impl = ERC2981Component::ERC2981Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981InfoImpl = ERC2981Component::ERC2981InfoImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981AdminAccessControlDefaultAdminRulesImpl = ERC2981Component::ERC2981AdminAccessControlDefaultAdminRulesImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            pauser: ContractAddress,␊
            minter: ContractAddress,␊
            uri_setter: ContractAddress,␊
            default_royalty_receiver: ContractAddress,␊
            royalty_admin: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
            self.erc2981.initializer(default_royalty_receiver, 500);␊
    ␊
            self.access_control_dar._grant_role(PAUSER_ROLE, pauser);␊
            self.access_control_dar._grant_role(MINTER_ROLE, minter);␊
            self.access_control_dar._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control_dar._grant_role(ERC2981Component::ROYALTY_ADMIN_ROLE, royalty_admin);␊
        }␊
    ␊
        impl ERC1155HooksImpl of ERC1155Component::ERC1155HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC1155Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                to: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
        }␊
        ␊
        impl AccessControlDefaultAdminRulesImmutableConfig of AccessControlDefaultAdminRulesComponent::ImmutableConfig {␊
            const DEFAULT_ADMIN_DELAY_INCREASE_WAIT: u64 = 604800; // 1 week␊
            const MAXIMUM_DEFAULT_ADMIN_TRANSFER_DELAY: u64 = 1209600; // 2 weeks␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.unpause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, account: ContractAddress, token_id: u256, value: u256) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.burn(account, token_id, value);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_burn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.batch_burn(account, token_ids, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchBurn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                self.batch_burn(account, tokenIds, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_id: u256,␊
                value: u256,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc1155.mint_with_acceptance_check(account, token_id, value, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc1155.batch_mint_with_acceptance_check(account, token_ids, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchMint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.batch_mint(account, tokenIds, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control_dar.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    }␊
    `

## full upgradeable roles-DAR (default opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Pausable, AccessControlDefaultAdminRules, Upgradeable, ERC2981)]␊
    mod MyToken {␊
        use openzeppelin_access::accesscontrol::extensions::DefaultConfig as AccessControlDefaultAdminRulesDefaultConfig;␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::common::erc2981::DefaultConfig as ERC2981DefaultConfig;␊
        use starknet::{ClassHash, ContractAddress, get_caller_address};␊
        use super::{MINTER_ROLE, PAUSER_ROLE, UPGRADER_ROLE, URI_SETTER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 86400; // 1 day␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlDefaultAdminRulesComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlDefaultAdminRulesImpl = AccessControlDefaultAdminRulesComponent::AccessControlDefaultAdminRulesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlDefaultAdminRulesComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlDefaultAdminRulesComponent::AccessControlWithDelayImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981Impl = ERC2981Component::ERC2981Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981InfoImpl = ERC2981Component::ERC2981InfoImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981AdminAccessControlDefaultAdminRulesImpl = ERC2981Component::ERC2981AdminAccessControlDefaultAdminRulesImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            pauser: ContractAddress,␊
            minter: ContractAddress,␊
            uri_setter: ContractAddress,␊
            upgrader: ContractAddress,␊
            default_royalty_receiver: ContractAddress,␊
            royalty_admin: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
            self.erc2981.initializer(default_royalty_receiver, 500);␊
    ␊
            self.access_control_dar._grant_role(PAUSER_ROLE, pauser);␊
            self.access_control_dar._grant_role(MINTER_ROLE, minter);␊
            self.access_control_dar._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control_dar._grant_role(UPGRADER_ROLE, upgrader);␊
            self.access_control_dar._grant_role(ERC2981Component::ROYALTY_ADMIN_ROLE, royalty_admin);␊
        }␊
    ␊
        impl ERC1155HooksImpl of ERC1155Component::ERC1155HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC1155Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                to: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.unpause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, account: ContractAddress, token_id: u256, value: u256) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.burn(account, token_id, value);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_burn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.batch_burn(account, token_ids, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchBurn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                self.batch_burn(account, tokenIds, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_id: u256,␊
                value: u256,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc1155.mint_with_acceptance_check(account, token_id, value, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc1155.batch_mint_with_acceptance_check(account, token_ids, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchMint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.batch_mint(account, tokenIds, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control_dar.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `

## full upgradeable roles-DAR (custom opts)

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts for Cairo ^3.0.0␊
    ␊
    const PAUSER_ROLE: felt252 = selector!("PAUSER_ROLE");␊
    const MINTER_ROLE: felt252 = selector!("MINTER_ROLE");␊
    const URI_SETTER_ROLE: felt252 = selector!("URI_SETTER_ROLE");␊
    const UPGRADER_ROLE: felt252 = selector!("UPGRADER_ROLE");␊
    ␊
    #[starknet::contract]␊
    #[with_components(ERC1155, SRC5, Pausable, AccessControlDefaultAdminRules, Upgradeable, ERC2981)]␊
    mod MyToken {␊
        use openzeppelin_interfaces::upgrades::IUpgradeable;␊
        use openzeppelin_token::common::erc2981::DefaultConfig as ERC2981DefaultConfig;␊
        use starknet::{ClassHash, ContractAddress, get_caller_address};␊
        use super::{MINTER_ROLE, PAUSER_ROLE, UPGRADER_ROLE, URI_SETTER_ROLE};␊
    ␊
        const INITIAL_DELAY: u64 = 172800; // 2 days␊
    ␊
        // External␊
        #[abi(embed_v0)]␊
        impl ERC1155MixinImpl = ERC1155Component::ERC1155MixinImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl PausableImpl = PausableComponent::PausableImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlImpl = AccessControlDefaultAdminRulesComponent::AccessControlImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlDefaultAdminRulesImpl = AccessControlDefaultAdminRulesComponent::AccessControlDefaultAdminRulesImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlCamelImpl = AccessControlDefaultAdminRulesComponent::AccessControlCamelImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl AccessControlWithDelayImpl = AccessControlDefaultAdminRulesComponent::AccessControlWithDelayImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981Impl = ERC2981Component::ERC2981Impl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981InfoImpl = ERC2981Component::ERC2981InfoImpl<ContractState>;␊
        #[abi(embed_v0)]␊
        impl ERC2981AdminAccessControlDefaultAdminRulesImpl = ERC2981Component::ERC2981AdminAccessControlDefaultAdminRulesImpl<ContractState>;␊
    ␊
        #[storage]␊
        struct Storage {}␊
    ␊
        #[constructor]␊
        fn constructor(␊
            ref self: ContractState,␊
            initial_default_admin: ContractAddress,␊
            pauser: ContractAddress,␊
            minter: ContractAddress,␊
            uri_setter: ContractAddress,␊
            upgrader: ContractAddress,␊
            default_royalty_receiver: ContractAddress,␊
            royalty_admin: ContractAddress,␊
        ) {␊
            self.erc1155.initializer("https://gateway.pinata.cloud/ipfs/QmcP9hxrnC1T5ATPmq2saFeAM1ypFX9BnAswCdHB9JCjLA/");␊
            self.access_control_dar.initializer(INITIAL_DELAY, initial_default_admin);␊
            self.erc2981.initializer(default_royalty_receiver, 500);␊
    ␊
            self.access_control_dar._grant_role(PAUSER_ROLE, pauser);␊
            self.access_control_dar._grant_role(MINTER_ROLE, minter);␊
            self.access_control_dar._grant_role(URI_SETTER_ROLE, uri_setter);␊
            self.access_control_dar._grant_role(UPGRADER_ROLE, upgrader);␊
            self.access_control_dar._grant_role(ERC2981Component::ROYALTY_ADMIN_ROLE, royalty_admin);␊
        }␊
    ␊
        impl ERC1155HooksImpl of ERC1155Component::ERC1155HooksTrait<ContractState> {␊
            fn before_update(␊
                ref self: ERC1155Component::ComponentState<ContractState>,␊
                from: ContractAddress,␊
                to: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let contract_state = self.get_contract();␊
                contract_state.pausable.assert_not_paused();␊
            }␊
        }␊
        ␊
        impl AccessControlDefaultAdminRulesImmutableConfig of AccessControlDefaultAdminRulesComponent::ImmutableConfig {␊
            const DEFAULT_ADMIN_DELAY_INCREASE_WAIT: u64 = 604800; // 1 week␊
            const MAXIMUM_DEFAULT_ADMIN_TRANSFER_DELAY: u64 = 1209600; // 2 weeks␊
        }␊
        ␊
        #[generate_trait]␊
        #[abi(per_item)]␊
        impl ExternalImpl of ExternalTrait {␊
            #[external(v0)]␊
            fn pause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.pause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn unpause(ref self: ContractState) {␊
                self.access_control_dar.assert_only_role(PAUSER_ROLE);␊
                self.pausable.unpause();␊
            }␊
    ␊
            #[external(v0)]␊
            fn burn(ref self: ContractState, account: ContractAddress, token_id: u256, value: u256) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.burn(account, token_id, value);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_burn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                let caller = get_caller_address();␊
                if account != caller {␊
                    assert(self.erc1155.is_approved_for_all(account, caller), ERC1155Component::Errors::UNAUTHORIZED);␊
                }␊
                self.erc1155.batch_burn(account, token_ids, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchBurn(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
            ) {␊
                self.batch_burn(account, tokenIds, values);␊
            }␊
    ␊
            #[external(v0)]␊
            fn mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_id: u256,␊
                value: u256,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc1155.mint_with_acceptance_check(account, token_id, value, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batch_mint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                token_ids: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.access_control_dar.assert_only_role(MINTER_ROLE);␊
                self.erc1155.batch_mint_with_acceptance_check(account, token_ids, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn batchMint(␊
                ref self: ContractState,␊
                account: ContractAddress,␊
                tokenIds: Span<u256>,␊
                values: Span<u256>,␊
                data: Span<felt252>,␊
            ) {␊
                self.batch_mint(account, tokenIds, values, data);␊
            }␊
    ␊
            #[external(v0)]␊
            fn set_base_uri(ref self: ContractState, base_uri: ByteArray) {␊
                self.access_control_dar.assert_only_role(URI_SETTER_ROLE);␊
                self.erc1155._set_base_uri(base_uri);␊
            }␊
    ␊
            #[external(v0)]␊
            fn setBaseUri(ref self: ContractState, baseUri: ByteArray) {␊
                self.set_base_uri(baseUri);␊
            }␊
        }␊
    ␊
        //␊
        // Upgradeable␊
        //␊
        ␊
        #[abi(embed_v0)]␊
        impl UpgradeableImpl of IUpgradeable<ContractState> {␊
            fn upgrade(ref self: ContractState, new_class_hash: ClassHash) {␊
                self.access_control_dar.assert_only_role(UPGRADER_ROLE);␊
                self.upgradeable.upgrade(new_class_hash);␊
            }␊
        }␊
    }␊
    `
