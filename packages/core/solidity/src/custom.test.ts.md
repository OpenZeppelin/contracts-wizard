# Snapshot report for `src/custom.test.ts`

The actual snapshot is saved in `custom.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## custom

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.0.0␊
    pragma solidity ^0.8.27;␊
    ␊
    contract MyContract {␊
    }␊
    `

## custom name is unicode safe

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.0.0␊
    pragma solidity ^0.8.27;␊
    ␊
    contract Contract {␊
    }␊
    `

## pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.0.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";␊
    import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol";␊
    ␊
    contract MyContract is Pausable, Ownable {␊
        constructor(address initialOwner) Ownable(initialOwner) {}␊
    ␊
        function pause() public onlyOwner {␊
            _pause();␊
        }␊
    ␊
        function unpause() public onlyOwner {␊
            _unpause();␊
        }␊
    }␊
    `

## upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.0.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    ␊
    contract MyContract is Initializable {␊
        /// @custom:oz-upgrades-unsafe-allow constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    }␊
    `

## upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.0.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyContract is Initializable, OwnableUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address initialOwner) public initializer {␊
            __Ownable_init(initialOwner);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyOwner␊
        {}␊
    }␊
    `

## access control disabled

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.0.0␊
    pragma solidity ^0.8.27;␊
    ␊
    contract MyContract {␊
    }␊
    `

## access control ownable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.0.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";␊
    ␊
    contract MyContract is Ownable {␊
        constructor(address initialOwner) Ownable(initialOwner) {}␊
    }␊
    `

## access control roles

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.0.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";␊
    ␊
    contract MyContract is AccessControl {␊
        constructor(address defaultAdmin) {␊
            _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);␊
        }␊
    }␊
    `

## access control managed

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.0.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AccessManaged} from "@openzeppelin/contracts/access/manager/AccessManaged.sol";␊
    ␊
    contract MyContract is AccessManaged {␊
        constructor(address initialAuthority) AccessManaged(initialAuthority) {}␊
    }␊
    `

## superchain messaging

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.0.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {IL2ToL2CrossDomainMessenger} from "@eth-optimism/contracts-bedrock/src/L2/IL2ToL2CrossDomainMessenger.sol";␊
    import {Predeploys} from "@eth-optimism/contracts-bedrock/src/libraries/Predeploys.sol";␊
    ␊
    contract MyContract {␊
        /// @custom:oz-upgrades-unsafe-allow state-variable-immutable␊
        IL2ToL2CrossDomainMessenger public immutable messenger = IL2ToL2CrossDomainMessenger(Predeploys.L2_TO_L2_CROSS_DOMAIN_MESSENGER);␊
    ␊
        error CallerNotL2ToL2CrossDomainMessenger();␊
        error InvalidCrossDomainSender();␊
        error InvalidDestination();␊
    ␊
        modifier onlyCrossDomainCallback() {␊
            if (msg.sender != address(messenger)) revert CallerNotL2ToL2CrossDomainMessenger();␊
            if (messenger.crossDomainMessageSender() != address(this)) revert InvalidCrossDomainSender();␊
            _;␊
        }␊
    ␊
        /// @dev NOTE: This function is unprotected. Anyone can call this function.␊
        function callMyFunction(uint256 _toChainId) public {␊
            if (_toChainId == block.chainid) revert InvalidDestination();␊
            messenger.sendMessage(_toChainId, address(this), abi.encodeCall(this.myFunction, (/* TODO: Add arguments */)));␊
        }␊
    ␊
        /**␊
         * @dev IMPORTANT: This function trusts contracts at the same address on other chains.␊
         * If an unauthorized contract is deployed at the same address on any chain in the Superchain, it could allow␊
         * malicious actors to invoke your function from that chain.␊
         * To prevent this, you must either design the deployer to allow only this contract's bytecode to be deployed␊
         * through it, or use CREATE2 from a deployer contract that is itself deployed by an EOA you control.␊
         */␊
        function myFunction(/* TODO: Add arguments */) external onlyCrossDomainCallback {␊
            // TODO: Implement logic for the function that will be called from another chain␊
        }␊
    }␊
    `

## superchain messaging ownable pausable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.0.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {IL2ToL2CrossDomainMessenger} from "@eth-optimism/contracts-bedrock/src/L2/IL2ToL2CrossDomainMessenger.sol";␊
    import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";␊
    import {Pausable} from "@openzeppelin/contracts/utils/Pausable.sol";␊
    import {Predeploys} from "@eth-optimism/contracts-bedrock/src/libraries/Predeploys.sol";␊
    ␊
    contract MyContract is Ownable, Pausable {␊
        /// @custom:oz-upgrades-unsafe-allow state-variable-immutable␊
        IL2ToL2CrossDomainMessenger public immutable messenger = IL2ToL2CrossDomainMessenger(Predeploys.L2_TO_L2_CROSS_DOMAIN_MESSENGER);␊
    ␊
        error CallerNotL2ToL2CrossDomainMessenger();␊
        error InvalidCrossDomainSender();␊
        error InvalidDestination();␊
    ␊
        modifier onlyCrossDomainCallback() {␊
            if (msg.sender != address(messenger)) revert CallerNotL2ToL2CrossDomainMessenger();␊
            if (messenger.crossDomainMessageSender() != address(this)) revert InvalidCrossDomainSender();␊
            _;␊
        }␊
    ␊
        constructor(address initialOwner) Ownable(initialOwner) {}␊
    ␊
        function callMyFunction(uint256 _toChainId) public onlyOwner whenNotPaused {␊
            if (_toChainId == block.chainid) revert InvalidDestination();␊
            messenger.sendMessage(_toChainId, address(this), abi.encodeCall(this.myFunction, (/* TODO: Add arguments */)));␊
        }␊
    ␊
        /**␊
         * @dev IMPORTANT: This function trusts contracts at the same address on other chains.␊
         * If an unauthorized contract is deployed at the same address on any chain in the Superchain, it could allow␊
         * malicious actors to invoke your function from that chain.␊
         * To prevent this, you must either design the deployer to allow only this contract's bytecode to be deployed␊
         * through it, or use CREATE2 from a deployer contract that is itself deployed by an EOA you control.␊
         */␊
        function myFunction(/* TODO: Add arguments */) external onlyCrossDomainCallback whenNotPaused {␊
            // TODO: Implement logic for the function that will be called from another chain␊
        }␊
    ␊
        function pause() public onlyOwner {␊
            _pause();␊
        }␊
    ␊
        function unpause() public onlyOwner {␊
            _unpause();␊
        }␊
    }␊
    `

## upgradeable uups with access control disabled

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.0.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyContract is Initializable, OwnableUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address initialOwner) public initializer {␊
            __Ownable_init(initialOwner);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyOwner␊
        {}␊
    }␊
    `
