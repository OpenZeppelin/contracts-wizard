# Snapshot report for `src/account.test.ts`

The actual snapshot is saved in `account.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## Account named non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    ␊
    contract CustomAccount is Account, EIP712, ERC7739 {␊
        constructor() EIP712("CustomAccount", "1") {}␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    ␊
    contract CustomAccountERC1271 is Account, IERC1271 {␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    ␊
    contract CustomAccountERC7739 is Account, EIP712, ERC7739 {␊
        constructor() EIP712("CustomAccountERC7739", "1") {}␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC721Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    ␊
    contract CustomAccountERC721Holder is Account, EIP712, ERC7739, ERC721Holder {␊
        constructor() EIP712("CustomAccountERC721Holder", "1") {}␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    ␊
    contract CustomAccountERC1155Holder is Account, EIP712, ERC7739, ERC1155Holder {␊
        constructor() EIP712("CustomAccountERC1155Holder", "1") {}␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC721Holder and ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    ␊
    contract CustomAccountERC721HolderERC1155Holder is Account, EIP712, ERC7739, ERC721Holder, ERC1155Holder {␊
        constructor() EIP712("CustomAccountERC721HolderERC1155Holder", "1") {}␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC7821 Execution non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, ERC7821 {␊
        constructor() EIP712("MyAccount", "1") {}␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC7579 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579 {␊
        constructor(uint256 moduleTypeId, address module, bytes calldata initData)␊
            EIP712("MyAccount", "1")␊
        {␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    `

## Account with ERC7579 with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Account, IERC1271, AccountERC7579 {␊
        constructor(uint256 moduleTypeId, address module, bytes calldata initData) {␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    }␊
    `

## Account with ERC7579 with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579 {␊
        constructor(uint256 moduleTypeId, address module, bytes calldata initData)␊
            EIP712("MyAccount", "1")␊
        {␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    `

## Account with ERC7579 hooks non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {AccountERC7579Hooked} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579Hooked.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579Hooked {␊
        constructor(uint256 moduleTypeId, address module, bytes calldata initData)␊
            EIP712("MyAccount", "1")␊
        {␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    `

## Account named upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccount is Initializable, Account, EIP712, ERC7739, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize() public initializer {␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with ERC1271 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountERC1271 is Initializable, Account, IERC1271, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize() public initializer {␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with ERC7739 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountERC7739 is Initializable, Account, EIP712, ERC7739, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccountERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize() public initializer {␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with ERC721Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountERC721Holder is Initializable, Account, EIP712, ERC7739, ERC721Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccountERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize() public initializer {␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with ERC1155Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountERC1155Holder is Initializable, Account, EIP712, ERC7739, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccountERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize() public initializer {␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with ERC721Holder and ERC1155Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, ERC721Holder, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccountERC721HolderERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize() public initializer {␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with ERC7821 Execution upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, ERC7821, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize() public initializer {␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with ERC7579 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __UUPSUpgradeable_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    `

## Account with ERC7579 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __UUPSUpgradeable_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (moduleTypeId, module, initData));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (moduleTypeId, module, initData)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with ERC7579 with ERC1271 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __UUPSUpgradeable_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    }␊
    `

## Account with ERC7579 with ERC1271 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __UUPSUpgradeable_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (moduleTypeId, module, initData));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (moduleTypeId, module, initData)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with ERC7579 with ERC7739 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __UUPSUpgradeable_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    `

## Account with ERC7579 with ERC7739 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __UUPSUpgradeable_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (moduleTypeId, module, initData));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (moduleTypeId, module, initData)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with ERC7579 hooks upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579Hooked_init();␊
            __UUPSUpgradeable_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    `

## Account with ERC7579 hooks upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579Hooked_init();␊
            __UUPSUpgradeable_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (moduleTypeId, module, initData));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (moduleTypeId, module, initData)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account named upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    ␊
    contract CustomAccount is Initializable, Account, EIP712, ERC7739 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC1271 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    ␊
    contract CustomAccountERC1271 is Initializable, Account, IERC1271 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC7739 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    ␊
    contract CustomAccountERC7739 is Initializable, Account, EIP712, ERC7739 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccountERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC721Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    ␊
    contract CustomAccountERC721Holder is Initializable, Account, EIP712, ERC7739, ERC721Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccountERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC1155Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    ␊
    contract CustomAccountERC1155Holder is Initializable, Account, EIP712, ERC7739, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccountERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC721Holder and ERC1155Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    ␊
    contract CustomAccountERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, ERC721Holder, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccountERC721HolderERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC7821 Execution upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, ERC7821 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    ␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            // Custom validation logic␊
            return false;␊
        }␊
    }␊
    `

## Account with ERC7579 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    `

## Account with ERC7579 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(moduleTypeId, module, initData, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(moduleTypeId, module, initData);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(moduleTypeId, module, initData, salt));␊
        }␊
    ␊
        function _salt(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(moduleTypeId, module, initData, salt));␊
        }␊
    }␊
    `

## Account with ERC7579 with ERC1271 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    }␊
    `

## Account with ERC7579 with ERC1271 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(moduleTypeId, module, initData, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(moduleTypeId, module, initData);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(moduleTypeId, module, initData, salt));␊
        }␊
    ␊
        function _salt(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(moduleTypeId, module, initData, salt));␊
        }␊
    }␊
    `

## Account with ERC7579 with ERC7739 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    `

## Account with ERC7579 with ERC7739 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(moduleTypeId, module, initData, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(moduleTypeId, module, initData);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(moduleTypeId, module, initData, salt));␊
        }␊
    ␊
        function _salt(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(moduleTypeId, module, initData, salt));␊
        }␊
    }␊
    `

## Account with ERC7579 hooks upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579Hooked_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    `

## Account with ERC7579 hooks upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MODULE_TYPE_EXECUTOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {MODULE_TYPE_VALIDATOR} from "@openzeppelin/contracts/interfaces/draft-IERC7579.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(uint256 moduleTypeId, address module, bytes calldata initData)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579Hooked_init();␊
    ␊
            require(moduleTypeId == MODULE_TYPE_VALIDATOR || moduleTypeId == MODULE_TYPE_EXECUTOR);␊
            _installModule(moduleTypeId, module, initData);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(moduleTypeId, module, initData, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(moduleTypeId, module, initData);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(moduleTypeId, module, initData, salt));␊
        }␊
    ␊
        function _salt(uint256 moduleTypeId, address module, bytes calldata initData, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(moduleTypeId, module, initData, salt));␊
        }␊
    }␊
    `

## Account with SignerERC7702 named non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerERC7702} from "@openzeppelin/contracts/utils/cryptography/signers/SignerERC7702.sol";␊
    ␊
    contract CustomAccountWithSignerERC7702 is Account, EIP712, ERC7739, SignerERC7702 {␊
        constructor() EIP712("CustomAccount with SignerERC7702", "1") {}␊
    }␊
    `

## Account with SignerERC7702 with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {SignerERC7702} from "@openzeppelin/contracts/utils/cryptography/signers/SignerERC7702.sol";␊
    ␊
    contract CustomAccountWithSignerERC7702ERC1271 is Account, IERC1271, SignerERC7702 {␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    }␊
    `

## Account with SignerERC7702 with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerERC7702} from "@openzeppelin/contracts/utils/cryptography/signers/SignerERC7702.sol";␊
    ␊
    contract CustomAccountWithSignerERC7702ERC7739 is Account, EIP712, ERC7739, SignerERC7702 {␊
        constructor() EIP712("CustomAccount with SignerERC7702ERC7739", "1") {}␊
    }␊
    `

## Account with SignerERC7702 with ERC721Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerERC7702} from "@openzeppelin/contracts/utils/cryptography/signers/SignerERC7702.sol";␊
    ␊
    contract CustomAccountWithSignerERC7702ERC721Holder is Account, EIP712, ERC7739, SignerERC7702, ERC721Holder {␊
        constructor() EIP712("CustomAccount with SignerERC7702ERC721Holder", "1") {}␊
    }␊
    `

## Account with SignerERC7702 with ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerERC7702} from "@openzeppelin/contracts/utils/cryptography/signers/SignerERC7702.sol";␊
    ␊
    contract CustomAccountWithSignerERC7702ERC1155Holder is Account, EIP712, ERC7739, SignerERC7702, ERC1155Holder {␊
        constructor() EIP712("CustomAccount with SignerERC7702ERC1155Holder", "1") {}␊
    }␊
    `

## Account with SignerERC7702 with ERC721Holder and ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerERC7702} from "@openzeppelin/contracts/utils/cryptography/signers/SignerERC7702.sol";␊
    ␊
    contract CustomAccountWithSignerERC7702ERC721HolderERC1155Holder is Account, EIP712, ERC7739, SignerERC7702, ERC721Holder, ERC1155Holder {␊
        constructor()␊
            EIP712("CustomAccount with SignerERC7702ERC721HolderERC1155Holder", "1")␊
        {}␊
    }␊
    `

## Account with SignerERC7702 with ERC7821 Execution non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {SignerERC7702} from "@openzeppelin/contracts/utils/cryptography/signers/SignerERC7702.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, SignerERC7702, ERC7821 {␊
        constructor() EIP712("MyAccount", "1") {}␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    `

## Account with SignerERC7702 with ERC7579 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerERC7702} from "@openzeppelin/contracts/utils/cryptography/signers/SignerERC7702.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579, SignerERC7702 {␊
        constructor() EIP712("MyAccount", "1") {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerERC7702 is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerERC7702)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerERC7702, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerERC7702 with ERC7579 with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerERC7702} from "@openzeppelin/contracts/utils/cryptography/signers/SignerERC7702.sol";␊
    ␊
    contract MyAccount is Account, IERC1271, AccountERC7579, SignerERC7702 {␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerERC7702 is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerERC7702)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerERC7702, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerERC7702 with ERC7579 with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerERC7702} from "@openzeppelin/contracts/utils/cryptography/signers/SignerERC7702.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579, SignerERC7702 {␊
        constructor() EIP712("MyAccount", "1") {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerERC7702 is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerERC7702)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerERC7702, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerERC7702 with ERC7579 hooks non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {AccountERC7579Hooked} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579Hooked.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerERC7702} from "@openzeppelin/contracts/utils/cryptography/signers/SignerERC7702.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579Hooked, SignerERC7702 {␊
        constructor() EIP712("MyAccount", "1") {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerERC7702 is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerERC7702)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerERC7702, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerECDSA named non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerECDSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerECDSA.sol";␊
    ␊
    contract CustomAccountWithSignerECDSA is Account, EIP712, ERC7739, SignerECDSA {␊
        constructor(address signer)␊
            EIP712("CustomAccount with SignerECDSA", "1")␊
            SignerECDSA(signer)␊
        {}␊
    }␊
    `

## Account with SignerECDSA with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {SignerECDSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerECDSA.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC1271 is Account, IERC1271, SignerECDSA {␊
        constructor(address signer) SignerECDSA(signer) {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerECDSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerECDSA.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC7739 is Account, EIP712, ERC7739, SignerECDSA {␊
        constructor(address signer)␊
            EIP712("CustomAccount with SignerECDSAERC7739", "1")␊
            SignerECDSA(signer)␊
        {}␊
    }␊
    `

## Account with SignerECDSA with ERC721Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerECDSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerECDSA.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC721Holder is Account, EIP712, ERC7739, SignerECDSA, ERC721Holder {␊
        constructor(address signer)␊
            EIP712("CustomAccount with SignerECDSAERC721Holder", "1")␊
            SignerECDSA(signer)␊
        {}␊
    }␊
    `

## Account with SignerECDSA with ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerECDSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerECDSA.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC1155Holder is Account, EIP712, ERC7739, SignerECDSA, ERC1155Holder {␊
        constructor(address signer)␊
            EIP712("CustomAccount with SignerECDSAERC1155Holder", "1")␊
            SignerECDSA(signer)␊
        {}␊
    }␊
    `

## Account with SignerECDSA with ERC721Holder and ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerECDSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerECDSA.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC721HolderERC1155Holder is Account, EIP712, ERC7739, SignerECDSA, ERC721Holder, ERC1155Holder {␊
        constructor(address signer)␊
            EIP712("CustomAccount with SignerECDSAERC721HolderERC1155Holder", "1")␊
            SignerECDSA(signer)␊
        {}␊
    }␊
    `

## Account with SignerECDSA with ERC7821 Execution non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {SignerECDSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerECDSA.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, SignerECDSA, ERC7821 {␊
        constructor(address signer) EIP712("MyAccount", "1") SignerECDSA(signer) {}␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerECDSA.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579, SignerECDSA {␊
        constructor(address signer) EIP712("MyAccount", "1") SignerECDSA(signer) {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSA is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerECDSA)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSA, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerECDSA.sol";␊
    ␊
    contract MyAccount is Account, IERC1271, AccountERC7579, SignerECDSA {␊
        constructor(address signer) SignerECDSA(signer) {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSA is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerECDSA)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSA, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerECDSA.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579, SignerECDSA {␊
        constructor(address signer) EIP712("MyAccount", "1") SignerECDSA(signer) {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSA is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerECDSA)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSA, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 hooks non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {AccountERC7579Hooked} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579Hooked.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerECDSA.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579Hooked, SignerECDSA {␊
        constructor(address signer) EIP712("MyAccount", "1") SignerECDSA(signer) {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSA is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerECDSA)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSA, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerECDSA named upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerECDSA is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSA", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerECDSA named upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerECDSA is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSA", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerECDSAFactory {␊
        CustomAccountWithSignerECDSA public immutable implementation = new CustomAccountWithSignerECDSA();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerECDSA.initialize, (signer));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerECDSA.initialize, (signer)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC1271 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC1271 is Initializable, Account, IERC1271, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerECDSA with ERC1271 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC1271 is Initializable, Account, IERC1271, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerECDSAERC1271Factory {␊
        CustomAccountWithSignerECDSAERC1271 public immutable implementation = new CustomAccountWithSignerECDSAERC1271();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerECDSAERC1271.initialize, (signer));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerECDSAERC1271.initialize, (signer)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7739 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC7739 is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSAERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerECDSA with ERC7739 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC7739 is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSAERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerECDSAERC7739Factory {␊
        CustomAccountWithSignerECDSAERC7739 public immutable implementation = new CustomAccountWithSignerECDSAERC7739();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerECDSAERC7739.initialize, (signer));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerECDSAERC7739.initialize, (signer)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC721Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC721Holder is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC721Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSAERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerECDSA with ERC721Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC721Holder is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC721Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSAERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerECDSAERC721HolderFactory {␊
        CustomAccountWithSignerECDSAERC721Holder public immutable implementation = new CustomAccountWithSignerECDSAERC721Holder();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerECDSAERC721Holder.initialize, (signer));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerECDSAERC721Holder.initialize, (signer)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC1155Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSAERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerECDSA with ERC1155Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSAERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerECDSAERC1155HolderFactory {␊
        CustomAccountWithSignerECDSAERC1155Holder public immutable implementation = new CustomAccountWithSignerECDSAERC1155Holder();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerECDSAERC1155Holder.initialize, (signer));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerECDSAERC1155Holder.initialize, (signer)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC721Holder and ERC1155Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC721Holder, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerECDSAERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerECDSA with ERC721Holder and ERC1155Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC721Holder, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerECDSAERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerECDSAERC721HolderERC1155HolderFactory {␊
        CustomAccountWithSignerECDSAERC721HolderERC1155Holder public immutable implementation = new CustomAccountWithSignerECDSAERC721HolderERC1155Holder();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerECDSAERC721HolderERC1155Holder.initialize, (signer));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerECDSAERC721HolderERC1155Holder.initialize, (signer)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7821 Execution upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC7821, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerECDSA with ERC7821 Execution upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC7821, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signer));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signer)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579_init();␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579_init();␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signer));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signer)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 with ERC1271 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579_init();␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 with ERC1271 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579_init();␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signer));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signer)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 with ERC7739 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579_init();␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 with ERC7739 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579_init();␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signer));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signer)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 hooks upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579Hooked_init();␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 hooks upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, SignerECDSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579Hooked_init();␊
            __SignerECDSA_init(signer);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signer));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signer)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerECDSA named upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerECDSA is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSA", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    }␊
    `

## Account with SignerECDSA named upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerECDSA is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSA", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerECDSAFactory {␊
        CustomAccountWithSignerECDSA public immutable implementation = new CustomAccountWithSignerECDSA();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(signer, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerECDSA(instance).initialize(signer);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signer, salt));␊
        }␊
    ␊
        function _salt(address signer, bytes32 salt) internal pure returns (bytes32) {␊
            return keccak256(abi.encode(signer, salt));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC1271 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC1271 is Initializable, Account, IERC1271, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC1271 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC1271 is Initializable, Account, IERC1271, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerECDSAERC1271Factory {␊
        CustomAccountWithSignerECDSAERC1271 public immutable implementation = new CustomAccountWithSignerECDSAERC1271();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(signer, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerECDSAERC1271(instance).initialize(signer);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signer, salt));␊
        }␊
    ␊
        function _salt(address signer, bytes32 salt) internal pure returns (bytes32) {␊
            return keccak256(abi.encode(signer, salt));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7739 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC7739 is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSAERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7739 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC7739 is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSAERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerECDSAERC7739Factory {␊
        CustomAccountWithSignerECDSAERC7739 public immutable implementation = new CustomAccountWithSignerECDSAERC7739();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(signer, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerECDSAERC7739(instance).initialize(signer);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signer, salt));␊
        }␊
    ␊
        function _salt(address signer, bytes32 salt) internal pure returns (bytes32) {␊
            return keccak256(abi.encode(signer, salt));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC721Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC721Holder is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC721Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSAERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC721Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC721Holder is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC721Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSAERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerECDSAERC721HolderFactory {␊
        CustomAccountWithSignerECDSAERC721Holder public immutable implementation = new CustomAccountWithSignerECDSAERC721Holder();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(signer, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerECDSAERC721Holder(instance).initialize(signer);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signer, salt));␊
        }␊
    ␊
        function _salt(address signer, bytes32 salt) internal pure returns (bytes32) {␊
            return keccak256(abi.encode(signer, salt));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC1155Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSAERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC1155Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerECDSAERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerECDSAERC1155HolderFactory {␊
        CustomAccountWithSignerECDSAERC1155Holder public immutable implementation = new CustomAccountWithSignerECDSAERC1155Holder();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(signer, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerECDSAERC1155Holder(instance).initialize(signer);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signer, salt));␊
        }␊
    ␊
        function _salt(address signer, bytes32 salt) internal pure returns (bytes32) {␊
            return keccak256(abi.encode(signer, salt));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC721Holder and ERC1155Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC721Holder, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerECDSAERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC721Holder and ERC1155Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerECDSAERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC721Holder, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerECDSAERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerECDSAERC721HolderERC1155HolderFactory {␊
        CustomAccountWithSignerECDSAERC721HolderERC1155Holder public immutable implementation = new CustomAccountWithSignerECDSAERC721HolderERC1155Holder();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(signer, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerECDSAERC721HolderERC1155Holder(instance).initialize(signer);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signer, salt));␊
        }␊
    ␊
        function _salt(address signer, bytes32 salt) internal pure returns (bytes32) {␊
            return keccak256(abi.encode(signer, salt));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7821 Execution upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC7821 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7821 Execution upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC7821 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __SignerECDSA_init(signer);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(signer, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signer);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signer, salt));␊
        }␊
    ␊
        function _salt(address signer, bytes32 salt) internal pure returns (bytes32) {␊
            return keccak256(abi.encode(signer, salt));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579_init();␊
            __SignerECDSA_init(signer);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579_init();␊
            __SignerECDSA_init(signer);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(signer, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signer);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signer, salt));␊
        }␊
    ␊
        function _salt(address signer, bytes32 salt) internal pure returns (bytes32) {␊
            return keccak256(abi.encode(signer, salt));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 with ERC1271 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579_init();␊
            __SignerECDSA_init(signer);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 with ERC1271 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579_init();␊
            __SignerECDSA_init(signer);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(signer, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signer);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signer, salt));␊
        }␊
    ␊
        function _salt(address signer, bytes32 salt) internal pure returns (bytes32) {␊
            return keccak256(abi.encode(signer, salt));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 with ERC7739 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579_init();␊
            __SignerECDSA_init(signer);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 with ERC7739 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579_init();␊
            __SignerECDSA_init(signer);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(signer, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signer);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signer, salt));␊
        }␊
    ␊
        function _salt(address signer, bytes32 salt) internal pure returns (bytes32) {␊
            return keccak256(abi.encode(signer, salt));␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 hooks upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579Hooked_init();␊
            __SignerECDSA_init(signer);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerECDSA with ERC7579 hooks upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, SignerECDSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(address signer) public initializer {␊
            __AccountERC7579Hooked_init();␊
            __SignerECDSA_init(signer);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerECDSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerECDSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerECDSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(address signer, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(signer, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signer);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(address signer, bytes32 salt) public view returns (address) {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signer, salt));␊
        }␊
    ␊
        function _salt(address signer, bytes32 salt) internal pure returns (bytes32) {␊
            return keccak256(abi.encode(signer, salt));␊
        }␊
    }␊
    `

## Account with SignerP256 named non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerP256} from "@openzeppelin/contracts/utils/cryptography/signers/SignerP256.sol";␊
    ␊
    contract CustomAccountWithSignerP256 is Account, EIP712, ERC7739, SignerP256 {␊
        constructor(bytes32 qx, bytes32 qy)␊
            EIP712("CustomAccount with SignerP256", "1")␊
            SignerP256(qx, qy)␊
        {}␊
    }␊
    `

## Account with SignerP256 with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {SignerP256} from "@openzeppelin/contracts/utils/cryptography/signers/SignerP256.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC1271 is Account, IERC1271, SignerP256 {␊
        constructor(bytes32 qx, bytes32 qy) SignerP256(qx, qy) {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerP256} from "@openzeppelin/contracts/utils/cryptography/signers/SignerP256.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC7739 is Account, EIP712, ERC7739, SignerP256 {␊
        constructor(bytes32 qx, bytes32 qy)␊
            EIP712("CustomAccount with SignerP256ERC7739", "1")␊
            SignerP256(qx, qy)␊
        {}␊
    }␊
    `

## Account with SignerP256 with ERC721Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerP256} from "@openzeppelin/contracts/utils/cryptography/signers/SignerP256.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC721Holder is Account, EIP712, ERC7739, SignerP256, ERC721Holder {␊
        constructor(bytes32 qx, bytes32 qy)␊
            EIP712("CustomAccount with SignerP256ERC721Holder", "1")␊
            SignerP256(qx, qy)␊
        {}␊
    }␊
    `

## Account with SignerP256 with ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerP256} from "@openzeppelin/contracts/utils/cryptography/signers/SignerP256.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC1155Holder is Account, EIP712, ERC7739, SignerP256, ERC1155Holder {␊
        constructor(bytes32 qx, bytes32 qy)␊
            EIP712("CustomAccount with SignerP256ERC1155Holder", "1")␊
            SignerP256(qx, qy)␊
        {}␊
    }␊
    `

## Account with SignerP256 with ERC721Holder and ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerP256} from "@openzeppelin/contracts/utils/cryptography/signers/SignerP256.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC721HolderERC1155Holder is Account, EIP712, ERC7739, SignerP256, ERC721Holder, ERC1155Holder {␊
        constructor(bytes32 qx, bytes32 qy)␊
            EIP712("CustomAccount with SignerP256ERC721HolderERC1155Holder", "1")␊
            SignerP256(qx, qy)␊
        {}␊
    }␊
    `

## Account with SignerP256 with ERC7821 Execution non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {SignerP256} from "@openzeppelin/contracts/utils/cryptography/signers/SignerP256.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, SignerP256, ERC7821 {␊
        constructor(bytes32 qx, bytes32 qy)␊
            EIP712("MyAccount", "1")␊
            SignerP256(qx, qy)␊
        {}␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256} from "@openzeppelin/contracts/utils/cryptography/signers/SignerP256.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579, SignerP256 {␊
        constructor(bytes32 qx, bytes32 qy)␊
            EIP712("MyAccount", "1")␊
            SignerP256(qx, qy)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256 is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerP256)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256} from "@openzeppelin/contracts/utils/cryptography/signers/SignerP256.sol";␊
    ␊
    contract MyAccount is Account, IERC1271, AccountERC7579, SignerP256 {␊
        constructor(bytes32 qx, bytes32 qy) SignerP256(qx, qy) {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256 is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerP256)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256} from "@openzeppelin/contracts/utils/cryptography/signers/SignerP256.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579, SignerP256 {␊
        constructor(bytes32 qx, bytes32 qy)␊
            EIP712("MyAccount", "1")␊
            SignerP256(qx, qy)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256 is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerP256)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 hooks non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {AccountERC7579Hooked} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579Hooked.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256} from "@openzeppelin/contracts/utils/cryptography/signers/SignerP256.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579Hooked, SignerP256 {␊
        constructor(bytes32 qx, bytes32 qy)␊
            EIP712("MyAccount", "1")␊
            SignerP256(qx, qy)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256 is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerP256)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerP256 named upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerP256 is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerP256 named upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerP256 is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerP256Factory {␊
        CustomAccountWithSignerP256 public immutable implementation = new CustomAccountWithSignerP256();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerP256.initialize, (qx, qy));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerP256.initialize, (qx, qy)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC1271 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC1271 is Initializable, Account, IERC1271, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerP256 with ERC1271 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC1271 is Initializable, Account, IERC1271, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerP256ERC1271Factory {␊
        CustomAccountWithSignerP256ERC1271 public immutable implementation = new CustomAccountWithSignerP256ERC1271();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerP256ERC1271.initialize, (qx, qy));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerP256ERC1271.initialize, (qx, qy)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7739 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC7739 is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256ERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerP256 with ERC7739 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC7739 is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256ERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerP256ERC7739Factory {␊
        CustomAccountWithSignerP256ERC7739 public immutable implementation = new CustomAccountWithSignerP256ERC7739();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerP256ERC7739.initialize, (qx, qy));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerP256ERC7739.initialize, (qx, qy)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC721Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC721Holder is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC721Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256ERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerP256 with ERC721Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC721Holder is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC721Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256ERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerP256ERC721HolderFactory {␊
        CustomAccountWithSignerP256ERC721Holder public immutable implementation = new CustomAccountWithSignerP256ERC721Holder();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerP256ERC721Holder.initialize, (qx, qy));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerP256ERC721Holder.initialize, (qx, qy)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC1155Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256ERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerP256 with ERC1155Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256ERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerP256ERC1155HolderFactory {␊
        CustomAccountWithSignerP256ERC1155Holder public immutable implementation = new CustomAccountWithSignerP256ERC1155Holder();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerP256ERC1155Holder.initialize, (qx, qy));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerP256ERC1155Holder.initialize, (qx, qy)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC721Holder and ERC1155Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC721Holder, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerP256ERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerP256 with ERC721Holder and ERC1155Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC721Holder, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerP256ERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerP256ERC721HolderERC1155HolderFactory {␊
        CustomAccountWithSignerP256ERC721HolderERC1155Holder public immutable implementation = new CustomAccountWithSignerP256ERC721HolderERC1155Holder();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerP256ERC721HolderERC1155Holder.initialize, (qx, qy));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerP256ERC721HolderERC1155Holder.initialize, (qx, qy)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7821 Execution upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC7821, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerP256 with ERC7821 Execution upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC7821, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (qx, qy));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (qx, qy)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579_init();␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579_init();␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (qx, qy));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (qx, qy)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 with ERC1271 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579_init();␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 with ERC1271 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579_init();␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (qx, qy));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (qx, qy)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 with ERC7739 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579_init();␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 with ERC7739 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579_init();␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (qx, qy));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (qx, qy)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 hooks upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579Hooked_init();␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 hooks upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, SignerP256Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579Hooked_init();␊
            __SignerP256_init(qx, qy);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (qx, qy));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (qx, qy)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerP256 named upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerP256 is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    }␊
    `

## Account with SignerP256 named upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerP256 is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerP256Factory {␊
        CustomAccountWithSignerP256 public immutable implementation = new CustomAccountWithSignerP256();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(qx, qy, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerP256(instance).initialize(qx, qy);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(qx, qy, salt));␊
        }␊
    ␊
        function _salt(bytes32 qx, bytes32 qy, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(qx, qy, salt));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC1271 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC1271 is Initializable, Account, IERC1271, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC1271 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC1271 is Initializable, Account, IERC1271, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerP256ERC1271Factory {␊
        CustomAccountWithSignerP256ERC1271 public immutable implementation = new CustomAccountWithSignerP256ERC1271();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(qx, qy, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerP256ERC1271(instance).initialize(qx, qy);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(qx, qy, salt));␊
        }␊
    ␊
        function _salt(bytes32 qx, bytes32 qy, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(qx, qy, salt));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7739 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC7739 is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256ERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7739 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC7739 is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256ERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerP256ERC7739Factory {␊
        CustomAccountWithSignerP256ERC7739 public immutable implementation = new CustomAccountWithSignerP256ERC7739();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(qx, qy, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerP256ERC7739(instance).initialize(qx, qy);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(qx, qy, salt));␊
        }␊
    ␊
        function _salt(bytes32 qx, bytes32 qy, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(qx, qy, salt));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC721Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC721Holder is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC721Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256ERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC721Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC721Holder is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC721Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256ERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerP256ERC721HolderFactory {␊
        CustomAccountWithSignerP256ERC721Holder public immutable implementation = new CustomAccountWithSignerP256ERC721Holder();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(qx, qy, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerP256ERC721Holder(instance).initialize(qx, qy);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(qx, qy, salt));␊
        }␊
    ␊
        function _salt(bytes32 qx, bytes32 qy, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(qx, qy, salt));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC1155Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256ERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC1155Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerP256ERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerP256ERC1155HolderFactory {␊
        CustomAccountWithSignerP256ERC1155Holder public immutable implementation = new CustomAccountWithSignerP256ERC1155Holder();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(qx, qy, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerP256ERC1155Holder(instance).initialize(qx, qy);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(qx, qy, salt));␊
        }␊
    ␊
        function _salt(bytes32 qx, bytes32 qy, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(qx, qy, salt));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC721Holder and ERC1155Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC721Holder, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerP256ERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC721Holder and ERC1155Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerP256ERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC721Holder, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerP256ERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerP256ERC721HolderERC1155HolderFactory {␊
        CustomAccountWithSignerP256ERC721HolderERC1155Holder public immutable implementation = new CustomAccountWithSignerP256ERC721HolderERC1155Holder();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(qx, qy, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerP256ERC721HolderERC1155Holder(instance).initialize(qx, qy);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(qx, qy, salt));␊
        }␊
    ␊
        function _salt(bytes32 qx, bytes32 qy, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(qx, qy, salt));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7821 Execution upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC7821 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7821 Execution upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerP256Upgradeable, ERC7821 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __SignerP256_init(qx, qy);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(qx, qy, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(qx, qy);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(qx, qy, salt));␊
        }␊
    ␊
        function _salt(bytes32 qx, bytes32 qy, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(qx, qy, salt));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579_init();␊
            __SignerP256_init(qx, qy);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579_init();␊
            __SignerP256_init(qx, qy);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(qx, qy, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(qx, qy);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(qx, qy, salt));␊
        }␊
    ␊
        function _salt(bytes32 qx, bytes32 qy, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(qx, qy, salt));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 with ERC1271 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579_init();␊
            __SignerP256_init(qx, qy);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 with ERC1271 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579_init();␊
            __SignerP256_init(qx, qy);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(qx, qy, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(qx, qy);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(qx, qy, salt));␊
        }␊
    ␊
        function _salt(bytes32 qx, bytes32 qy, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(qx, qy, salt));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 with ERC7739 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579_init();␊
            __SignerP256_init(qx, qy);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 with ERC7739 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579_init();␊
            __SignerP256_init(qx, qy);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(qx, qy, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(qx, qy);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(qx, qy, salt));␊
        }␊
    ␊
        function _salt(bytes32 qx, bytes32 qy, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(qx, qy, salt));␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 hooks upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579Hooked_init();␊
            __SignerP256_init(qx, qy);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerP256 with ERC7579 hooks upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerP256Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerP256Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, SignerP256Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes32 qx, bytes32 qy) public initializer {␊
            __AccountERC7579Hooked_init();␊
            __SignerP256_init(qx, qy);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerP256Upgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerP256Upgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerP256Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes32 qx, bytes32 qy, bytes32 salt) public returns (address) {␊
                bytes32 effectiveSalt = _salt(qx, qy, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(qx, qy);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes32 qx, bytes32 qy, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(qx, qy, salt));␊
        }␊
    ␊
        function _salt(bytes32 qx, bytes32 qy, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(qx, qy, salt));␊
        }␊
    }␊
    `

## Account with SignerRSA named non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerRSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerRSA.sol";␊
    ␊
    contract CustomAccountWithSignerRSA is Account, EIP712, ERC7739, SignerRSA {␊
        constructor(bytes memory e, bytes memory n)␊
            EIP712("CustomAccount with SignerRSA", "1")␊
            SignerRSA(e, n)␊
        {}␊
    }␊
    `

## Account with SignerRSA with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {SignerRSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerRSA.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC1271 is Account, IERC1271, SignerRSA {␊
        constructor(bytes memory e, bytes memory n) SignerRSA(e, n) {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerRSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerRSA.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC7739 is Account, EIP712, ERC7739, SignerRSA {␊
        constructor(bytes memory e, bytes memory n)␊
            EIP712("CustomAccount with SignerRSAERC7739", "1")␊
            SignerRSA(e, n)␊
        {}␊
    }␊
    `

## Account with SignerRSA with ERC721Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerRSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerRSA.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC721Holder is Account, EIP712, ERC7739, SignerRSA, ERC721Holder {␊
        constructor(bytes memory e, bytes memory n)␊
            EIP712("CustomAccount with SignerRSAERC721Holder", "1")␊
            SignerRSA(e, n)␊
        {}␊
    }␊
    `

## Account with SignerRSA with ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerRSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerRSA.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC1155Holder is Account, EIP712, ERC7739, SignerRSA, ERC1155Holder {␊
        constructor(bytes memory e, bytes memory n)␊
            EIP712("CustomAccount with SignerRSAERC1155Holder", "1")␊
            SignerRSA(e, n)␊
        {}␊
    }␊
    `

## Account with SignerRSA with ERC721Holder and ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {SignerRSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerRSA.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC721HolderERC1155Holder is Account, EIP712, ERC7739, SignerRSA, ERC721Holder, ERC1155Holder {␊
        constructor(bytes memory e, bytes memory n)␊
            EIP712("CustomAccount with SignerRSAERC721HolderERC1155Holder", "1")␊
            SignerRSA(e, n)␊
        {}␊
    }␊
    `

## Account with SignerRSA with ERC7821 Execution non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {SignerRSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerRSA.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, SignerRSA, ERC7821 {␊
        constructor(bytes memory e, bytes memory n)␊
            EIP712("MyAccount", "1")␊
            SignerRSA(e, n)␊
        {}␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerRSA.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579, SignerRSA {␊
        constructor(bytes memory e, bytes memory n)␊
            EIP712("MyAccount", "1")␊
            SignerRSA(e, n)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSA is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerRSA)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSA, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerRSA.sol";␊
    ␊
    contract MyAccount is Account, IERC1271, AccountERC7579, SignerRSA {␊
        constructor(bytes memory e, bytes memory n) SignerRSA(e, n) {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSA is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerRSA)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSA, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerRSA.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579, SignerRSA {␊
        constructor(bytes memory e, bytes memory n)␊
            EIP712("MyAccount", "1")␊
            SignerRSA(e, n)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSA is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerRSA)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSA, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 hooks non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {AccountERC7579Hooked} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579Hooked.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerRSA.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579Hooked, SignerRSA {␊
        constructor(bytes memory e, bytes memory n)␊
            EIP712("MyAccount", "1")␊
            SignerRSA(e, n)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSA is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerRSA)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSA, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerRSA named upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerRSA is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSA", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerRSA named upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerRSA is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSA", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerRSAFactory {␊
        CustomAccountWithSignerRSA public immutable implementation = new CustomAccountWithSignerRSA();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerRSA.initialize, (e, n));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerRSA.initialize, (e, n)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC1271 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC1271 is Initializable, Account, IERC1271, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerRSA with ERC1271 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC1271 is Initializable, Account, IERC1271, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerRSAERC1271Factory {␊
        CustomAccountWithSignerRSAERC1271 public immutable implementation = new CustomAccountWithSignerRSAERC1271();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerRSAERC1271.initialize, (e, n));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerRSAERC1271.initialize, (e, n)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7739 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC7739 is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSAERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerRSA with ERC7739 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC7739 is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSAERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerRSAERC7739Factory {␊
        CustomAccountWithSignerRSAERC7739 public immutable implementation = new CustomAccountWithSignerRSAERC7739();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerRSAERC7739.initialize, (e, n));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerRSAERC7739.initialize, (e, n)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC721Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC721Holder is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC721Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSAERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerRSA with ERC721Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC721Holder is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC721Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSAERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerRSAERC721HolderFactory {␊
        CustomAccountWithSignerRSAERC721Holder public immutable implementation = new CustomAccountWithSignerRSAERC721Holder();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerRSAERC721Holder.initialize, (e, n));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerRSAERC721Holder.initialize, (e, n)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC1155Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSAERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerRSA with ERC1155Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSAERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerRSAERC1155HolderFactory {␊
        CustomAccountWithSignerRSAERC1155Holder public immutable implementation = new CustomAccountWithSignerRSAERC1155Holder();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerRSAERC1155Holder.initialize, (e, n));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerRSAERC1155Holder.initialize, (e, n)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC721Holder and ERC1155Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC721Holder, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerRSAERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerRSA with ERC721Holder and ERC1155Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC721Holder, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerRSAERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerRSAERC721HolderERC1155HolderFactory {␊
        CustomAccountWithSignerRSAERC721HolderERC1155Holder public immutable implementation = new CustomAccountWithSignerRSAERC721HolderERC1155Holder();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerRSAERC721HolderERC1155Holder.initialize, (e, n));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerRSAERC721HolderERC1155Holder.initialize, (e, n)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7821 Execution upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC7821, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerRSA with ERC7821 Execution upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC7821, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (e, n));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (e, n)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579_init();␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579_init();␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (e, n));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (e, n)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 with ERC1271 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579_init();␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 with ERC1271 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579_init();␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (e, n));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (e, n)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 with ERC7739 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579_init();␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 with ERC7739 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579_init();␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (e, n));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (e, n)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 hooks upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579Hooked_init();␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 hooks upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, SignerRSAUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579Hooked_init();␊
            __SignerRSA_init(e, n);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (e, n));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (e, n)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerRSA named upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerRSA is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSA", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    }␊
    `

## Account with SignerRSA named upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerRSA is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSA", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerRSAFactory {␊
        CustomAccountWithSignerRSA public immutable implementation = new CustomAccountWithSignerRSA();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(e, n, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerRSA(instance).initialize(e, n);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(e, n, salt));␊
        }␊
    ␊
        function _salt(bytes memory e, bytes memory n, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(e, n, salt));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC1271 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC1271 is Initializable, Account, IERC1271, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC1271 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC1271 is Initializable, Account, IERC1271, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerRSAERC1271Factory {␊
        CustomAccountWithSignerRSAERC1271 public immutable implementation = new CustomAccountWithSignerRSAERC1271();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(e, n, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerRSAERC1271(instance).initialize(e, n);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(e, n, salt));␊
        }␊
    ␊
        function _salt(bytes memory e, bytes memory n, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(e, n, salt));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7739 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC7739 is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSAERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7739 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC7739 is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSAERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerRSAERC7739Factory {␊
        CustomAccountWithSignerRSAERC7739 public immutable implementation = new CustomAccountWithSignerRSAERC7739();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(e, n, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerRSAERC7739(instance).initialize(e, n);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(e, n, salt));␊
        }␊
    ␊
        function _salt(bytes memory e, bytes memory n, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(e, n, salt));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC721Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC721Holder is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC721Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSAERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC721Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC721Holder is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC721Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSAERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerRSAERC721HolderFactory {␊
        CustomAccountWithSignerRSAERC721Holder public immutable implementation = new CustomAccountWithSignerRSAERC721Holder();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(e, n, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerRSAERC721Holder(instance).initialize(e, n);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(e, n, salt));␊
        }␊
    ␊
        function _salt(bytes memory e, bytes memory n, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(e, n, salt));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC1155Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSAERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC1155Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerRSAERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerRSAERC1155HolderFactory {␊
        CustomAccountWithSignerRSAERC1155Holder public immutable implementation = new CustomAccountWithSignerRSAERC1155Holder();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(e, n, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerRSAERC1155Holder(instance).initialize(e, n);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(e, n, salt));␊
        }␊
    ␊
        function _salt(bytes memory e, bytes memory n, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(e, n, salt));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC721Holder and ERC1155Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC721Holder, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerRSAERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC721Holder and ERC1155Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerRSAERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC721Holder, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerRSAERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerRSAERC721HolderERC1155HolderFactory {␊
        CustomAccountWithSignerRSAERC721HolderERC1155Holder public immutable implementation = new CustomAccountWithSignerRSAERC721HolderERC1155Holder();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(e, n, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerRSAERC721HolderERC1155Holder(instance).initialize(e, n);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(e, n, salt));␊
        }␊
    ␊
        function _salt(bytes memory e, bytes memory n, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(e, n, salt));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7821 Execution upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC7821 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7821 Execution upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerRSAUpgradeable, ERC7821 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __SignerRSA_init(e, n);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(e, n, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(e, n);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(e, n, salt));␊
        }␊
    ␊
        function _salt(bytes memory e, bytes memory n, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(e, n, salt));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579_init();␊
            __SignerRSA_init(e, n);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579_init();␊
            __SignerRSA_init(e, n);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(e, n, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(e, n);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(e, n, salt));␊
        }␊
    ␊
        function _salt(bytes memory e, bytes memory n, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(e, n, salt));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 with ERC1271 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579_init();␊
            __SignerRSA_init(e, n);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 with ERC1271 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579_init();␊
            __SignerRSA_init(e, n);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(e, n, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(e, n);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(e, n, salt));␊
        }␊
    ␊
        function _salt(bytes memory e, bytes memory n, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(e, n, salt));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 with ERC7739 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579_init();␊
            __SignerRSA_init(e, n);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 with ERC7739 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579_init();␊
            __SignerRSA_init(e, n);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(e, n, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(e, n);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(e, n, salt));␊
        }␊
    ␊
        function _salt(bytes memory e, bytes memory n, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(e, n, salt));␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 hooks upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579Hooked_init();␊
            __SignerRSA_init(e, n);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerRSA with ERC7579 hooks upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {SignerRSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerRSAUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, SignerRSAUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes memory e, bytes memory n) public initializer {␊
            __AccountERC7579Hooked_init();␊
            __SignerRSA_init(e, n);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerRSAUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerRSAUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(SignerRSAUpgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(e, n, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(e, n);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes memory e, bytes memory n, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(e, n, salt));␊
        }␊
    ␊
        function _salt(bytes memory e, bytes memory n, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(e, n, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisig named non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    ␊
    contract CustomAccountWithSignerMultisig is Account, EIP712, ERC7739, MultiSignerERC7913 {␊
        constructor(bytes[] memory signers, uint64 threshold)␊
            EIP712("CustomAccount with SignerMultisig", "1")␊
            MultiSignerERC7913(signers, threshold)␊
        {}␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC1271 is Account, IERC1271, MultiSignerERC7913 {␊
        constructor(bytes[] memory signers, uint64 threshold)␊
            MultiSignerERC7913(signers, threshold)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC7739 is Account, EIP712, ERC7739, MultiSignerERC7913 {␊
        constructor(bytes[] memory signers, uint64 threshold)␊
            EIP712("CustomAccount with SignerMultisigERC7739", "1")␊
            MultiSignerERC7913(signers, threshold)␊
        {}␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC721Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC721Holder is Account, EIP712, ERC7739, MultiSignerERC7913, ERC721Holder {␊
        constructor(bytes[] memory signers, uint64 threshold)␊
            EIP712("CustomAccount with SignerMultisigERC721Holder", "1")␊
            MultiSignerERC7913(signers, threshold)␊
        {}␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC1155Holder is Account, EIP712, ERC7739, MultiSignerERC7913, ERC1155Holder {␊
        constructor(bytes[] memory signers, uint64 threshold)␊
            EIP712("CustomAccount with SignerMultisigERC1155Holder", "1")␊
            MultiSignerERC7913(signers, threshold)␊
        {}␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC721Holder and ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC721HolderERC1155Holder is Account, EIP712, ERC7739, MultiSignerERC7913, ERC721Holder, ERC1155Holder {␊
        constructor(bytes[] memory signers, uint64 threshold)␊
            EIP712("CustomAccount with SignerMultisigERC721HolderERC1155Holder", "1")␊
            MultiSignerERC7913(signers, threshold)␊
        {}␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7821 Execution non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, MultiSignerERC7913, ERC7821 {␊
        constructor(bytes[] memory signers, uint64 threshold)␊
            EIP712("MyAccount", "1")␊
            MultiSignerERC7913(signers, threshold)␊
        {}␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579, MultiSignerERC7913 {␊
        constructor(bytes[] memory signers, uint64 threshold)␊
            EIP712("MyAccount", "1")␊
            MultiSignerERC7913(signers, threshold)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisig is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerMultisig)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Account, IERC1271, AccountERC7579, MultiSignerERC7913 {␊
        constructor(bytes[] memory signers, uint64 threshold)␊
            MultiSignerERC7913(signers, threshold)␊
        {}␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisig is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerMultisig)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579, MultiSignerERC7913 {␊
        constructor(bytes[] memory signers, uint64 threshold)␊
            EIP712("MyAccount", "1")␊
            MultiSignerERC7913(signers, threshold)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisig is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerMultisig)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 hooks non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {AccountERC7579Hooked} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579Hooked.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579Hooked, MultiSignerERC7913 {␊
        constructor(bytes[] memory signers, uint64 threshold)␊
            EIP712("MyAccount", "1")␊
            MultiSignerERC7913(signers, threshold)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisig is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerMultisig)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisig named upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisig is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisig", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisig named upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerMultisig is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisig", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigFactory {␊
        CustomAccountWithSignerMultisig public immutable implementation = new CustomAccountWithSignerMultisig();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerMultisig.initialize, (signers, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerMultisig.initialize, (signers, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC1271 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC1271 is Initializable, Account, IERC1271, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisig with ERC1271 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC1271 is Initializable, Account, IERC1271, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigERC1271Factory {␊
        CustomAccountWithSignerMultisigERC1271 public immutable implementation = new CustomAccountWithSignerMultisigERC1271();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerMultisigERC1271.initialize, (signers, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerMultisigERC1271.initialize, (signers, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7739 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC7739 is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisig with ERC7739 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC7739 is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigERC7739Factory {␊
        CustomAccountWithSignerMultisigERC7739 public immutable implementation = new CustomAccountWithSignerMultisigERC7739();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerMultisigERC7739.initialize, (signers, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerMultisigERC7739.initialize, (signers, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC721Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC721Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC721Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisig with ERC721Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC721Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC721Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigERC721HolderFactory {␊
        CustomAccountWithSignerMultisigERC721Holder public immutable implementation = new CustomAccountWithSignerMultisigERC721Holder();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerMultisigERC721Holder.initialize, (signers, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerMultisigERC721Holder.initialize, (signers, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC1155Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisig with ERC1155Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigERC1155HolderFactory {␊
        CustomAccountWithSignerMultisigERC1155Holder public immutable implementation = new CustomAccountWithSignerMultisigERC1155Holder();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerMultisigERC1155Holder.initialize, (signers, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerMultisigERC1155Holder.initialize, (signers, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC721Holder and ERC1155Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC721Holder, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisig with ERC721Holder and ERC1155Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC721Holder, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigERC721HolderERC1155HolderFactory {␊
        CustomAccountWithSignerMultisigERC721HolderERC1155Holder public immutable implementation = new CustomAccountWithSignerMultisigERC721HolderERC1155Holder();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerMultisigERC721HolderERC1155Holder.initialize, (signers, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerMultisigERC721HolderERC1155Holder.initialize, (signers, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7821 Execution upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC7821, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisig with ERC7821 Execution upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC7821, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signers, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signers, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signers, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signers, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 with ERC1271 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 with ERC1271 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signers, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signers, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 with ERC7739 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 with ERC7739 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signers, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signers, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 hooks upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579Hooked_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 hooks upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, MultiSignerERC7913Upgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579Hooked_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signers, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signers, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisig named upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisig is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisig", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisig named upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerMultisig is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisig", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigFactory {␊
        CustomAccountWithSignerMultisig public immutable implementation = new CustomAccountWithSignerMultisig();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerMultisig(instance).initialize(signers, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC1271 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC1271 is Initializable, Account, IERC1271, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC1271 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC1271 is Initializable, Account, IERC1271, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigERC1271Factory {␊
        CustomAccountWithSignerMultisigERC1271 public immutable implementation = new CustomAccountWithSignerMultisigERC1271();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerMultisigERC1271(instance).initialize(signers, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7739 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC7739 is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7739 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC7739 is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigERC7739", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigERC7739Factory {␊
        CustomAccountWithSignerMultisigERC7739 public immutable implementation = new CustomAccountWithSignerMultisigERC7739();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerMultisigERC7739(instance).initialize(signers, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC721Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC721Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC721Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC721Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC721Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC721Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigERC721Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigERC721HolderFactory {␊
        CustomAccountWithSignerMultisigERC721Holder public immutable implementation = new CustomAccountWithSignerMultisigERC721Holder();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerMultisigERC721Holder(instance).initialize(signers, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC1155Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC1155Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigERC1155Holder", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigERC1155HolderFactory {␊
        CustomAccountWithSignerMultisigERC1155Holder public immutable implementation = new CustomAccountWithSignerMultisigERC1155Holder();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerMultisigERC1155Holder(instance).initialize(signers, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC721Holder and ERC1155Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC721Holder, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC721Holder and ERC1155Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC721Holder, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigERC721HolderERC1155HolderFactory {␊
        CustomAccountWithSignerMultisigERC721HolderERC1155Holder public immutable implementation = new CustomAccountWithSignerMultisigERC721HolderERC1155Holder();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerMultisigERC721HolderERC1155Holder(instance).initialize(signers, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7821 Execution upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC7821 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7821 Execution upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913Upgradeable, ERC7821 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signers, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signers, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 with ERC1271 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 with ERC1271 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signers, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 with ERC7739 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 with ERC7739 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signers, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 hooks upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579Hooked_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisig with ERC7579 hooks upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, MultiSignerERC7913Upgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579Hooked_init();␊
            __MultiSignerERC7913_init(signers, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signers, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted named non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913Weighted} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913Weighted.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeighted is Account, EIP712, ERC7739, MultiSignerERC7913Weighted {␊
        constructor(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            EIP712("CustomAccount with SignerMultisigWeighted", "1")␊
            MultiSignerERC7913Weighted(signers, weights, threshold)␊
        {}␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {MultiSignerERC7913Weighted} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913Weighted.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1271 is Account, IERC1271, MultiSignerERC7913Weighted {␊
        constructor(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            MultiSignerERC7913Weighted(signers, weights, threshold)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913Weighted} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913Weighted.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC7739 is Account, EIP712, ERC7739, MultiSignerERC7913Weighted {␊
        constructor(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            EIP712("CustomAccount with SignerMultisigWeightedERC7739", "1")␊
            MultiSignerERC7913Weighted(signers, weights, threshold)␊
        {}␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC721Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913Weighted} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913Weighted.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721Holder is Account, EIP712, ERC7739, MultiSignerERC7913Weighted, ERC721Holder {␊
        constructor(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            EIP712("CustomAccount with SignerMultisigWeightedERC721Holder", "1")␊
            MultiSignerERC7913Weighted(signers, weights, threshold)␊
        {}␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913Weighted} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913Weighted.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1155Holder is Account, EIP712, ERC7739, MultiSignerERC7913Weighted, ERC1155Holder {␊
        constructor(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            EIP712("CustomAccount with SignerMultisigWeightedERC1155Holder", "1")␊
            MultiSignerERC7913Weighted(signers, weights, threshold)␊
        {}␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC721Holder and ERC1155Holder non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913Weighted} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913Weighted.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721HolderERC1155Holder is Account, EIP712, ERC7739, MultiSignerERC7913Weighted, ERC721Holder, ERC1155Holder {␊
        constructor(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            EIP712("CustomAccount with SignerMultisigWeightedERC721HolderERC1155Holder", "1")␊
            MultiSignerERC7913Weighted(signers, weights, threshold)␊
        {}␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7821 Execution non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {MultiSignerERC7913Weighted} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913Weighted.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, MultiSignerERC7913Weighted, ERC7821 {␊
        constructor(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            EIP712("MyAccount", "1")␊
            MultiSignerERC7913Weighted(signers, weights, threshold)␊
        {}␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    import {MultiSignerERC7913Weighted} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913Weighted.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579, MultiSignerERC7913Weighted {␊
        constructor(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            EIP712("MyAccount", "1")␊
            MultiSignerERC7913Weighted(signers, weights, threshold)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeighted is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerMultisigWeighted)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 with ERC1271 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    import {MultiSignerERC7913Weighted} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913Weighted.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Account, IERC1271, AccountERC7579, MultiSignerERC7913Weighted {␊
        constructor(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            MultiSignerERC7913Weighted(signers, weights, threshold)␊
        {}␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeighted is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerMultisigWeighted)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 with ERC7739 non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    import {MultiSignerERC7913Weighted} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913Weighted.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579, MultiSignerERC7913Weighted {␊
        constructor(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            EIP712("MyAccount", "1")␊
            MultiSignerERC7913Weighted(signers, weights, threshold)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeighted is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerMultisigWeighted)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 hooks non-upgradeable

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579.sol";␊
    import {AccountERC7579Hooked} from "@openzeppelin/contracts/account/extensions/draft-AccountERC7579Hooked.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {MultiSignerERC7913} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913.sol";␊
    import {MultiSignerERC7913Weighted} from "@openzeppelin/contracts/utils/cryptography/signers/MultiSignerERC7913Weighted.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Account, EIP712, ERC7739, AccountERC7579Hooked, MultiSignerERC7913Weighted {␊
        constructor(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            EIP712("MyAccount", "1")␊
            MultiSignerERC7913Weighted(signers, weights, threshold)␊
        {}␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeighted is most derived than AccountERC7579␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579, ..., SignerMultisigWeighted)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579 returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913, AbstractSigner, AccountERC7579)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted named upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeighted is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigWeighted", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisigWeighted named upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeighted is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigWeighted", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedFactory {␊
        CustomAccountWithSignerMultisigWeighted public immutable implementation = new CustomAccountWithSignerMultisigWeighted();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerMultisigWeighted.initialize, (signers, weights, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerMultisigWeighted.initialize, (signers, weights, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC1271 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1271 is Initializable, Account, IERC1271, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC1271 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1271 is Initializable, Account, IERC1271, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1271Factory {␊
        CustomAccountWithSignerMultisigWeightedERC1271 public immutable implementation = new CustomAccountWithSignerMultisigWeightedERC1271();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerMultisigWeightedERC1271.initialize, (signers, weights, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerMultisigWeightedERC1271.initialize, (signers, weights, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7739 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC7739 is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC7739", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7739 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC7739 is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC7739", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC7739Factory {␊
        CustomAccountWithSignerMultisigWeightedERC7739 public immutable implementation = new CustomAccountWithSignerMultisigWeightedERC7739();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerMultisigWeightedERC7739.initialize, (signers, weights, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerMultisigWeightedERC7739.initialize, (signers, weights, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC721Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC721Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC721Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC721Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC721Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC721Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721HolderFactory {␊
        CustomAccountWithSignerMultisigWeightedERC721Holder public immutable implementation = new CustomAccountWithSignerMultisigWeightedERC721Holder();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerMultisigWeightedERC721Holder.initialize, (signers, weights, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerMultisigWeightedERC721Holder.initialize, (signers, weights, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC1155Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC1155Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1155HolderFactory {␊
        CustomAccountWithSignerMultisigWeightedERC1155Holder public immutable implementation = new CustomAccountWithSignerMultisigWeightedERC1155Holder();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerMultisigWeightedERC1155Holder.initialize, (signers, weights, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerMultisigWeightedERC1155Holder.initialize, (signers, weights, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC721Holder and ERC1155Holder upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC721Holder, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC721Holder and ERC1155Holder upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC721Holder, ERC1155Holder, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721HolderERC1155HolderFactory {␊
        CustomAccountWithSignerMultisigWeightedERC721HolderERC1155Holder public immutable implementation = new CustomAccountWithSignerMultisigWeightedERC721HolderERC1155Holder();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(CustomAccountWithSignerMultisigWeightedERC721HolderERC1155Holder.initialize, (signers, weights, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(CustomAccountWithSignerMultisigWeightedERC721HolderERC1155Holder.initialize, (signers, weights, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7821 Execution upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC7821, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7821 Execution upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC7821, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signers, weights, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signers, weights, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signers, weights, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signers, weights, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 with ERC1271 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 with ERC1271 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signers, weights, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signers, weights, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 with ERC7739 upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 with ERC7739 upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signers, weights, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signers, weights, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 hooks upgradeable uups

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579Hooked_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 hooks upgradeable uups with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
    import {Create2} from "@openzeppelin/contracts/utils/Create2.sol";␊
    import {ERC1967Proxy} from "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, MultiSignerERC7913WeightedUpgradeable, UUPSUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579Hooked_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
            __UUPSUpgradeable_init();␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _authorizeUpgrade(address newImplementation)␊
            internal␊
            override␊
            onlyEntryPointOrSelf␊
        {}␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes memory initcall = abi.encodeCall(MyAccount.initialize, (signers, weights, threshold));␊
                address instance = _predict(salt, initcall);␊
                if (instance.code.length == 0) {␊
                    new ERC1967Proxy{salt: salt}(address(implementation), initcall);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return _predict(salt, abi.encodeCall(MyAccount.initialize, (signers, weights, threshold)));␊
        }␊
    ␊
        function _predict(bytes32 salt, bytes memory initcall)␊
            internal␊
            view␊
            returns (address)␊
        {␊
            return Create2.computeAddress(salt, keccak256(bytes.concat(type(ERC1967Proxy).creationCode, abi.encode(implementation, initcall))));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted named upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeighted is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigWeighted", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted named upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeighted is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("CustomAccount with SignerMultisigWeighted", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedFactory {␊
        CustomAccountWithSignerMultisigWeighted public immutable implementation = new CustomAccountWithSignerMultisigWeighted();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, weights, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerMultisigWeighted(instance).initialize(signers, weights, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, weights, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, weights, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC1271 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1271 is Initializable, Account, IERC1271, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC1271 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1271 is Initializable, Account, IERC1271, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override␊
            returns (bytes4)␊
        {␊
            return _rawSignatureValidation(hash, signature) ? IERC1271.isValidSignature.selector : bytes4(0xffffffff);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1271Factory {␊
        CustomAccountWithSignerMultisigWeightedERC1271 public immutable implementation = new CustomAccountWithSignerMultisigWeightedERC1271();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, weights, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerMultisigWeightedERC1271(instance).initialize(signers, weights, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, weights, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, weights, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7739 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC7739 is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC7739", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7739 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC7739 is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC7739", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC7739Factory {␊
        CustomAccountWithSignerMultisigWeightedERC7739 public immutable implementation = new CustomAccountWithSignerMultisigWeightedERC7739();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, weights, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerMultisigWeightedERC7739(instance).initialize(signers, weights, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, weights, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, weights, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC721Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC721Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC721Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC721Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC721Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC721Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721HolderFactory {␊
        CustomAccountWithSignerMultisigWeightedERC721Holder public immutable implementation = new CustomAccountWithSignerMultisigWeightedERC721Holder();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, weights, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerMultisigWeightedERC721Holder(instance).initialize(signers, weights, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, weights, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, weights, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC1155Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC1155Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC1155HolderFactory {␊
        CustomAccountWithSignerMultisigWeightedERC1155Holder public immutable implementation = new CustomAccountWithSignerMultisigWeightedERC1155Holder();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, weights, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerMultisigWeightedERC1155Holder(instance).initialize(signers, weights, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, weights, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, weights, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC721Holder and ERC1155Holder upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC721Holder, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC721Holder and ERC1155Holder upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
    import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721HolderERC1155Holder is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC721Holder, ERC1155Holder {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor()␊
            EIP712("CustomAccount with SignerMultisigWeightedERC721HolderERC1155Holder", "1")␊
        {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    }␊
    ␊
    contract CustomAccountWithSignerMultisigWeightedERC721HolderERC1155HolderFactory {␊
        CustomAccountWithSignerMultisigWeightedERC721HolderERC1155Holder public immutable implementation = new CustomAccountWithSignerMultisigWeightedERC721HolderERC1155Holder();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, weights, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    CustomAccountWithSignerMultisigWeightedERC721HolderERC1155Holder(instance).initialize(signers, weights, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, weights, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, weights, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7821 Execution upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC7821 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7821 Execution upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {ERC7821} from "@openzeppelin/contracts/account/extensions/draft-ERC7821.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, MultiSignerERC7913WeightedUpgradeable, ERC7821 {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        function _erc7821AuthorizedExecutor(address caller, bytes32 mode, bytes calldata executionData)␊
            internal␊
            view␊
            override␊
            returns (bool)␊
        {␊
            return caller == address(entryPoint()) || super._erc7821AuthorizedExecutor(caller, mode, executionData);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, weights, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signers, weights, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, weights, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, weights, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, weights, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signers, weights, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, weights, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, weights, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 with ERC1271 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 with ERC1271 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {IERC1271} from "@openzeppelin/contracts/interfaces/IERC1271.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, IERC1271, AccountERC7579Upgradeable, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(IERC1271, AccountERC7579Upgradeable)␊
            returns (bytes4)␊
        {␊
            return super.isValidSignature(hash, signature);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, weights, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signers, weights, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, weights, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, weights, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 with ERC7739 upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 with ERC7739 upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579Upgradeable, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, weights, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signers, weights, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, weights, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, weights, threshold, salt));␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 hooks upgradeable transparent

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579Hooked_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    `

## Account with SignerMultisigWeighted with ERC7579 hooks upgradeable transparent with factory

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Contracts ^5.4.0␊
    pragma solidity ^0.8.27;␊
    ␊
    import {AbstractSigner} from "@openzeppelin/contracts/utils/cryptography/signers/AbstractSigner.sol";␊
    import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
    import {AccountERC7579Upgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579Upgradeable.sol";␊
    import {AccountERC7579HookedUpgradeable} from "@openzeppelin/contracts-upgradeable/account/extensions/draft-AccountERC7579HookedUpgradeable.sol";␊
    import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
    import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
    import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
    import {MultiSignerERC7913Upgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913Upgradeable.sol";␊
    import {MultiSignerERC7913WeightedUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/MultiSignerERC7913WeightedUpgradeable.sol";␊
    import {PackedUserOperation} from "@openzeppelin/contracts/interfaces/draft-IERC4337.sol";␊
    import {Clones} from "@openzeppelin/contracts/proxy/Clones.sol";␊
    ␊
    contract MyAccount is Initializable, Account, EIP712, ERC7739, AccountERC7579HookedUpgradeable, MultiSignerERC7913WeightedUpgradeable {␊
        /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
        constructor() EIP712("MyAccount", "1") {␊
            _disableInitializers();␊
        }␊
    ␊
        function initialize(bytes[] memory signers, uint64[] memory weights, uint64 threshold)␊
            public␊
            initializer␊
        {␊
            __AccountERC7579Hooked_init();␊
            __MultiSignerERC7913Weighted_init(signers, weights, threshold);␊
        }␊
    ␊
        function isValidSignature(bytes32 hash, bytes calldata signature)␊
            public␊
            view␊
            override(AccountERC7579Upgradeable, ERC7739)␊
            returns (bytes4)␊
        {␊
            // ERC-7739 can return the ERC-1271 magic value, 0xffffffff (invalid) or 0x77390001 (detection).␊
            // If the returned value is 0xffffffff, fallback to ERC-7579 validation.␊
            bytes4 erc7739magic = ERC7739.isValidSignature(hash, signature);␊
            return erc7739magic == bytes4(0xffffffff) ? AccountERC7579Upgradeable.isValidSignature(hash, signature) : erc7739magic;␊
        }␊
    ␊
        function setSignerWeights(bytes[] memory signers, uint64[] memory weights)␊
            public␊
            onlyEntryPointOrSelf␊
        {␊
            _setSignerWeights(signers, weights);␊
        }␊
    ␊
        function addSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _addSigners(signers);␊
        }␊
    ␊
        function removeSigners(bytes[] memory signers) public onlyEntryPointOrSelf {␊
            _removeSigners(signers);␊
        }␊
    ␊
        function setThreshold(uint64 threshold) public onlyEntryPointOrSelf {␊
            _setThreshold(threshold);␊
        }␊
    ␊
        // The following functions are overrides required by Solidity.␊
    ␊
        function _validateUserOp(PackedUserOperation calldata userOp, bytes32 userOpHash)␊
            internal␊
            override(Account, AccountERC7579Upgradeable)␊
            returns (uint256)␊
        {␊
            return super._validateUserOp(userOp, userOpHash);␊
        }␊
    ␊
        // IMPORTANT: Make sure SignerMultisigWeightedUpgradeable is most derived than AccountERC7579Upgradeable␊
        // in the inheritance chain (i.e. contract ... is AccountERC7579Upgradeable, ..., SignerMultisigWeightedUpgradeable)␊
        // to ensure the correct order of function resolution.␊
        // AccountERC7579Upgradeable returns false for _rawSignatureValidation␊
        function _rawSignatureValidation(bytes32 hash, bytes calldata signature)␊
            internal␊
            view␊
            override(MultiSignerERC7913Upgradeable, AbstractSigner, AccountERC7579Upgradeable)␊
            returns (bool)␊
        {␊
            return super._rawSignatureValidation(hash, signature);␊
        }␊
    }␊
    ␊
    contract MyAccountFactory {␊
        MyAccount public immutable implementation = new MyAccount();␊
    ␊
        function deploy(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            returns (address)␊
        {␊
                bytes32 effectiveSalt = _salt(signers, weights, threshold, salt);␊
                address instance = Clones.predictDeterministicAddress(address(implementation), effectiveSalt);␊
                if (instance.code.length == 0) {␊
                    Clones.cloneDeterministic(address(implementation), effectiveSalt);␊
                    MyAccount(instance).initialize(signers, weights, threshold);␊
                }␊
                return instance;␊
            ␊
        }␊
    ␊
        function predict(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            public␊
            view␊
            returns (address)␊
        {␊
            return Clones.predictDeterministicAddress(address(implementation), _salt(signers, weights, threshold, salt));␊
        }␊
    ␊
        function _salt(bytes[] memory signers, uint64[] memory weights, uint64 threshold, bytes32 salt)␊
            internal␊
            pure␊
            returns (bytes32)␊
        {␊
            return keccak256(abi.encode(signers, weights, threshold, salt));␊
        }␊
    }␊
    `
