# Snapshot report for `src/zip-hardhat.test.ts`

The actual snapshot is saved in `zip-hardhat.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## erc20 full

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Contracts ^5.4.0␊
      pragma solidity ^0.8.27;␊
      ␊
      import {AccessControl} from "@openzeppelin/contracts/access/AccessControl.sol";␊
      import {ERC20} from "@openzeppelin/contracts/token/ERC20/ERC20.sol";␊
      import {ERC20Burnable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Burnable.sol";␊
      import {ERC20FlashMint} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20FlashMint.sol";␊
      import {ERC20Pausable} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Pausable.sol";␊
      import {ERC20Permit} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Permit.sol";␊
      import {ERC20Votes} from "@openzeppelin/contracts/token/ERC20/extensions/ERC20Votes.sol";␊
      import {Nonces} from "@openzeppelin/contracts/utils/Nonces.sol";␊
      ␊
      contract MyToken is ERC20, ERC20Burnable, ERC20Pausable, AccessControl, ERC20Permit, ERC20Votes, ERC20FlashMint {␊
          bytes32 public constant PAUSER_ROLE = keccak256("PAUSER_ROLE");␊
          bytes32 public constant MINTER_ROLE = keccak256("MINTER_ROLE");␊
      ␊
          constructor(address recipient, address defaultAdmin, address pauser, address minter)␊
              ERC20("My Token", "MTK")␊
              ERC20Permit("My Token")␊
          {␊
              _mint(recipient, 2000 * 10 ** decimals());␊
              _grantRole(DEFAULT_ADMIN_ROLE, defaultAdmin);␊
              _grantRole(PAUSER_ROLE, pauser);␊
              _grantRole(MINTER_ROLE, minter);␊
          }␊
      ␊
          function pause() public onlyRole(PAUSER_ROLE) {␊
              _pause();␊
          }␊
      ␊
          function unpause() public onlyRole(PAUSER_ROLE) {␊
              _unpause();␊
          }␊
      ␊
          function mint(address to, uint256 amount) public onlyRole(MINTER_ROLE) {␊
              _mint(to, amount);␊
          }␊
      ␊
          // The following functions are overrides required by Solidity.␊
      ␊
          function _update(address from, address to, uint256 value)␊
              internal␊
              override(ERC20, ERC20Pausable, ERC20Votes)␊
          {␊
              super._update(from, to, value);␊
          }␊
      ␊
          function nonces(address owner)␊
              public␊
              view␊
              override(ERC20Permit, Nonces)␊
              returns (uint256)␊
          {␊
              return super.nonces(owner);␊
          }␊
      }␊
      `,
      `import { HardhatUserConfig } from "hardhat/config";␊
      import "@nomicfoundation/hardhat-toolbox";␊
      ␊
      ␊
      const config: HardhatUserConfig = {␊
        solidity: {␊
          version: "0.8.27",␊
          settings: {␊
            optimizer: {␊
              enabled: true,␊
            },␊
          },␊
        },␊
      };␊
      ␊
      export default config;␊
      `,
      `{␊
        "name": "hardhat-sample",␊
        "version": "0.0.1",␊
        "description": "",␊
        "main": "index.js",␊
        "scripts": {␊
          "test": "hardhat test"␊
        },␊
        "author": "",␊
        "license": "MIT",␊
        "devDependencies": {␊
          "@openzeppelin/contracts": "^5.4.0",␊
          "@nomicfoundation/hardhat-toolbox": "^6.1.0",␊
          "hardhat": "^2.16.1"␊
        }␊
      }`,
      `import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";␊
      ␊
      export default buildModule("MyTokenModule", (m) => {␊
      ␊
        // TODO: Set addresses for the contract arguments below␊
        const myToken = m.contract("MyToken", [recipient, defaultAdmin, pauser, minter]);␊
      ␊
        return { myToken };␊
      });␊
      `,
      `import { expect } from "chai";␊
      import { ethers } from "hardhat";␊
      ␊
      describe("MyToken", function () {␊
        it("Test contract", async function () {␊
          const ContractFactory = await ethers.getContractFactory("MyToken");␊
      ␊
          const recipient = (await ethers.getSigners())[0].address;␊
          const defaultAdmin = (await ethers.getSigners())[1].address;␊
          const pauser = (await ethers.getSigners())[2].address;␊
          const minter = (await ethers.getSigners())[3].address;␊
      ␊
          const instance = await ContractFactory.deploy(recipient, defaultAdmin, pauser, minter);␊
          await instance.waitForDeployment();␊
      ␊
          expect(await instance.name()).to.equal("My Token");␊
        });␊
      });␊
      `,
    ]

## erc20 ownable, uups, crossChainBridging custom

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Contracts ^5.4.0␊
      pragma solidity ^0.8.27;␊
      ␊
      import {ERC20Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol";␊
      import {ERC20BridgeableUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20BridgeableUpgradeable.sol";␊
      import {ERC20BurnableUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20BurnableUpgradeable.sol";␊
      import {ERC20FlashMintUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20FlashMintUpgradeable.sol";␊
      import {ERC20PausableUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PausableUpgradeable.sol";␊
      import {ERC20PermitUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20PermitUpgradeable.sol";␊
      import {ERC20VotesUpgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol";␊
      import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
      import {NoncesUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/NoncesUpgradeable.sol";␊
      import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";␊
      import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
      ␊
      contract MyToken is Initializable, ERC20Upgradeable, ERC20BridgeableUpgradeable, ERC20BurnableUpgradeable, ERC20PausableUpgradeable, OwnableUpgradeable, ERC20PermitUpgradeable, ERC20VotesUpgradeable, ERC20FlashMintUpgradeable, UUPSUpgradeable {␊
          address public tokenBridge;␊
          error Unauthorized();␊
      ␊
          /// @custom:oz-upgrades-unsafe-allow constructor␊
          constructor() {␊
              _disableInitializers();␊
          }␊
      ␊
          function initialize(address tokenBridge_, address recipient, address initialOwner)␊
              public initializer␊
          {␊
              __ERC20_init("My Token", "MTK");␊
              __ERC20Bridgeable_init();␊
              __ERC20Burnable_init();␊
              __ERC20Pausable_init();␊
              __Ownable_init(initialOwner);␊
              __ERC20Permit_init("My Token");␊
              __ERC20Votes_init();␊
              __ERC20FlashMint_init();␊
              __UUPSUpgradeable_init();␊
      ␊
              require(tokenBridge_ != address(0), "Invalid tokenBridge_ address");␊
              tokenBridge = tokenBridge_;␊
              if (block.chainid == 10) {␊
                  _mint(recipient, 2000 * 10 ** decimals());␊
              }␊
          }␊
      ␊
          function _checkTokenBridge(address caller) internal view override {␊
              if (caller != tokenBridge) revert Unauthorized();␊
          }␊
      ␊
          function pause() public onlyOwner {␊
              _pause();␊
          }␊
      ␊
          function unpause() public onlyOwner {␊
              _unpause();␊
          }␊
      ␊
          function mint(address to, uint256 amount) public onlyOwner {␊
              _mint(to, amount);␊
          }␊
      ␊
          function _authorizeUpgrade(address newImplementation)␊
              internal␊
              override␊
              onlyOwner␊
          {}␊
      ␊
          // The following functions are overrides required by Solidity.␊
      ␊
          function _update(address from, address to, uint256 value)␊
              internal␊
              override(ERC20Upgradeable, ERC20PausableUpgradeable, ERC20VotesUpgradeable)␊
          {␊
              super._update(from, to, value);␊
          }␊
      ␊
          function nonces(address owner)␊
              public␊
              view␊
              override(ERC20PermitUpgradeable, NoncesUpgradeable)␊
              returns (uint256)␊
          {␊
              return super.nonces(owner);␊
          }␊
      }␊
      `,
      `import { HardhatUserConfig } from "hardhat/config";␊
      import "@nomicfoundation/hardhat-toolbox";␊
      import "@openzeppelin/hardhat-upgrades";␊
      ␊
      const config: HardhatUserConfig = {␊
        solidity: {␊
          version: "0.8.27",␊
          settings: {␊
            optimizer: {␊
              enabled: true,␊
            },␊
          },␊
        },␊
      };␊
      ␊
      export default config;␊
      `,
      `{␊
        "name": "hardhat-sample",␊
        "version": "0.0.1",␊
        "description": "",␊
        "main": "index.js",␊
        "scripts": {␊
          "test": "hardhat test"␊
        },␊
        "author": "",␊
        "license": "MIT",␊
        "devDependencies": {␊
          "@openzeppelin/contracts": "^5.4.0",␊
          "@openzeppelin/contracts-upgradeable": "^5.4.0",␊
          "@openzeppelin/hardhat-upgrades": "^3.0.0",␊
          "@nomicfoundation/hardhat-toolbox": "^6.1.0",␊
          "hardhat": "^2.16.1"␊
        }␊
      }`,
      `import { ethers, upgrades } from "hardhat";␊
      ␊
      async function main() {␊
        const ContractFactory = await ethers.getContractFactory("MyToken");␊
      ␊
        // TODO: Set addresses for the contract arguments below␊
        const instance = await upgrades.deployProxy(ContractFactory, [tokenBridge_, recipient, initialOwner]);␊
        await instance.waitForDeployment();␊
      ␊
        console.log(\`Proxy deployed to ${await instance.getAddress()}\`);␊
      }␊
      ␊
      // We recommend this pattern to be able to use async/await everywhere␊
      // and properly handle errors.␊
      main().catch((error) => {␊
        console.error(error);␊
        process.exitCode = 1;␊
      });␊
      `,
      `import { expect } from "chai";␊
      import { ethers, upgrades } from "hardhat";␊
      ␊
      describe("MyToken", function () {␊
        it("Test contract", async function () {␊
          const ContractFactory = await ethers.getContractFactory("MyToken");␊
      ␊
          const tokenBridge_ = (await ethers.getSigners())[0].address;␊
          const recipient = (await ethers.getSigners())[1].address;␊
          const initialOwner = (await ethers.getSigners())[2].address;␊
      ␊
          const instance = await upgrades.deployProxy(ContractFactory, [tokenBridge_, recipient, initialOwner]);␊
          await instance.waitForDeployment();␊
      ␊
          expect(await instance.name()).to.equal("My Token");␊
        });␊
      });␊
      `,
    ]

## erc721 upgradeable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Contracts ^5.4.0␊
      pragma solidity ^0.8.27;␊
      ␊
      import {ERC721Upgradeable} from "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol";␊
      import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
      import {OwnableUpgradeable} from "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";␊
      import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
      ␊
      contract MyToken is Initializable, ERC721Upgradeable, OwnableUpgradeable, UUPSUpgradeable {␊
          /// @custom:oz-upgrades-unsafe-allow constructor␊
          constructor() {␊
              _disableInitializers();␊
          }␊
      ␊
          function initialize(address initialOwner) public initializer {␊
              __ERC721_init("My Token", "MTK");␊
              __Ownable_init(initialOwner);␊
              __UUPSUpgradeable_init();␊
          }␊
      ␊
          function _authorizeUpgrade(address newImplementation)␊
              internal␊
              override␊
              onlyOwner␊
          {}␊
      }␊
      `,
      `import { HardhatUserConfig } from "hardhat/config";␊
      import "@nomicfoundation/hardhat-toolbox";␊
      import "@openzeppelin/hardhat-upgrades";␊
      ␊
      const config: HardhatUserConfig = {␊
        solidity: {␊
          version: "0.8.27",␊
          settings: {␊
            optimizer: {␊
              enabled: true,␊
            },␊
          },␊
        },␊
      };␊
      ␊
      export default config;␊
      `,
      `{␊
        "name": "hardhat-sample",␊
        "version": "0.0.1",␊
        "description": "",␊
        "main": "index.js",␊
        "scripts": {␊
          "test": "hardhat test"␊
        },␊
        "author": "",␊
        "license": "MIT",␊
        "devDependencies": {␊
          "@openzeppelin/contracts": "^5.4.0",␊
          "@openzeppelin/contracts-upgradeable": "^5.4.0",␊
          "@openzeppelin/hardhat-upgrades": "^3.0.0",␊
          "@nomicfoundation/hardhat-toolbox": "^6.1.0",␊
          "hardhat": "^2.16.1"␊
        }␊
      }`,
      `import { ethers, upgrades } from "hardhat";␊
      ␊
      async function main() {␊
        const ContractFactory = await ethers.getContractFactory("MyToken");␊
      ␊
        // TODO: Set addresses for the contract arguments below␊
        const instance = await upgrades.deployProxy(ContractFactory, [initialOwner]);␊
        await instance.waitForDeployment();␊
      ␊
        console.log(\`Proxy deployed to ${await instance.getAddress()}\`);␊
      }␊
      ␊
      // We recommend this pattern to be able to use async/await everywhere␊
      // and properly handle errors.␊
      main().catch((error) => {␊
        console.error(error);␊
        process.exitCode = 1;␊
      });␊
      `,
      `import { expect } from "chai";␊
      import { ethers, upgrades } from "hardhat";␊
      ␊
      describe("MyToken", function () {␊
        it("Test contract", async function () {␊
          const ContractFactory = await ethers.getContractFactory("MyToken");␊
      ␊
          const initialOwner = (await ethers.getSigners())[0].address;␊
      ␊
          const instance = await upgrades.deployProxy(ContractFactory, [initialOwner]);␊
          await instance.waitForDeployment();␊
      ␊
          expect(await instance.name()).to.equal("My Token");␊
        });␊
      });␊
      `,
    ]

## erc1155 basic

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Contracts ^5.4.0␊
      pragma solidity ^0.8.27;␊
      ␊
      import {ERC1155} from "@openzeppelin/contracts/token/ERC1155/ERC1155.sol";␊
      import {Ownable} from "@openzeppelin/contracts/access/Ownable.sol";␊
      ␊
      contract MyToken is ERC1155, Ownable {␊
          constructor(address initialOwner)␊
              ERC1155("https://myuri/{id}")␊
              Ownable(initialOwner)␊
          {}␊
      ␊
          function setURI(string memory newuri) public onlyOwner {␊
              _setURI(newuri);␊
          }␊
      }␊
      `,
      `import { HardhatUserConfig } from "hardhat/config";␊
      import "@nomicfoundation/hardhat-toolbox";␊
      ␊
      ␊
      const config: HardhatUserConfig = {␊
        solidity: {␊
          version: "0.8.27",␊
          settings: {␊
            optimizer: {␊
              enabled: true,␊
            },␊
          },␊
        },␊
      };␊
      ␊
      export default config;␊
      `,
      `{␊
        "name": "hardhat-sample",␊
        "version": "0.0.1",␊
        "description": "",␊
        "main": "index.js",␊
        "scripts": {␊
          "test": "hardhat test"␊
        },␊
        "author": "",␊
        "license": "MIT",␊
        "devDependencies": {␊
          "@openzeppelin/contracts": "^5.4.0",␊
          "@nomicfoundation/hardhat-toolbox": "^6.1.0",␊
          "hardhat": "^2.16.1"␊
        }␊
      }`,
      `import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";␊
      ␊
      export default buildModule("MyTokenModule", (m) => {␊
      ␊
        // TODO: Set addresses for the contract arguments below␊
        const myToken = m.contract("MyToken", [initialOwner]);␊
      ␊
        return { myToken };␊
      });␊
      `,
      `import { expect } from "chai";␊
      import { ethers } from "hardhat";␊
      ␊
      describe("MyToken", function () {␊
        it("Test contract", async function () {␊
          const ContractFactory = await ethers.getContractFactory("MyToken");␊
      ␊
          const initialOwner = (await ethers.getSigners())[0].address;␊
      ␊
          const instance = await ContractFactory.deploy(initialOwner);␊
          await instance.waitForDeployment();␊
      ␊
          expect(await instance.uri(0)).to.equal("https://myuri/{id}");␊
        });␊
      });␊
      `,
    ]

## account ecdsa

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Contracts ^5.4.0␊
      pragma solidity ^0.8.27;␊
      ␊
      import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
      import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
      import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
      import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
      import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
      import {Initializable} from "@openzeppelin/contracts/proxy/utils/Initializable.sol";␊
      import {SignerECDSA} from "@openzeppelin/contracts/utils/cryptography/signers/SignerECDSA.sol";␊
      ␊
      contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerECDSA, ERC721Holder, ERC1155Holder {␊
          /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
          constructor(address signer) EIP712("My Account", "1") SignerECDSA(signer) {␊
              // Accounts are typically deployed and initialized as clones during their first user op,␊
              // therefore, initializers are disabled for the implementation contract␊
              _disableInitializers();␊
          }␊
      ␊
          function initialize(address signer) public initializer {␊
              _setSigner(signer);␊
          }␊
      }␊
      `,
      `import { HardhatUserConfig } from "hardhat/config";␊
      import "@nomicfoundation/hardhat-toolbox";␊
      ␊
      ␊
      const config: HardhatUserConfig = {␊
        solidity: {␊
          version: "0.8.27",␊
          settings: {␊
            optimizer: {␊
              enabled: true,␊
            },␊
          },␊
        },␊
      };␊
      ␊
      export default config;␊
      `,
      `{␊
        "name": "hardhat-sample",␊
        "version": "0.0.1",␊
        "description": "",␊
        "main": "index.js",␊
        "scripts": {␊
          "test": "hardhat test"␊
        },␊
        "author": "",␊
        "license": "MIT",␊
        "devDependencies": {␊
          "@openzeppelin/contracts": "^5.4.0",␊
          "@nomicfoundation/hardhat-toolbox": "^6.1.0",␊
          "hardhat": "^2.16.1"␊
        }␊
      }`,
      `import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";␊
      ␊
      export default buildModule("MyAccountModule", (m) => {␊
      ␊
        // TODO: Set addresses for the contract arguments below␊
        const myAccount = m.contract("MyAccount", [signer]);␊
      ␊
        return { myAccount };␊
      });␊
      `,
      `import { expect } from "chai";␊
      import { ethers } from "hardhat";␊
      ␊
      describe("MyAccount", function () {␊
        it("Test contract", async function () {␊
          const ContractFactory = await ethers.getContractFactory("MyAccount");␊
      ␊
          const signer = (await ethers.getSigners())[0].address;␊
      ␊
          const instance = await ContractFactory.deploy(signer);␊
          await instance.waitForDeployment();␊
        });␊
      });␊
      `,
    ]

## account ecdsa uups

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Contracts ^5.4.0␊
      pragma solidity ^0.8.27;␊
      ␊
      import {Account} from "@openzeppelin/contracts/account/Account.sol";␊
      import {EIP712} from "@openzeppelin/contracts/utils/cryptography/EIP712.sol";␊
      import {ERC1155Holder} from "@openzeppelin/contracts/token/ERC1155/utils/ERC1155Holder.sol";␊
      import {ERC721Holder} from "@openzeppelin/contracts/token/ERC721/utils/ERC721Holder.sol";␊
      import {ERC7739} from "@openzeppelin/contracts/utils/cryptography/signers/draft-ERC7739.sol";␊
      import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
      import {SignerECDSAUpgradeable} from "@openzeppelin/contracts-upgradeable/utils/cryptography/signers/SignerECDSAUpgradeable.sol";␊
      import {UUPSUpgradeable} from "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";␊
      ␊
      contract MyAccount is Initializable, Account, EIP712, ERC7739, SignerECDSAUpgradeable, ERC721Holder, ERC1155Holder, UUPSUpgradeable {␊
          /// @custom:oz-upgrades-unsafe-allow-reachable constructor␊
          constructor() EIP712("My Account", "1") {␊
              _disableInitializers();␊
          }␊
      ␊
          function initialize(address signer) public initializer {␊
              __SignerECDSA_init(signer);␊
          }␊
      ␊
          function _authorizeUpgrade(address newImplementation)␊
              internal␊
              override␊
              onlyEntryPointOrSelf␊
          {}␊
      }␊
      `,
      `import { HardhatUserConfig } from "hardhat/config";␊
      import "@nomicfoundation/hardhat-toolbox";␊
      ␊
      ␊
      const config: HardhatUserConfig = {␊
        solidity: {␊
          version: "0.8.27",␊
          settings: {␊
            optimizer: {␊
              enabled: true,␊
            },␊
          },␊
        },␊
      };␊
      ␊
      export default config;␊
      `,
      `{␊
        "name": "hardhat-sample",␊
        "version": "0.0.1",␊
        "description": "",␊
        "main": "index.js",␊
        "scripts": {␊
          "test": "hardhat test"␊
        },␊
        "author": "",␊
        "license": "MIT",␊
        "devDependencies": {␊
          "@openzeppelin/contracts": "^5.4.0",␊
          "@openzeppelin/contracts-upgradeable": "^5.4.0",␊
          "@openzeppelin/hardhat-upgrades": "^3.0.0",␊
          "@nomicfoundation/hardhat-toolbox": "^6.1.0",␊
          "hardhat": "^2.16.1"␊
        }␊
      }`,
      `import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";␊
      ␊
      export default buildModule("MyAccountModule", (m) => {␊
      ␊
        ␊
        const myAccount = m.contract("MyAccount", []);␊
      ␊
        return { myAccount };␊
      });␊
      `,
      `import { expect } from "chai";␊
      import { ethers } from "hardhat";␊
      ␊
      describe("MyAccount", function () {␊
        it("Test contract", async function () {␊
          const ContractFactory = await ethers.getContractFactory("MyAccount");␊
      ␊
          const instance = await ContractFactory.deploy();␊
          await instance.waitForDeployment();␊
        });␊
      });␊
      `,
    ]

## custom basic

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Contracts ^5.4.0␊
      pragma solidity ^0.8.27;␊
      ␊
      contract MyContract {␊
      }␊
      `,
      `import { HardhatUserConfig } from "hardhat/config";␊
      import "@nomicfoundation/hardhat-toolbox";␊
      ␊
      ␊
      const config: HardhatUserConfig = {␊
        solidity: {␊
          version: "0.8.27",␊
          settings: {␊
            optimizer: {␊
              enabled: true,␊
            },␊
          },␊
        },␊
      };␊
      ␊
      export default config;␊
      `,
      `{␊
        "name": "hardhat-sample",␊
        "version": "0.0.1",␊
        "description": "",␊
        "main": "index.js",␊
        "scripts": {␊
          "test": "hardhat test"␊
        },␊
        "author": "",␊
        "license": "MIT",␊
        "devDependencies": {␊
          "@openzeppelin/contracts": "^5.4.0",␊
          "@nomicfoundation/hardhat-toolbox": "^6.1.0",␊
          "hardhat": "^2.16.1"␊
        }␊
      }`,
      `import { buildModule } from "@nomicfoundation/hardhat-ignition/modules";␊
      ␊
      export default buildModule("MyContractModule", (m) => {␊
      ␊
        ␊
        const myContract = m.contract("MyContract", []);␊
      ␊
        return { myContract };␊
      });␊
      `,
      `import { expect } from "chai";␊
      import { ethers } from "hardhat";␊
      ␊
      describe("MyContract", function () {␊
        it("Test contract", async function () {␊
          const ContractFactory = await ethers.getContractFactory("MyContract");␊
      ␊
          const instance = await ContractFactory.deploy();␊
          await instance.waitForDeployment();␊
        });␊
      });␊
      `,
    ]

## custom upgradeable

> Snapshot 1

    [
      `// SPDX-License-Identifier: MIT␊
      // Compatible with OpenZeppelin Contracts ^5.4.0␊
      pragma solidity ^0.8.27;␊
      ␊
      import {Initializable} from "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";␊
      ␊
      contract MyContract is Initializable {␊
          /// @custom:oz-upgrades-unsafe-allow constructor␊
          constructor() {␊
              _disableInitializers();␊
          }␊
      }␊
      `,
      `import { HardhatUserConfig } from "hardhat/config";␊
      import "@nomicfoundation/hardhat-toolbox";␊
      import "@openzeppelin/hardhat-upgrades";␊
      ␊
      const config: HardhatUserConfig = {␊
        solidity: {␊
          version: "0.8.27",␊
          settings: {␊
            optimizer: {␊
              enabled: true,␊
            },␊
          },␊
        },␊
      };␊
      ␊
      export default config;␊
      `,
      `{␊
        "name": "hardhat-sample",␊
        "version": "0.0.1",␊
        "description": "",␊
        "main": "index.js",␊
        "scripts": {␊
          "test": "hardhat test"␊
        },␊
        "author": "",␊
        "license": "MIT",␊
        "devDependencies": {␊
          "@openzeppelin/contracts": "^5.4.0",␊
          "@openzeppelin/contracts-upgradeable": "^5.4.0",␊
          "@openzeppelin/hardhat-upgrades": "^3.0.0",␊
          "@nomicfoundation/hardhat-toolbox": "^6.1.0",␊
          "hardhat": "^2.16.1"␊
        }␊
      }`,
      `import { ethers, upgrades } from "hardhat";␊
      ␊
      async function main() {␊
        const ContractFactory = await ethers.getContractFactory("MyContract");␊
      ␊
        ␊
        const instance = await upgrades.deployProxy(ContractFactory, []);␊
        await instance.waitForDeployment();␊
      ␊
        console.log(\`Proxy deployed to ${await instance.getAddress()}\`);␊
      }␊
      ␊
      // We recommend this pattern to be able to use async/await everywhere␊
      // and properly handle errors.␊
      main().catch((error) => {␊
        console.error(error);␊
        process.exitCode = 1;␊
      });␊
      `,
      `import { expect } from "chai";␊
      import { ethers, upgrades } from "hardhat";␊
      ␊
      describe("MyContract", function () {␊
        it("Test contract", async function () {␊
          const ContractFactory = await ethers.getContractFactory("MyContract");␊
      ␊
          const instance = await upgrades.deployProxy(ContractFactory, []);␊
          await instance.waitForDeployment();␊
        });␊
      });␊
      `,
    ]
