import JSZip from "jszip";
import type { Contract } from "../contract";
import { printContract } from "../print";
import { hardhatPackageLock } from "./lockHardhat";
import { hardhatUpgradeablePackageLock } from "./lockHardhatUpgradeable";

const hardhatConfig = (upgradeable: boolean) => `\
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";${upgradeable ? `
import "@openzeppelin/hardhat-upgrades";` : ''}

const config: HardhatUserConfig = {
  solidity: {
    version: "0.8.17",
    settings: {
      optimizer: {
        enabled: true,
      },
    },
  }
};

export default config;
`;

const packageJson = (upgradeable: boolean) => `\
{
  "name": "hardhat-sample",
  "version": "0.0.1",
  "description": "",
  "main": "index.js",
  "scripts": {
    "test": "npx hardhat test"
  },
  "author": "",
  "license": "ISC",
  "devDependencies": {
    "@nomicfoundation/hardhat-toolbox": "^2.0.0",
    ${upgradeable ? `"@openzeppelin/contracts-upgradeable" : "^4.7.3",
    "@openzeppelin/hardhat-upgrades": "^1.21.0",
    "@nomiclabs/hardhat-ethers": "^2.2.0",
    "ethers": "^5.7.1",`
    :
    `"@openzeppelin/contracts" : "^4.7.3",`
    }
    "hardhat": "^2.11.2"
  }
}
`

const tsConfig = `\
{
  "compilerOptions": {
    "target": "es2020",
    "module": "commonjs",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "strict": true,
    "skipLibCheck": true
  }
}
`

const gitIgnore = `\
node_modules
.env
coverage
coverage.json
typechain
typechain-types

#Hardhat files
cache
artifacts
`

const test = (c: Contract, nameOpt?: string) => `\
import { expect } from "chai";
import { ethers${c.upgradeable ? ', upgrades' : ''} } from "hardhat";

describe("${c.name}", function () {
  it("Should return token name", async function () {
    const ContractFactory = await ethers.getContractFactory("${c.name}");

    const instance = await ${c.upgradeable ? 'upgrades.deployProxy(ContractFactory);' : 'ContractFactory.deploy();' }
    await instance.deployed();

    expect(await instance.name()).to.equal("${nameOpt ?? c.name}");
  });
});
`

const script = (c: Contract) => `\
import { ethers${c.upgradeable ? ', upgrades' : ''} } from "hardhat";

async function main() {
  const ContractFactory = await ethers.getContractFactory("${c.name}");

  const instance = await ${c.upgradeable ? 'upgrades.deployProxy(ContractFactory);' : 'ContractFactory.deploy();' }
  await instance.deployed();

  console.log(\`${c.upgradeable ? 'Proxy' : 'Contract'} deployed to \${instance.address}\`);
}

// We recommend this pattern to be able to use async/await everywhere
// and properly handle errors.
main().catch((error) => {
  console.error(error);
  process.exitCode = 1;
});
`

const readme = `\
# Sample Hardhat Project

This project demonstrates a basic Hardhat use case. It comes with a contract generated by [OpenZeppelin Wizard](https://wizard.openzeppelin.com/), a test for that contract, and a script that deploys that contract.

## Installing dependencies

\`\`\`shell
npm install
\`\`\`

## Testing the contract

\`\`\`shell
npm test
\`\`\`

## Deploying the contract

You can target any network from your Hardhat config using:

\`\`\`shell
npx hardhat run --network <your-network> scripts/deploy.js
\`\`\`
`

export function zipHardhat(c: Contract, nameOpt?: string) {
  const zip = new JSZip();

  zip.file('hardhat.config.ts', hardhatConfig(c.upgradeable));
  zip.file('package.json', packageJson(c.upgradeable));
  zip.file('README.md', readme);
  zip.file('tsconfig.json', tsConfig);
  zip.file('.gitignore', gitIgnore);
  zip.file('test/test.ts', test(c, nameOpt));
  zip.file('scripts/deploy.ts', script(c));

  zip.file(`contracts/${c.name}.sol`, printContract(c));

  zip.file(`package-lock.json`, c.upgradeable ? hardhatUpgradeablePackageLock : hardhatPackageLock);

  return zip;
}