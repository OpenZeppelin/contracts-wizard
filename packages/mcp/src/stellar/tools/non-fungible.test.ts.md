# Snapshot report for `src/stellar/tools/non-fungible.test.ts`

The actual snapshot is saved in `non-fungible.test.ts.snap`.

Generated by [AVA](https://avajs.dev).

## basic

> Snapshot 1

    `// SPDX-License-Identifier: MIT␊
    // Compatible with OpenZeppelin Stellar Soroban Contracts ^0.2.0␊
    #![no_std]␊
    ␊
    use soroban_sdk::{Address, contract, contractimpl, Env, String};␊
    use stellar_non_fungible::{Base, NonFungibleToken};␊
    ␊
    #[contract]␊
    pub struct TestToken;␊
    ␊
    #[contractimpl]␊
    impl TestToken {␊
        pub fn __constructor(e: &Env) {␊
            Base::set_metadata(e, String::from_str(e, "www.mytoken.com"), String::from_str(e, "TestToken"), String::from_str(e, "TST"));␊
        }␊
    }␊
    ␊
    #[contractimpl]␊
    impl NonFungibleToken for TestToken {␊
        type ContractType = Base;␊
    ␊
        fn owner_of(e: &Env, token_id: u32) -> Address {␊
            Self::ContractType::owner_of(e, token_id)␊
        }␊
    ␊
        fn transfer(e: &Env, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer(e, &from, &to, token_id);␊
        }␊
    ␊
        fn transfer_from(e: &Env, spender: Address, from: Address, to: Address, token_id: u32) {␊
            Self::ContractType::transfer_from(e, &spender, &from, &to, token_id);␊
        }␊
    ␊
        fn balance(e: &Env, owner: Address) -> u32 {␊
            Self::ContractType::balance(e, &owner)␊
        }␊
    ␊
        fn approve(␊
            e: &Env,␊
            approver: Address,␊
            approved: Address,␊
            token_id: u32,␊
            live_until_ledger: u32,␊
        ) {␊
            Self::ContractType::approve(e, &approver, &approved, token_id, live_until_ledger);␊
        }␊
    ␊
        fn approve_for_all(e: &Env, owner: Address, operator: Address, live_until_ledger: u32) {␊
            Self::ContractType::approve_for_all(e, &owner, &operator, live_until_ledger);␊
        }␊
    ␊
        fn get_approved(e: &Env, token_id: u32) -> Option<Address> {␊
            Self::ContractType::get_approved(e, token_id)␊
        }␊
    ␊
        fn is_approved_for_all(e: &Env, owner: Address, operator: Address) -> bool {␊
            Self::ContractType::is_approved_for_all(e, &owner, &operator)␊
        }␊
    ␊
        fn name(e: &Env) -> String {␊
            Self::ContractType::name(e)␊
        }␊
    ␊
        fn symbol(e: &Env) -> String {␊
            Self::ContractType::symbol(e)␊
        }␊
    ␊
        fn token_uri(e: &Env, token_id: u32) -> String {␊
            Self::ContractType::token_uri(e, token_id)␊
        }␊
    }␊
    `

## all

> Snapshot 1

    `Invalid options␊
    ␊
    {␊
      "enumerable": "Enumerable cannot be used with Consecutive extension",␊
      "consecutive": "Consecutive cannot be used with Sequential minting",␊
      "mintable": "Mintable cannot be used with Consecutive extension",␊
      "sequential": "Sequential minting cannot be used with Consecutive extension"␊
    }`
